# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_JStransform.ipynb.

# %% ../nbs/02_JStransform.ipynb 1
from __future__ import annotations

# %% auto 0
__all__ = ['JSImportTransform']

# %% ../nbs/02_JStransform.ipynb
import fastcore.all as FC
import tree_sitter_javascript as tsjs
from tree_sitter import Language
from tree_sitter import Parser


# %% ../nbs/02_JStransform.ipynb
def _string_content(node):
    return ''.join(c.text.decode() for c in node.children if c.type == 'string_fragment')

# %% ../nbs/02_JStransform.ipynb
def _import_specifiers(node):
    specifiers = []
    for child in node.children:
        if child.type == 'import_specifier':
            if (l := len(child.children)) == 1:
                name = child.children[0].text.decode()
                specifiers.append({'imported': name, 'local': name})
            elif l == 3:
                imported, local = child.children[0].text.decode(), child.children[2].text.decode()
                specifiers.append({'imported': imported, 'local': local})
    return specifiers

# %% ../nbs/02_JStransform.ipynb
def _extract_comments(node, code_bytes, comment_marker):
    "Extract all comments from AST with their line positions."
    comments = []
    marker = f"@{comment_marker[0]}"
    ignore_cmd = comment_marker[1][0]
    def walk(node):
        if node.type == 'comment' and marker in node.text.decode() and ignore_cmd in node.text.decode():
            line = node.start_point[0]
            is_line_comment = node.prev_sibling is None or (
                node.prev_sibling.start_point[0] < line and 
                (node.next_sibling is None or node.next_sibling.start_point[0] > line)
            )
            comments.append({
                'text': node.text.decode(),
                'line': line,  # 0-indexed line number
                'start_byte': node.start_byte,
                'end_byte': node.end_byte,
                'is_line_comment': is_line_comment,
            })
        for child in node.children:
            walk(child)
    walk(node)
    return comments

# %% ../nbs/02_JStransform.ipynb
def _should_ignore_import(import_node, comments):
    "Check if import should be ignored based on nearby comments."
    import_line = import_node.start_point[0]
    
    for comment in comments:
        comment_line = comment['line']
        # Check same line or previous line
        if comment_line == import_line: return True
        if comment_line == import_line - 1 and comment['is_line_comment']: return True
    return False

# %% ../nbs/02_JStransform.ipynb
def _validate_import_statement(import_node, code):
    def walk(node):
        if node.type == 'ERROR' or node.type == 'MISSING':
            original_text = code[import_node.start_byte:import_node.end_byte].decode()
            raise ValueError(f"Malformed import statement: {original_text}")
        for child in node.children: walk(child)
    walk(import_node)


def _parse_import_statement(import_node):
    "Parse import_statement node into structured data."
    result = {
        'source': None, 'default_import': None, 'named_imports': [],
        'namespace_import': None, 'side_effect_only': False,
        'has_mixed_default_namespace': False
    }
    for c in import_node.children:
        if c.type == 'string': 
            result['source'] = _string_content(c); break
    if not (import_clause := FC.first(import_node.children, lambda c:c.type == 'import_clause')):
        result['side_effect_only'] = True
        return result
    has_default = has_namespace = False
    for c in import_clause.children:
        if c.type == 'identifier':
            result['default_import'] = c.text.decode()
            has_default = True
        elif c.type == 'named_imports':
            result['named_imports'] = _import_specifiers(c)
        elif c.type == 'namespace_import':
            has_namespace = True
            result['namespace_import'] = FC.first(c.children, lambda c: c.type == 'identifier').text.decode()  # type: ignore
    result['has_mixed_default_namespace'] = has_default and has_namespace
    return result

# %% ../nbs/02_JStransform.ipynb
def _generate_dynamic_import(import_data, fn):
    "Generate dynamic import equivalent from parsed import data."
    source = import_data['source']
    if import_data['side_effect_only']: return f'await {fn}("{source}");'
    if import_data['has_mixed_default_namespace']:
        ns_name = import_data['namespace_import']
        default_name = import_data['default_import']
        return f'const {ns_name} = await {fn}("{source}");\nconst {default_name} = {ns_name}.default;'
    if import_data['namespace_import'] and not import_data['default_import']:
        return f'const {import_data["namespace_import"]} = await {fn}("{source}");'
    # Build destructuring for default and/or named imports
    parts = []
    if import_data['default_import']: parts.append(f'default: {import_data["default_import"]}')
    parts.extend(
        spec['imported'] if spec['imported'] == spec['local'] 
        else f'{spec["imported"]}: {spec["local"]}'
        for spec in import_data['named_imports']
    )
    return f'const {{{", ".join(parts)}}} = await {fn}("{source}");' if parts else f'await {fn}("{source}");'

# %% ../nbs/02_JStransform.ipynb
# def _find_all_imports(node, code, fn):
#     static_imports, dynamic_imports = [], []
#     def walk(node):
#         if node.type == 'import_statement':
#             _validate_import_statement(node, code)
#             import_data = _parse_import_statement(node)
#             replace = _generate_dynamic_import(import_data, fn)
#             static_imports.append({'start': node.start_byte, 'end': node.end_byte, 'replace': replace})
#         elif node.type == 'call_expression':
#             func = node.child_by_field_name('function')
#             if func and func.type == 'import':
#                 dynamic_imports.append({'start': func.start_byte, 'end': func.end_byte, 'replace': fn})
#         for child in node.children: walk(child)
#     walk(node)
#     return static_imports, dynamic_imports

def _find_all_imports(node, code, fn, comment_marker):
    static_imports, dynamic_imports = [], []
    comments = _extract_comments(node, code, comment_marker)  # Extract comments first
    
    def walk(node):
        if node.type == 'import_statement':
            if _should_ignore_import(node, comments):  # Check ignore
                return  # Skip this import
            _validate_import_statement(node, code)
            import_data = _parse_import_statement(node)
            replace = _generate_dynamic_import(import_data, fn)
            static_imports.append({'start': node.start_byte, 'end': node.end_byte, 'replace': replace})
        elif node.type == 'call_expression':
            func = node.child_by_field_name('function')
            if func and func.type == 'import':
                if _should_ignore_import(node, comments):  # Check ignore
                    return  # Skip this import
                dynamic_imports.append({'start': func.start_byte, 'end': func.end_byte, 'replace': fn})
        for child in node.children: 
            walk(child)
    walk(node)
    return static_imports, dynamic_imports

# %% ../nbs/02_JStransform.ipynb
def _replace(bytes, imports):
    "Replace ranges.`imports` is a list of dicts with `start`, `end`, and `replace` keys."
    imports.sort(key=lambda x: x['start'])
    res, prev_end = [None]*(2*len(imports) + 1), 0
    for i, info in enumerate(imports):
        res[2*i] = bytes[prev_end:info['start']]
        res[2*i+1] = info['replace'].encode('utf-8')
        prev_end = info['end']
    res[2*len(imports)] = bytes[prev_end:]
    res = b"".join(res)  # type: ignore
    return res

# %% ../nbs/02_JStransform.ipynb
class JSImportTransform:
    def __init__(self, import_name="import", comment_marker=('transform', ('ignore',))):
        self.import_name = import_name
        self.comment_marker = comment_marker
        self.parser = Parser(Language(tsjs.language()))

    def __call__(self, code):
        "Transform JS code, converting imports to dynamic and renaming import function."
        if isinstance(code, str): code = code.encode('utf-8')
        return self._transform(code).decode('utf-8')

    def _transform(self, code_bytes):
        tree = self.parser.parse(code_bytes)
        static_imports, dynamic_imports = _find_all_imports(tree.root_node, code_bytes, self.import_name, self.comment_marker)
        return _replace(code_bytes, static_imports + dynamic_imports)

    def _transform_static(self, code_bytes):
        "Transform static import statements to dynamic imports."
        tree = self.parser.parse(code_bytes)
        static_imports, _ = _find_all_imports(tree.root_node, code_bytes, self.import_name, self.comment_marker)
        return _replace(code_bytes, static_imports)

    def _transform_dynamic(self, code_bytes):
        "Transform dynamic import function names."
        tree = self.parser.parse(code_bytes)
        _, dynamic_imports = _find_all_imports(tree.root_node, code_bytes, self.import_name, self.comment_marker)
        return _replace(code_bytes, dynamic_imports)
