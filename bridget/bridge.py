# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/14_bridge.ipynb.

# %% ../nbs/14_bridge.ipynb 1
from __future__ import annotations

# %% auto 0
__all__ = ['defaultLogConfig', 'observer_js', 'bridge_default_plugins', 'debug', 'notdebug', 'to_js', 'ScriptsDetails',
           'bridge_scripts', 'show_scripts', 'get_bcanvas', 'BLogger', 'Links', 'load_links', 'BridgePlugin',
           'HTMXPlugin', 'show_summary', 'get_bridge']

# %% ../nbs/14_bridge.ipynb
from collections.abc import Sequence
from pathlib import Path
from typing import Any
from typing import overload
from urllib.parse import ParseResult

import anywidget
import fastcore.all as FC
import traitlets as T
from fastcore.all import L
from fastcore.all import NotStr
from fastcore.xml import escape
from fastcore.xml import to_xml
from fasthtml.core import FT
from fasthtml.xtend import Script
from IPython.display import clear_output
from IPython.display import display
from pote.basic import bundle_path
from pote.common import shorten
from pote.common import shortens
from pote.common import update_


# %% ../nbs/14_bridge.ipynb
from fasthtml.components import B, Details, Summary, Pre

# %% ../nbs/14_bridge.ipynb
from .bridge_widget import anysource
from .bridge_widget import blocks
from .bridge_widget import BridgeWidget
from .bridge_widget import bundled
from .bridge_widget import resolve_ESM
from .helpers import Brd_Mark
from .helpers import brdmark_js
from .helpers import bridge_cfg
from .helpers import DEBUG
from .helpers import HTML
from .helpers import id_gen
from .logger import FCanvas
from .logger import FCanvas_css
from .logger import FLogger
from .logger import NBLogger
from .logger import NoopLogger
from .nb import NB


# %% ../nbs/14_bridge.ipynb
new_id = id_gen()
BUNDLE_PATH = bundle_path(__name__)
# bridge_cfg.for_module(__name__)

# %% ../nbs/14_bridge.ipynb
def debug(jsstr: str): return f"debugger;\n{jsstr}"
def notdebug(jsstr: str): return jsstr

# %% ../nbs/14_bridge.ipynb
def _to_js(ft):
    if isinstance(ft, FT): 
        return [ft.tag, [_to_js(_) for _ in ft.children], ft.attrs]
    return str(ft)

def to_js(*fts: FT|str):
    return f"[\n  {',\n  '.join(repr(_to_js(_)) if isinstance(_, FT) else repr(_) for _ in fts)}\n]"

# %% ../nbs/14_bridge.ipynb
def _safe(o, m='r', l=140): return escape(shorten(o, m, l), False)  # type: ignore

# %% ../nbs/14_bridge.ipynb
class ScriptsDetails:
    def __init__(self, scs, title='Loaded scripts', open=True): 
        self.scs = scs; self.title = title; self.open = open
    def __ft__(self):
        return Details(open=self.open)(
            Summary(B(self.title)),
            Pre(NotStr('\n'.join(escape(to_xml(_, indent=False, do_escape=False).strip()) for _ in self.scs))),
        )

# %% ../nbs/14_bridge.ipynb
def _bridge_scripts_extra():
    from fasthtml.core import surrsrc, scopesrc
    return {'surreal': surrsrc, 'css_scope_inline': scopesrc}

def bridge_scripts(htmx=True):
    from fasthtml.core import fhjsscr
    from fasthtml.xtend import Script
    htmxsrc = Script(src=f"https://unpkg.com/htmx.org@next/dist/htmx.{'' if DEBUG() else 'min.'}js")()
    return update_({'htmx': htmxsrc } if htmx else {}, fasthtml_js=fhjsscr, **_bridge_scripts_extra())

def show_scripts(**scs: FT): 
    display(HTML(ScriptsDetails(shortens(map(to_xml, scs.values()), 'r', 140))))

# %% ../nbs/14_bridge.ipynb
class BCanvas(FCanvas):
    _esm = '''
const { bcanvas } = await brdimport('./bcanvas.js');
export default { initialize({ model }) {
  bcanvas.setup(model);
  model.set('_loaded', true); model.save_changes();
  return () => {
    bcanvas.setup();
    model.set('_loaded', false); model.save_changes();
  }
}}
'''
    _css = FCanvas_css

# %% ../nbs/14_bridge.ipynb
__bcanvas__ = None

@FC.delegates(BCanvas, keep=True)  # type: ignore
def get_bcanvas(**kwargs):
    global __bcanvas__
    if not __bcanvas__:
        timeout, sleep = kwargs.pop('timeout', 2), kwargs.pop('sleep', 0.2)
        __bcanvas__ = BCanvas.create(timeout=timeout, sleep=sleep, **kwargs)
    return __bcanvas__

# %% ../nbs/14_bridge.ipynb
class BLogger(FLogger):
    canvas: BCanvas

    def _setup_canvas(self, height:int): self._canvas = get_bcanvas(height=height)
    def close_canvas(self): ...
    def msg(self, msg, clear:bool=False, ctx:str='logger', **kwargs):
        super().msg(msg, clear=clear, ctx=ctx, format=self.canvas is None or (not self.canvas.displayed()), **kwargs)

# %% ../nbs/14_bridge.ipynb
defaultLogConfig = {
    'ns': 'brd',
    'color': 'light-dark(gray, lightgray)', # #fdc400 darkgoldenrod gold
    'fmt': 'htmlFmt',
    'tsDelta': True,
    'INFO': {},
    'ERROR': {
        'color': 'red',
    },
    'WARN': {
        'color': 'LightSalmon',
    },
}

# %% ../nbs/14_bridge.ipynb
__brd__ = None

def _get_bridge(): return __brd__

def _set_bridge(value):
    global __brd__
    __brd__ = value


class BridgeBoot(BridgeWidget):
    _esm = '''
const { bcanvas } = await brdimport('./bcanvas.js');
const { initBridge } = await brdimport('./bridge.js');

export default { async initialize({ model, experimental }) {
// debugger;
  try {
    const cb = await initBridge(model, experimental.invoke);
    model.set('_loaded', true); model.save_changes();
    return () => { cb(); model.set('_loaded', false); model.save_changes(); };
  } catch (e) {
    console.error('Error initializing bridge', e);
  }
}}
'''
    _css = FCanvas_css

    ctx_name = T.Unicode('brd').tag(sync=True)
    logger = T.Instance(NBLogger, default_value=NoopLogger())
    logger_config = T.Dict(default_value=defaultLogConfig).tag(sync=True)

    def __init__(self, logger=None, show_logger=False, **kwargs):
        if logger is None: logger = BLogger(show=show_logger)
        elif show_logger: self.logger.show()
        self.on_msg(self._message_hdlr)
        super().__init__(logger=logger, **kwargs)
    @T.observe('_loaded')
    def _on_loaded(self, change):
        _set_bridge(self if change['new'] else None)
        self.log(f"<strong>The bridge is {('closed', 'open')[change['new']]}</strong>")
    def close(self):
        if self.comm is not None:
            self.send(dict(ctx=self.ctx_name, cmd='remove'))
            self._on_loaded(FC.AttrDict(new=False))
        super().close()

    def _message_hdlr(self, _, content, buffers):
        self.log(f"handle message: content=<code>{_safe(content)}</code>"
                f"{' buffers=><code>'+_safe(buffers)+'</code>' if buffers else ''}")

    def update_logger_config(self, **kwargs): self.logger_config = { **self.logger_config, **kwargs }

    def log(self, msg:Any, clear:bool=False): self.logger.msg(f"*{msg}", clear=clear, ctx=self.ctx_name, level='LOG')
    def error(self, msg:Any, clear:bool=False): self.logger.msg(f"*{msg}", clear=clear, ctx=self.ctx_name, level='ERROR')
    def warn(self, msg:Any, clear:bool=False): self.logger.msg(f"*{msg}", clear=clear, ctx=self.ctx_name, level='WARN')

# for n,l in _l2l.items(): setattr(BridgeBoot, n, partialmethod(BridgeBoot._log, level=l))

# %% ../nbs/14_bridge.ipynb
def handle_message(
        o: Any, 
        *args: Any, 
        ctx:str, kind:str, 
        prefix:str='on_', forward:bool=True, forward_name:str='_msg_fwrdr', 
        **kwargs: Any) -> bool:
    """if `o` has an attr named `ctx`, look for a handler with the form `on_{kind}` 
    passing the rest of `msg` and `args` to it. 
    If `forward`and `o` has an attr named with `forward_name`, call it with `o`, `msg` and `args`."""
    # print(f"handle_message: {o=} {args=} {ctx=}, {kind=} {kwargs=}")
    handled = False
    if o:
        if ctx in getattr(o, 'ctx_names', ()) and (fn := getattr(o, f"{prefix}{kind}", None)): fn(*args, **kwargs); handled = True
        if forward and (fn := getattr(o, forward_name, None)): fn(*args, ctx=ctx, kind=kind, **kwargs); handled = True
    return handled

# %% ../nbs/14_bridge.ipynb
@FC.delegates(BridgeBoot, keep=True)  # type: ignore
class BridgeMessenger(BridgeBoot):
    ctx_names: set[str]

    def __init__(self, **kwargs):
        self._pending = {}
        super().__init__(**kwargs)
        # Warning: As AnyWidget calls `self.add_traits()`, 
        # `self.__class__` before `super()__init__` is not `self.__class__` now
        self.ctx_names = set(L(type(self).mro()).attrgot('ctx_name.default_value').filter())

    def on_info(self, *args, info:str, **kwargs):
        "Handle 'info' messages from the front-end."
        if info == 'loaded':
            self.log(f"{self.__class__.__name__} loaded.")
            self.log(f"bridge_cfg: {vars(bridge_cfg)}")
        elif info == 'model-set':
            self.log(f"{self.__class__.__name__} model set.")
        elif info == 'model-unset':
            self.log(f"{self.__class__.__name__} model unset.")

    def on_error(self, *args, error:str, **kwargs):
        "Handle 'error' messages from the front-end."
        self.log(f"{self.__class__.__name__} error: {error}")

    def debug_enabled(self, ctx:str|None=None, enabled=True, **kwargs):
        "Switch debug logs."
        self.send({'ctx': self.ctx_name, 'cmd': 'debug', 
                'args': {'debug_ctx': ctx or self.ctx_name, 'enabled': enabled, **kwargs}})
    
    def msg(self, tracker:Any=None, **kwargs):
        "Compose a message with tracking."
        msg_id = new_id()
        if tracker: self._pending[msg_id] = tracker
        return update_(kwargs, msg_id=msg_id)
    def _message_hdlr(self, _, content, buffers):
        "Front-end message hub for all ctx handlers."
        self.log(f"handle message: content=<code>{_safe(content)}</code>"
                f"{' buffers=<code>'+_safe(buffers)+'</code>' if buffers else ''}")
        if 'ctx' in content:
            tracker = self._pending.get(msg_id := content.get('msg_id'))
            try: handle_message(self, buffers, **content, tracker=tracker)
            finally: self._pending.pop(msg_id, None)
    
    def _msg_fwrdr(self, *args, ctx:str, kind:str, **kwargs):
        "Forward message to the appropriate ctx handler."
        if ctx not in self.ctx_names:
            self.warn(f"Unknown forward ctx '{ctx}' {kind=} kwargs=<code>{_safe(kwargs)}</code>")

# %% ../nbs/14_bridge.ipynb
def Links(*fts: FT):
    return Script(notdebug("""
if (window.$Ls) requestAnimationFrame(() => $Ls(%s));
""" % to_js(*fts)), type='module')

# %% ../nbs/14_bridge.ipynb
def load_links(*fts: FT, feedback: str=''):
    dh = display(HTML(to_xml(Links(*fts)) + feedback), display_id=True)
    # if not feedback and dh: dh.update(HTML(''))
    if not feedback: clear_output()

# %% ../nbs/14_bridge.ipynb
class BridgePlugin(FC.GetAttr):
    _default = 'bridge'; _xtra = ['send', 'asend', 'msg', '_pending']
    ctx_name: str
    bridge:Bridge  # type: ignore
    def __init__(self, ctx:str='', src:str|Path='', bridge=None):
        self.is_initialized = None
        self.ctx_name, self.src = ctx or getattr(self, 'ctx_name', ''), src or getattr(self, 'src', '')
        self.ctx_names = {self.ctx_name} | set(L(type(self).mro()).attrgot('ctx_name').filter()) | getattr(self, 'ctx_names', set())
        if bridge: self.bridge = bridge
    def on_init(self, *args, info:str, **kwargs):
        if info == 'initialized':
            self.is_initialized = True
            self.log(f"Plugin '{self.ctx_name}' initialized")
        else:
            self.is_initialized = False
            self.log(f"Can't initialize plugin: <code>{info}</code>")
    def log(self, msg:Any, clear:bool=False): self.bridge.logger.msg(f"*{msg}", clear=clear, ctx=self.ctx_name, level='LOG')
    def error(self, msg:Any, clear:bool=False): self.bridge.logger.msg(f"*{msg}", clear=clear, ctx=self.ctx_name, level='ERROR')
    def warn(self, msg:Any, clear:bool=False): self.bridge.logger.msg(f"*{msg}", clear=clear, ctx=self.ctx_name, level='WARN')

# %% ../nbs/14_bridge.ipynb
@FC.delegates(BridgeMessenger, keep=True)  # type: ignore
class Bridge(BridgeMessenger):
    state: NB
    def __init__(self, *plugins:BridgePlugin, kwplugins:dict[str, str]|None=None, **kwargs):
        self.plugins = {  # stubs for default plugins
            'loader': BridgePlugin('loader', bridge=self), 
            'htmx': BridgePlugin('htmx', bridge=self), 
            'fasthtmljs': BridgePlugin('fasthtmljs', bridge=self)}
        self._init_plugins = (plugins, kwplugins)
        super().__init__(**kwargs)

    def _msg_fwrdr(self, *args, ctx:str, kind:str, **kwargs):
        handled = False
        if ctx in self.plugins:
            handle_message(self.plugins[ctx], *args, ctx=ctx, kind=kind, **kwargs); handled = True
        # elif ctx not in self.ctx_names:
        #     self.warn(f"Unknown forward ctx '{ctx}' {kind=} {kwargs=}")
        for k,p in self.plugins.items():
            if k != ctx and ctx in p.ctx_names:
                handle_message(p, *args, ctx=k, kind=kind, **kwargs); handled = True
        if not handled: self.warn(f"Unknown forward ctx '{ctx}' {kind=} {kwargs=}")

    @property
    def loader(self) -> Loader: return self.plugins['loader']  # type: ignore
    def __getattr__(self, name:str):
        if name in self.plugins: return self.plugins[name]
        raise AttributeError(f"Bridge has no plugin '{name}'")

    def add_plugins(self, *plugins:BridgePlugin, kwplugins:dict[str, str]|None=None, wait:int=0):
        if plugins or kwplugins:
            kwplugins = kwplugins or {}
            args, pp = {}, plugins + tuple(BridgePlugin(*t) for t in kwplugins.items())
            self.log(f"Adding plugins: {', '.join(p.ctx_name for p in pp)}")
            for p in pp:
                p.bridge = self
                self.plugins[p.ctx_name] = p
                if p.src: args[p.ctx_name] = anysource(p.src)
                else: handle_message(self, None, ctx=p.ctx_name, kind='init', info='initialized')
            if args:
                self.send(self.msg(ctx='loader', cmd='loadPlugins', args=args))
                if wait: blocks(lambda: all(self.plugins[k].is_initialized != None for k in args), wait)
    
    def on_info(self, *args, info:str, **kwargs):
        super().on_info(*args, info=info, **kwargs)
        if info == 'loaded':
            self.add_plugins(*self._init_plugins[0], kwplugins=self._init_plugins[1] or {})

    @anywidget.experimental.command  # type: ignore
    def get_prop(self, spec:dict, buffers):
        ctx, name, prop = spec['ctx'], spec['name'], None
        if ctx in self.plugins:
            prop = getattr(self.plugins[ctx], name, None)
        else:
            self.warn(f"get_prop: unknown ctx '{ctx}' for {name=}")
        return prop, buffers

# %% ../nbs/14_bridge.ipynb
class Loader(BridgePlugin):
    def __init__(self, 
            lnks: dict[str, FT]|None = None, 
            esms: dict[str, str|Path]|None = None
        ):
        self._lnks, self._esms, self._loaded = lnks or {}, esms or {}, {}
        super().__init__('loader')

    def on_init(self, *args, info:str, **kwargs):
        super().on_init(*args, info=info, **kwargs)
        if info == 'initialized':
            self.load_links(self._lnks)
            self.load(self._esms)
            self.log('Bridge initialized')

    @property
    def loading(self) -> bool: return len(tuple(self._pending.keys())) > 0
    @overload
    def loaded(self, name:str) -> bool: ...
    @overload
    def loaded(self, name:None=None) -> dict[str, str|None]: ...
    def loaded(self, name:str|None=None):
        if not name: return self._loaded.copy()
        return name in self._loaded
    
    def load(self, esms: dict[str, str|Path]|None=None, reload:bool=False, cache:bool=True):
        if not esms: return
        msg = self.msg(esms, ctx=self.ctx_name, cmd='load', 
            args={n:anysource(esm) for n,esm in esms.items()}, reload=reload, cache=cache)
        self.send(msg)
    def load_links(self, lnks: dict[str, FT]|None=None):
        if not lnks: return
        msg = self.msg(lnks, ctx=self.ctx_name, cmd='loadLinks', args={n:_to_js(_) for n,_ in lnks.items()})
        self.send(msg)

    async def _asend(self, msg, kind:str):
        res = await self.asend(msg)
        try:
            msg_id = res[0]['msg_id']  # type: ignore
            if msg_id in self._pending: self.log(f"Timeout loading {kind} {msg_id}")
        except Exception: pass
    async def aload(self, esms: dict[str, str|Path]|None=None, reload:bool=False, cache:bool=True):
        if not esms: return
        msg = self.msg(esms, ctx=self.ctx_name, cmd='load', 
            args={n:esm.read_text() if isinstance(esm, Path) else esm for n,esm in esms.items()}, 
                reload=reload, cache=cache)
        await self._asend(msg, 'ESMs')
    async def aload_links(self, lnks: dict[str, FT]|None=None):
        if not lnks: return
        msg = self.msg(lnks, ctx=self.ctx_name, cmd='loadLinks', args={n:_to_js(_) for n,_ in lnks.items()})
        await self._asend(msg, 'links')

    def on_load(self, *args, success:list[str], failed:list[dict[str,str]], tracker:dict, **kwargs):
        for name in success: self.log(f"'{name}' loaded.")
        for res in failed: self.log(f"'{res['name']}' failed: {res['error']}")
        self._loaded |= {n:None for n in success}  # don't store the source code for now
        
    def on_loadLinks(self, *args, success:list[str], failed:list[dict[str,str]], tracker:dict, **kwargs):
        for name in success: self.log(f"'{name}' loaded.")
        for res in failed: self.log(f"'{res['name']}' failed: {res['error']}")
        self._loaded |= {n:tracker[n] for n in success}
    
    # def on_loadPlugins(self, *args, success:list[str], failed:list[dict[str,str]], **kwargs):
    #     # for name in success: self.log(f"'{name}' loaded.")
    #     for res in failed: self.log(f"'{res['name']}' failed: {res['error']}")

# %% ../nbs/14_bridge.ipynb
class HTMXPlugin(BridgePlugin):
    ctx_name = 'htmx'
    sels = ['.output', '.jp-Cell-outputArea']
    url = 'https://cdn.jsdelivr.net/npm/htmx.org@2.0.3/dist/htmx.esm.js'

    def setup(self):
        self.send(self.msg(ctx=self.ctx_name, cmd='setup', args=[self.sels, self.url]))
    def on_info(self, *args, info:str, **kwargs):
        if info == 'setup': self.log(f"HTMX setup.")

# %% ../nbs/14_bridge.ipynb
observer_js = BUNDLE_PATH / 'js/observer.js'

# %% ../nbs/14_bridge.ipynb
# @FC.patch
# async def brdimport(self: Loader, source: str|Path, name:str|None=None, base:str|Path|None=None):
#     src = resolve_ESM(source, base) if isinstance(source, str) else source
#     if src is None: raise ValueError(f"Invalid module specifier: {src}")
#     d = {}
#     if isinstance(src, ParseResult):
#         url = src.geturl()
#         d[name or source] = Script(type='module', src=url, id=name)
#         await self.aload_links(d)
#     else:
#         d[name or str(source)] = src
#         await self.aload(d)@FC.patch

@FC.patch
def brdimport(self: Loader, source: str|Path, name:str|None=None, base:str|Path|None=None):
    src = resolve_ESM(source, base) if isinstance(source, str) else source
    if src is None: raise ValueError(f"Invalid module specifier: {src}")
    d = {}
    if isinstance(src, ParseResult):
        url = src.geturl()
        d[name or source] = Script(type='module', src=url, id=name)
        self.load_links(d)
    else:
        d[name or str(source)] = src
        self.load(d)

# %% ../nbs/14_bridge.ipynb
observer_plugin = bundled('''
import { getObserverManager } from './observer.js';
export default function initializeObserverPlugin(bridge) {
    return [null, { getObserverManager }]
}
''')()

# %% ../nbs/14_bridge.ipynb
def show_summary(brd:Bridge):
    summ = shortens(map(to_xml, [*brd.plugins.keys(), *brd.loader.loaded().values()]), 'r', 140)
    display(HTML(ScriptsDetails(summ)))

# %% ../nbs/14_bridge.ipynb
bridge_default_plugins = [
    HTMXPlugin(),
    BridgePlugin('observer', observer_plugin), 
    BridgePlugin('brd_mark', bundled(brdmark_js)()),
]


@FC.delegates(Bridge.create, keep=True)  # type: ignore
def get_bridge(
    logger:NBLogger|None=None, 
    show_logger:bool=False,
    *,
    lnks: dict[str, FT]|None = None, 
    esms: dict[str, str|Path]|None = None,
    plugins:Sequence[BridgePlugin]|None=None, 
    kwplugins:dict[str, str]|None=None, 
    wait:int=0,  # seconds to wait for plugins/links/modules to load
    summary:bool=False,
    **kwargs,  # `Bridge.create` kwargs
):
    if not __brd__: 
        timeout, sleep = kwargs.pop('timeout', 3), kwargs.pop('sleep', 0.2)
        lnks = {**_bridge_scripts_extra(), **(lnks or {})}
        plugins = [Loader(), *bridge_default_plugins, *(plugins or ())]
        brd = Bridge.create(*plugins, kwplugins=kwplugins, logger=logger, show_logger=show_logger, 
            timeout=timeout, sleep=sleep, **kwargs)
    else:
        brd = __brd__
        if logger: brd.logger = logger
        if not logger and show_logger: brd.logger.show()
        brd.add_plugins(*(plugins or ()), kwplugins=kwplugins, wait=wait)
    brd.loader.load_links(lnks)
    brd.loader.load(esms)
    if wait: blocks(lambda: not brd.loader.loading, wait)
    if summary: show_summary(brd)
    return brd

# %% ../nbs/14_bridge.ipynb
if bridge_cfg.bootstrap: get_bridge(show_logger=True)
