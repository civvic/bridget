"""A bridge from back to front."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/15_bridge.ipynb.

# %% ../nbs/15_bridge.ipynb 1
from __future__ import annotations

# %% auto 0
__all__ = ['commander_js', 'commander_esm', 'commander_scr', 'SwapStyleT', 'shell', 'bridge_scripts', 'show_scripts',
           'CellExecInfo', 'Bridged', 'OutputCapture', 'get_capturer', 'HTMXCommander', 'swap', 'BridgeBase',
           'get_bridge']

# %% ../nbs/15_bridge.ipynb
import os
import sys
from collections import deque
from contextlib import contextmanager
from functools import cached_property
from typing import Literal
from typing import TypeAlias

import fastcore.all as FC
import traitlets as T
from fastcore.xml import to_xml
from fasthtml.core import FT
from fasthtml.xtend import Script
from IPython.core.displayhook import CapturingDisplayHook
from IPython.core.getipython import get_ipython
from IPython.core.interactiveshell import InteractiveShell
from IPython.display import display
from IPython.display import DisplayHandle
from IPython.display import HTML
from IPython.utils.capture import CapturedIO
from olio.common import shortens
from olio.common import update_
from traitlets.config import SingletonConfigurable

# %% ../nbs/15_bridge.ipynb
from .bridge_helpers import BLogger
from .bridge_helpers import Brd_Mark
from .bridge_helpers import BridgeWidget
from .bridge_helpers import debug
from .bridge_helpers import Loader
from .bridge_helpers import marker_scr
from .bridge_helpers import observer_scr
from .bridge_helpers import ScriptsDetails
from .helpers import bridge_cfg
from .helpers import bundle_path
from .helpers import id_gen
from .helpers import skip
from .widget_helpers import anysource
from .widget_helpers import bundled

# %% ../nbs/15_bridge.ipynb
DEBUG = os.environ.get('DEBUG', None) == 'True'
BUNDLE_PATH = bundle_path(__name__)
new_id = id_gen()
_n = '\n'

# %% ../nbs/15_bridge.ipynb
def _bridge_scripts_extra():
    from fasthtml.core import surrsrc, scopesrc
    return {'surreal': surrsrc, 'css_scope_inline': scopesrc}

def bridge_scripts(htmx=True):
    from fasthtml.core import fhjsscr
    from fasthtml.xtend import Script
    htmxsrc = Script(src=f"https://unpkg.com/htmx.org@next/dist/htmx.{'' if DEBUG else 'min.'}js")()
    return update_({'htmx': htmxsrc } if htmx else {}, fasthtml_js=fhjsscr, **_bridge_scripts_extra())

# def _load_scripts(scs):
#     display(HTML(to_xml((*(scvals := [_ for _ in scs.values()]), ScriptsDetails(scvals)))))

def show_scripts(**scs: FT): 
    display(HTML(to_xml(ScriptsDetails(shortens(map(to_xml, scs.values()), 'r', 140)))), metadata=skip())

# %% ../nbs/15_bridge.ipynb
@FC.patch
def _repr_mimebundle_(self: FT, include=None, exclude=None):
    mb = {'text/plain': repr(self)}
    if bridge_cfg.auto_show: mb['text/html'] = self.__html__()
    else: mb['text/markdown'] = self._repr_markdown_()
    return mb

# %% ../nbs/15_bridge.ipynb
class CellExecInfo:
    def __init__(self): 
        self._active, self.last_info, self.last_result = False,{}, {}
        self._evts = get_ipython().events  # type: ignore
    def pre_run_cell(self, info): 
        if not self._active: 
            self._evts.register('post_run_cell', self.post_run_cell)
            self._active = True
        self.last_info = {'raw_cell': info.raw_cell, 'cell_id': info.cell_id}
        if (shell := get_ipython()): 
            shell.user_ns['__cellid__'] = info.cell_id
            shell.user_ns['__cellsource__'] = info.raw_cell
    def post_run_cell(self, result):
        if not self._active: return
        self.last_result = {
            'execution_count': result.execution_count,
            'error_before_exec': result.error_before_exec,
            'error_in_exec': result.error_in_exec,
            'info': {'raw_cell': result.info.raw_cell, 'cell_id': result.info.cell_id},
            'result': result.result
        }
    def start(self): self._evts.register('pre_run_cell', self.pre_run_cell)
    def stop(self):
        if self._active:
            self._active = False
            if self.last_result: self.last_info = self.last_result['info']
            self._evts.unregister('pre_run_cell', self.pre_run_cell)
            self._evts.unregister('post_run_cell', self.post_run_cell)

# %% ../nbs/15_bridge.ipynb
class Bridged:
    def __init__(self, 
            dhs: deque[DisplayHandle]|None = None, msgs: list[dict]|None = None, register: bool = False):
        self.dhs = deque(maxlen=100) if dhs is None else dhs
        if DEBUG: self.msgs = [] if msgs is None else msgs
        if register: self.register()
    
    def register(self):
        shell = get_ipython()
        if shell and (reg := getattr(shell.display_pub, 'register_hook', None)): return reg(self.bridged)
        return False

    def unregister(self):
        shell = get_ipython()
        if shell and (unreg := getattr(shell.display_pub, 'unregister_hook', None)): return unreg(self.bridged)
        return False
    
    def __del__(self): self.unregister()
    
    def bridged(self, msg):
        "Augment display messages with bridge stuff."
        if DEBUG: self.msgs.append(msg)
        if msg['msg_type'] in ('display_data', 'update_display_data'):
            # hoist display_id or brd_did to output metadata
            cnt, md, did = msg['content'], msg['metadata'], None
            cmd = cnt['metadata']
            if (brdmd := cmd.get('bridge', None)) and brdmd.get('skip', None): return msg
            if 'text/html' not in (d := cnt['data']): return msg
            if trn := cnt['transient']: did = trn['display_id']
            elif cmd:
                for k,v in cmd.items():
                    if brd_id := v.get('brd_did', None): did = brd_id; break
            if not did and bridge_cfg.auto_id: did = new_id()
            if did: 
                if 'display_id' not in trn: trn['display_id'] = did
                if not self.dhs or (did != self.dhs[-1].display_id):
                    self.dhs.append(DisplayHandle(display_id=did))
                # cmd['brd_did'] = did
                # md['bridge'] = {'id': did}
                # add brd-mark to output
                if 'text/html' in (d := cnt['data']):
                    d['text/html'] = d['text/html'] + _n + to_xml(Brd_Mark(id=did))
        return msg


# %% ../nbs/15_bridge.ipynb
class OutputCapture(SingletonConfigurable):
    shell: InteractiveShell
    def __init__(self):
        super().__init__()
        self.shell = get_ipython()  # type: ignore
        if DEBUG: self._cells, self._outputs, self._captured = deque(maxlen=100), deque(maxlen=100), deque(maxlen=100)
        # if DEBUG: self._exres = deque(maxlen=100)
        self._active, self.run_outputs = False, []
        self.displayhook = CapturingDisplayHook(shell=self.shell, outputs=self.run_outputs)
    
    @contextmanager
    def _capture(self):
        self.run_outputs.clear()
        try: 
            save_display_hook, sys.displayhook = sys.displayhook, self.displayhook
            self._active = True
            yield CapturedIO(stdout=None, stderr=None, outputs=self.run_outputs)
        finally: 
            self._active = False
            sys.displayhook = save_display_hook
    
    def __call__(self, cell):
        if DEBUG: self._cells.append(cell)
        with self._capture() as io:
            # result = self.shell.run_cell(cell, silent=True, cell_id=self.shell.user_ns.get('__cellid__'))
            self.shell.run_cell(cell, cell_id=self.shell.user_ns.get('__cellid__'))
        # self._exres.append(result)
        # assert len(io._outputs) == 0, "Outputs should be 0."
        if io._outputs: 
            if DEBUG: self._outputs.extend(io._outputs)
            assert len(io._outputs) <= 1, "Only one output is supported"
            display(io.outputs[-1])
    
    def _transform(self, lines):
        "Input transformer function"
        if not lines or self._active: return lines
        if lines[0].startswith('import debugpy;debugpy.listen('): return lines
        if lines[0].startswith('import debugpy\ndebugpy.debug_this_thread()'): return lines
        return ['get_capturer()(%r)\n' % ''.join(lines)]
            
    def register(self):
        self.shell.user_ns['get_capturer'] = get_capturer
        if DEBUG: self._cells, self._outputs = deque(maxlen=100), deque(maxlen=100)
        # self.shell.input_transformers_cleanup.append(self._transform)
        self.shell.input_transformer_manager.line_transforms.append(self._transform)
        
    def unregister(self):
        try: 
            # self.shell.input_transformers_cleanup.remove(self._transform)
            self.shell.input_transformer_manager.line_transforms.remove(self._transform)
        except (ValueError, NameError): pass
    
    def __del__(self): self.unregister()


def get_capturer(): return OutputCapture.instance()

# %% ../nbs/15_bridge.ipynb
commander_js = BUNDLE_PATH / 'js/commander.js'
commander_esm = bundled(commander_js, bundle=__name__, bundler='copy')
commander_scr = Script(debug(commander_esm.source), id='htmx-commander')

class HTMXCommander(BridgeWidget):
    _esm = anysource(commander_esm(debugger=DEBUG), '''
export default { 
    async initialize({ model }) {
        await initializeCommander(model.get('output_sels'));
        model.on("msg:custom", on_commander_msg);
        model.send({ ctx: 'commander', kind: 'info', info: 'loaded' });
    }
};
''')
    
    output_sels = T.List(['.output', '.jp-Cell-outputArea']).tag(sync=True)

    ctx_name = T.Unicode('commander').tag(sync=True)

    def swap(self: HTMXCommander,
        target, 
        content, 
        *, 
        # ---- swapSpec:SwapSpec, 
        swapStyle: Literal['innerHTML','outerHTML','testContent','beforebegin','afterbegin','beforeend','afterend','delete','none'],
        swapDelay: int|None=None, settleDelay: int|None=None,
        transition: bool|None=None,
        # ignoreTitle: bool|None=None, head: Literal['merge', 'append']|None=None,
        scroll: str|None=None, scrollTarget: str|None=None,
        show: str|None=None, showTarget: str|None=None, focusScroll: bool|None=None,
        # ---- swapOptions=None,
        select: str|None=None, selectOOB: str|None=None,
        # eventInfo: dict|None=None,
        anchor: str|None=None,        
        # contextElement: str|None=None,
        # afterSwapCallback: Callable|None=None, afterSettleCallback: Callable|None=None,
    ): ...

# %% ../nbs/15_bridge.ipynb
SwapStyleT: TypeAlias = Literal['innerHTML','outerHTML','testContent','beforebegin','afterbegin',
                        'beforeend','afterend','delete','none']

# %% ../nbs/15_bridge.ipynb
def swap(self, 
        target, 
        content, 
        *, 
        # ---- swapSpec:SwapSpec, 
        swapStyle: SwapStyleT='innerHTML',
        swapDelay: int|None=None, settleDelay: int|None=None,
        transition: bool|None=None,
        # ignoreTitle: bool|None=None, head: Literal['merge', 'append']|None=None,
        scroll: str|None=None, scrollTarget: str|None=None,
        show: str|None=None, showTarget: str|None=None, focusScroll: bool|None=None,
        # ---- swapOptions=None,
        select: str|None=None, selectOOB: str|None=None,
        # eventInfo: dict|None=None,
        anchor: str|None=None,        
        # contextElement: str|None=None,
        # afterSwapCallback: Callable|None=None, afterSettleCallback: Callable|None=None,
    ):
    d = {
        'target': target,
        'content': content,
        'swapSpec': update_(**{
            'swapStyle': swapStyle, 'swapDelay': swapDelay, 'settleDelay': settleDelay,
            'transition': transition,
            # 'ignoreTitle': ignoreTitle, 'head': head,
            'scroll': scroll, 'scrollTarget': scrollTarget,
            'show': show, 'showTarget': showTarget, 'focusScroll': focusScroll,
            # 'afterSwapCallback': afterSwapCallback, 'afterSettleCallback': afterSettleCallback,
        }),
        'swapOptions': update_(**{
            'select': select, 'selectOOB': selectOOB,
            # 'eventInfo': eventInfo,
            'anchor': anchor,
            # 'contextElement': contextElement,
            # 'afterSwapCallback': afterSwapCallback, 'afterSettleCallback': afterSettleCallback,
        }),
    }
    self.send({
        'cmd': 'swap',
        'args': [*d.values()]
    })

FC.patch_to(HTMXCommander)(swap)

# %% ../nbs/15_bridge.ipynb
@FC.delegates()
class BridgeBase(Loader):
    logger: BLogger
    lnks = {**bridge_scripts(), 'observer_scr':observer_scr, 'brd_mark': marker_scr}
    dhs: deque[DisplayHandle]
    # commander: HTMXCommander | None = None

    def __init__(self, *args, 
            # companions_loader: Callable[[Self], list[BridgeWidget]]|None = None,
            **kwargs
        ):
        if DEBUG: self.msgs = []
        self.csi, self.dhs, self.hook = CellExecInfo(), deque(maxlen=100), None
        # self.companions = []
        # self._companions_loader = companions_loader
        super().__init__(*args, **kwargs)

    def close(self):
        self.csi.stop()
        get_capturer().unregister()
        if self.hook: self.hook.unregister()
        # map(lambda c: c.close(), self.companions)
        super().close()
    def __del__(self): self.close()

    def on_info(self, *args, info:str, **kwargs):
        super().on_info(*args, info=info, **kwargs)
        if info == 'loaded': # now we can initialize the scripts
            self.hook = Bridged(self.dhs, self.msgs if DEBUG else None, register=True)
            get_capturer().register()
            self.csi.start()

    def on_loadLinks(self, *args, success:list[str], **kwargs):
        super().on_loadLinks(*args, success=success, **kwargs)
        # if self._companions_loader: self.companions = self._companions_loader(self)
    
    @cached_property
    def commander(self) -> HTMXCommander | None:
        if self.loaded('htmx'):
            return HTMXCommander(logger=self.logger, show=False)


@FC.delegates(Loader.__init__)  # type: ignore
async def get_bridge(*args, logger=None, show_scr=False, **kwargs): 
    if logger: logger.display()
    brd = await BridgeBase.create(*args, logger=logger, **kwargs)
    if show_scr: show_scripts(**brd.lnks)
    return brd

# %% ../nbs/15_bridge.ipynb
shell = get_ipython()
if shell:
    shell.user_ns['__cellid__'] = None
    shell.user_ns['__cellsource__'] = None
