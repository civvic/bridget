"""Programmatic access to notebook cells and outputs."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/21_nb_state.ipynb.

# %% ../nbs/21_nb_state.ipynb 1
from __future__ import annotations


# %% auto 0
__all__ = ['BUNDLER_PATH', 'EmptyT', 'NBSTATE_MIME', 'nbstate_js', 'FIRST', 'LAST', 'show_notebook_state',
           'update_notebook_state', 'NBStateFetcher', 'NBState', 'this', 'these']

# %% ../nbs/21_nb_state.ipynb
import inspect
import json
import sys
from inspect import Parameter
from pathlib import Path
from typing import Mapping

import anywidget
import fastcore.all as FC
import traitlets as T
from fastcore.foundation import L
from IPython.display import clear_output
from IPython.display import display
from IPython.display import DisplayHandle
from IPython.display import HTML


# %% ../nbs/21_nb_state.ipynb
from .display_helpers import BasicLogger
from .display_helpers import displaydh
from .helpers import bundler_path
from .helpers import kounter
from .helpers import skip
from .nb import NB
from .nb import NBCell
from .widget_helpers import anytext
from .widget_helpers import BlockingMixin


# %% ../nbs/21_nb_state.ipynb
BUNDLER_PATH = bundler_path(None if __name__ == "__main__" else 'bridget')
_EMPTY = Parameter.empty
EmptyT = type[_EMPTY]


# %% ../nbs/21_nb_state.ipynb
NBSTATE_MIME = 'application/x-notebook-state'

def show_notebook_state(options:Mapping={'feedback': True, 'watch': True, 'debug': True}) -> DisplayHandle:
    "Display notebook state with our custom mime type"
    dh = display({NBSTATE_MIME: options}, raw=True, display_id=True, 
        metadata=skip())
    return dh  # type: ignore

def update_notebook_state(dh: DisplayHandle, options:Mapping|None=None):
    dh.update({NBSTATE_MIME: {**(options or {}), 'id': kounter('nbstate'), 'update': True}}, 
        raw=True, metadata=skip())


# %% ../nbs/21_nb_state.ipynb
nbstate_js = BUNDLER_PATH / 'js/nbstate.js'

class NBStateFetcher(anywidget.AnyWidget, BlockingMixin):
    _esm = anytext(
        'debugger;', nbstate_js, '''
export default { initialize: initializeNBState };
''')

    feedback = True; watch = False; debug = True;
    state = T.Instance(NB, default_value=NB())
    def __init__(self, *args, logger:BasicLogger|None=None, **kwargs):
        self._loading = True
        self.feedback_dh = display(HTML(''), display_id=True, metadata=skip())
        self.logger = logger or BasicLogger().setup(height=200)
        self.logger.show('Loading NBState fetcher...')
        self.on_msg(self._on_message)
        super().__init__(*args, **kwargs)
    
    def close(self):
        self.logger.close('NBState unloaded')
        if self.feedback_dh: self.feedback_dh.update(HTML(''))
        self.feedback_dh = None
        super().close()
    
    @property
    def opts(self): return {'feedback': self.feedback, 'watch': self.watch, 'debug': self.debug}

    def _on_message(self, _, content, buffers):
        "Handle messages from the front-end"
        self._loading = False
        kind = content.get('kind')
        self.logger.show(f"_on_message: {kind}")
        if kind == 'info':
            if content['info'] == 'initialized':
                self.logger.show('Requesting notebook state...')
                self.setup_notebook_state()
            elif content['info'] == 'several state observers':
                self.logger.show("There're other state observers.")
        elif kind == 'state_update':
            state = (json.loads(content['state']) if content['state'] else {})
            self.state = NB(**state)
            # this shouldn't trigger update
            self.logger.show(  f"State updated type: {state['type']} #cells {len(state['cells'])} @{state['timestamp']}" 
                        f" watch: {self.watch} feedback: {self.feedback} debug: {self.debug}")

    def setup_notebook_state(self):
        self.feedback_dh.update({NBSTATE_MIME: {**self.opts, 'id': kounter('nbstate')}},  # type: ignore
            raw=True, metadata=skip())

    def _update_notebook_state(self, req_id):
        if self.feedback_dh and not self._loading: self.feedback_dh.update(
            {NBSTATE_MIME: {**self.opts, 'id': req_id, 'update': True}}, raw=True, metadata=skip())
    def update_notebook_state(self, 
            watch:bool|None=None, feedback:bool|None=None, debug:bool|None=None): 
        if watch is not None: self.watch = watch
        if feedback is not None: self.feedback = feedback
        if debug is not None: self.debug = debug
        return self._update_notebook_state(kounter('nbstate'))

    def update(self, timeout: float|None=None):
        if not self.watch:
            self.update_notebook_state()
            self.send({'cmd': 'get_state'}, timeout=timeout)

    async def aupdate(self, timeout: float=20.0):
        if not self.watch:
            self.update_notebook_state()
            await self.asend({'cmd': 'get_state'}, timeout=timeout)


# %% ../nbs/21_nb_state.ipynb
class NBState(T.HasTraits, FC.GetAttr):
    state = T.Instance(NB, default_value=NB())
    _default = 'state'
    def __init__(self, source: NBStateFetcher|Mapping|None=None):
        if source is None: source = NBStateFetcher()
        self.source = source

    @property
    def source(self): return self._source
    @source.setter
    def source(self, source: NBStateFetcher|Mapping|None=None):
        if hasattr(self, '_link'): self._link.unlink()
        if isinstance(source, NBStateFetcher): 
            self._link = T.dlink((source, 'state'), (self, 'state'))
        elif isinstance(source, Mapping): self.state = NB(**source)
        else: self.state = NB()
        # try: del self.processor
        # except: pass
        self._source = source

    def update(self):
        if isinstance(self.source, NBStateFetcher): self.source.update_notebook_state()
    
    def this(self: NBState, idx:int|None=None) -> NBCell:...
    
    def __del__(self):
        if hasattr(self, '_link'): self._link.unlink()


# %% ../nbs/21_nb_state.ipynb
FIRST = -sys.maxsize
LAST = sys.maxsize

def _this(nb):
    this_id = f"this_{kounter('this')}"
    displaydh(metadata={'bridget': {'this': this_id}})
    nb.source.send({'cmd': 'get_state'}, timeout=5)
    clear_output(wait=True)
    this_cell = nb.state.find(this_id, 'outputs.0.metadata.metadata.bridget.this')[0]
    this_idx = nb.cells.index(this_cell)
    return this_idx, this_cell

@FC.patch
def this(self: NBState, idx:int|None=None) -> NBCell:
    "Current cell if `idx` is None, or cell at `idx` from current cell upwards. Raises if not found."
    if not isinstance(self.source, NBStateFetcher): return self.cells[idx or -1]
    this_idx, this_cell = _this(self)
    if not idx: return this_cell
    return self.cells[max(0, this_idx + idx)] if idx < 0 else self.cells[min(len(self.cells)-1, this_idx + idx)]

@FC.patch
def these(self: NBState, above:int|None=None, below:int|None=None) -> L:
    if not isinstance(self.source, NBStateFetcher): return self.cells[above or 0:below or None]
    this_idx, _ = _this(self)
    return self.cells[max(0, this_idx + (above or FIRST)):min(len(self.cells), this_idx+1+(below or 0))]

