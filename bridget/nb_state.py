"""Programmatic access to notebook cells and outputs."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/21_nb_state.ipynb.

# %% ../nbs/21_nb_state.ipynb 1
from __future__ import annotations

# %% auto 0
__all__ = ['NBSTATE_MIME', 'NBStateFeedback', 'nbstate_js', 'FIRST', 'LAST', 'NBStateFetcher', 'StateProvider', 'NBState', 'this',
           'get_nb']

# %% ../nbs/21_nb_state.ipynb
import json
import sys
from datetime import datetime
from inspect import Parameter
from typing import Mapping
from typing import overload
from typing import Protocol
from typing import runtime_checkable
from typing import SupportsIndex

import fastcore.all as FC
from fastcore.foundation import L
from IPython.core.getipython import get_ipython
from IPython.display import display
from IPython.core.display import HTML
from olio.basic import AD
from olio.basic import bundle_path
from olio.basic import update_


# %% ../nbs/21_nb_state.ipynb
import bridget.nb_hooks
from .bridge import BridgePlugin
from .bridge import get_bridge
from .bridge_plugins import NBHooksPlugin
from .bridge_widget import blocks
from .bridge_widget import bundled
from .bridge_widget import get_brdimport
from .helpers import bridge_cfg
from .helpers import id_gen
from .helpers import kounter
from .helpers import ms2str
from .nb import NB
from .nb import NBCell


# %% ../nbs/21_nb_state.ipynb
BUNDLE_PATH = bundle_path(__name__)
_EMPTY = Parameter.empty
EmptyT = type[_EMPTY]
new_id = id_gen()

# %% ../nbs/21_nb_state.ipynb
NBSTATE_MIME = 'application/x-notebook-state+json'

class _NBStateFeedback:
    def __init__(self, **options):
        self.options = AD(feedback=True, hide=False, debug=True, **options)
        self.dh = None; self.shown = False
    def show(self, hide=False, **options):
        if self.dh: self.dh.update(HTML(''))
        self.dh = display({NBSTATE_MIME: update_(self.options, **options, hide=hide)}, raw=True, display_id=True)
        self.shown = True
    def update(self, **options):
        if self.dh: self.dh.update({NBSTATE_MIME: {**update_(self.options, **options), 'id': kounter('nbstate')}}, raw=True)
    def hide(self):
        if self.dh: self.dh.update({NBSTATE_MIME: {**update_(self.options, hide=True), 'id': kounter('nbstate')}}, raw=True)


NBStateFeedback = _NBStateFeedback()

# %% ../nbs/21_nb_state.ipynb
nbstate_js = BUNDLE_PATH / 'js/nbstate.js'

# %% ../nbs/21_nb_state.ipynb
class NBStateFetcher(BridgePlugin):
    src = bundled('''
import { initializeNBState } from './nbstate.js';
export default async function initializeFetcher(bridge) {
    const cleanup = initializeNBState(bridge);
    return () => cleanup();
}
''')()

    ctx_name = 'fetcher'

    def __init__(self):
        self.feedback = True; self.debug = True; self._renderer = True
        self._last_update = []
        super().__init__()

    @property
    def opts(self): return {'feedback': self.feedback, 'debug': self.debug}

    def update(self, timeout: float|None=None, **kwargs):
        kwargs['id'] = new_id(self)
        self.send({'ctx': self.ctx_name, 'cmd': 'get_state', **kwargs}, timeout=timeout)

    async def aupdate(self, timeout: float=3, **kwargs):
        kwargs['id'] = new_id(self)
        await self.asend({'ctx': self.ctx_name, 'cmd': 'get_state', **kwargs}, timeout=timeout)

    def on_init(self, *args, info:str, **kwargs):
        super().on_init(*args, info=info, **kwargs)
        if info == 'initialized':
            self.bridge.state = bridget.nb_hooks.get_nb_from_hooks()
            if self._renderer:
                self.log('Requesting initial notebook state...')
                self.update(update='full')
        elif info == 'renderer not found':
            self._renderer = False
            self.log("Renderer not found: NBState is empty. Try calling update(update='full') again...")
    
    def on_state_update(self, *args, state:dict|str, **kwargs):
        d = (json.loads(state) if isinstance(state, str) else state or {})
        self.log(f"State update - type: {d['type']} ts: {ms2str(float(d['timestamp'])/1000)}")
        self._last_update.append(d)
        if d['type'] == 'state':
            self.log(f"---- #cells: {len(d.get('cells', []))}")
            self.bridge.state.setup(**d)
        else:
            if len(self.bridge.state.cells) == 0: return
            try:
                self.bridge.state.apply_diffsMessage(d)
                diffs:list[dict] = d.get('changes', [])
                # self.log(f"#diffs: {len(diffs)}")
                for i, d in enumerate(diffs): self.log(
                    f"---- {i} - cells: {[c['idx'] for c in d['cells']]} "
                    f"added: {[c['idx'] for c in d.get('added', [])]} "
                    f"removed: {d.get('removed', [])}")
            except Exception as e:
                self.log(f"Error applying diffs: {e}")

# %% ../nbs/21_nb_state.ipynb
@runtime_checkable
class StateProvider(Protocol):
    @property
    def state(self) -> NB:...


class NBState(FC.GetAttr):
    _default = 'state'
    def __init__(self, source: StateProvider|Mapping|None=None, *bridge_args, plugins=None, **bridge_kw):
        self._state = None
        if source is None:
            if not NBStateFeedback.shown: NBStateFeedback.show(hide=True)
            plugins = [NBHooksPlugin(), NBStateFetcher()]
            if 'wait' not in bridge_kw: bridge_kw['wait'] = 3
            source = get_bridge(*bridge_args, plugins=plugins, **bridge_kw)
        elif isinstance(source, Mapping): self._state = NB(**source)
        self.source = source

    @overload
    def __getitem__(self, key: SupportsIndex|str, /) -> NBCell: ...
    @overload
    def __getitem__(self, key: slice, /) -> L: ...
    def __getitem__(self, key) -> NBCell|L: 
        if isinstance(key, str):
            cc = self.cells.filter(lambda c: c.metadata['cell_id'] == key)
            return cc[0] if len(cc) else L()  # type: ignore
        return self.cells[key]  # type: ignore

    @property
    def state(self) -> NB:
        return self.source.state if self._state is None else self._state  # type: ignore

    def this(self, idx:int|None=None) -> NBCell:...

# %% ../nbs/21_nb_state.ipynb
FIRST = -sys.maxsize
LAST = sys.maxsize

# this: Literal['this'] = 'this'

# %% ../nbs/21_nb_state.ipynb
def this(idx:int|None=None) -> NBCell:
    "Current cell if `idx` is None, or cell at `idx` from current cell upwards. Raises if not found."
    # if not ((bridge := get_bridge()).plugins.get('fetcher', None)):
    #     bridge.add_plugins(fetcher := NBStateFetcher(), wait=3)
    #     blocks(lambda: fetcher.is_initialized is not None, 3)
    # Ummm, don't really need the `fetcher` for this to work
    if not ((bridge := get_bridge()).plugins.get('nbhooks', None)): bridge.add_plugins(NBHooksPlugin())
    shell = get_ipython()
    if shell is None: raise IndexError('No IPython shell found')
    cellinfo = shell.user_ns.get('__cellinfo__')
    if not cellinfo: raise IndexError('__cellinfo__ is not set')
    this_cell = bridge.state[cellinfo.cell_id]
    this_cell.source = cellinfo.source
    if not idx: return this_cell
    this_idx, cells = this_cell.idx, bridge.state.cells
    return cells[
        max(0, this_idx + idx)] if idx < 0 else cells[min(len(cells)-1, this_idx + idx)]  # type: ignore

# %% ../nbs/21_nb_state.ipynb
__nbstate__ = None

@FC.delegates(get_bridge)  # type: ignore
def get_nb(*args, show_feedback:bool=False, **kwargs):
    global __nbstate__
    if __nbstate__ is None:
        wait=kwargs.pop('wait', 5)
        __nbstate__ = NBState(*args, wait=wait, **kwargs)
    else: get_bridge(*args, **kwargs)
    if show_feedback: NBStateFeedback.show()
    return __nbstate__

# %% ../nbs/21_nb_state.ipynb
if bridge_cfg.bootstrap: get_nb(show_logger=True)
