"""Basis of the bridge: bundling, blocking operations, and AnyWidget."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_bridge_widget.ipynb.

# %% ../nbs/10_bridge_widget.ipynb 1
from __future__ import annotations

# %% auto 0
__all__ = ['read_vfile', 'ScriptV', 'StyleV', 'SourceProvider', 'anysource', 'Bundle', 'bundled', 'resolve_ESM', 'get_ESM',
           'exp_backoff', 'blocks', 'ablocks', 'blocking', 'BlockingMixin', 'BridgeWidget', 'get_brdimport']

# %% ../nbs/10_bridge_widget.ipynb
import asyncio
import shutil
import time
from contextlib import contextmanager
from functools import cached_property
from pathlib import Path
from typing import Any
from typing import Callable
from typing import overload
from typing import Protocol
from typing import Self
from urllib.parse import ParseResult
from urllib.parse import urlparse

import anywidget
import fastcore.all as FC
import ipywidgets as W
import nbdev.config
import traitlets as T
from fastcore.xml import FT
from fastcore.xml import NotStr
from fasthtml.basics import ft_html
from jupyter_ui_poll import ui_events
from olio.basic import bundle_path
from olio.basic import Empty
from olio.basic import empty


# %% ../nbs/10_bridge_widget.ipynb
from .helpers import bridge_cfg
from .helpers import DEBUG
from .helpers import id_gen
from .helpers import kounter
from .helpers import ms2str
from .helpers import run_command
from .helpers import ts
from .js_transform import JSImportTransform


# %% ../nbs/10_bridge_widget.ipynb
new_id = id_gen()
BUNDLE_PATH = bundle_path(__name__)
bridge_cfg.for_module(__name__)

# %% ../nbs/10_bridge_widget.ipynb
_n = '\n'

# %% ../nbs/10_bridge_widget.ipynb
def read_vfile(cts:str)->str|None:
    # %load_ext anywidget should have been previously run for this to work
    import anywidget
    from anywidget._file_contents import _VIRTUAL_FILES
    if isinstance(cts, str) and cts.startswith('vfile:'):
        if fn := _VIRTUAL_FILES.get(cts, None):
            return fn.contents

# %% ../nbs/10_bridge_widget.ipynb
@FC.delegates(ft_html, keep=True)  # type: ignore
def ScriptV(code:str="", **kwargs)-> FT:
    "A Script w/ code or `vfile:` contents that doesn't escape its code"
    return ft_html('script', (_n, NotStr(FC.ifnone(read_vfile(code), code))), **kwargs)

@FC.delegates(ft_html, keep=True)  # type: ignore
def StyleV(*c, **kwargs)-> FT:
    "A Style w/ code or `vfile:` contents that doesn't escape its code"
    return ft_html('style', tuple(NotStr(FC.ifnone(read_vfile(_), _)) for _ in c), **kwargs)


# %% ../nbs/10_bridge_widget.ipynb
class SourceProvider(Protocol):
    @property
    def source(self) -> str | cached_property[str]: ...

def _source(o: str|Path|SourceProvider) -> str:
    if hasattr(o, 'source'): return o.source  # type: ignore
    return FC.ifnone(read_vfile(o), o if isinstance(o, str) else o.read_text())  # type: ignore

def anysource(*args: str|Path|SourceProvider):
    "Read and join text from files, vfiles or strings"
    return '\n'.join(filter(None, (_source(_) for _ in args)))

# %% ../nbs/10_bridge_widget.ipynb
class Bundle:
    "Basic JS bundler class."
    def __init__(self, 
        *sources: str|Path,         # javascript source
        bundle:bool=True,           # Bundle using `bundler` with sources as entry points
        bundler:str='copy',         # Bundler type to use, one of 'esbuild', 'copy'
        outdir:str|Path|None=None,  # Output directory for bundled files
        command:str|None=None,      # Run `command` first if not None
        **cmd_kw                    # Command kwargs
    ):
        self.sources, self.bundle, self.bundler = list(sources), bundle, bundler
        self.command, self.cmd_kwargs = command, cmd_kw
        self.outdir = Path(outdir).resolve() if outdir else self.default_outdir()
    @classmethod
    def default_outdir(cls): return nbdev.config.get_config().lib_path/'js'
    @classmethod
    def transform(cls, src:str):
        if bridge_cfg.bundle_cfg.rewrite_imports: src = JSImportTransform(bridge_cfg.bundle_cfg.import_name)(src)
        return src
    def __str__(self): return self.source
    def __call__(self, 
        *args:str|Bundle,  # Insert sources before the bundle
        debugger=False,    # Insert `debugger` at the beginning of the bundle
        ts=False,          # Insert timestamp at the beginning of the bundle
        transform=True,    # Transform resulting source if `bundler` is `copy` and `rewrite_imports` is True
        **kwargs):
        "Concatenate sources. This is the only point where the source is transformed"
        srcs = [_.source if isinstance(_, Bundle) else _ for _ in args]
        src = anysource(f"debugger;{('  // '+str(time.time())) if ts else ''}" if debugger else '', *srcs, self.source)
        return self.transform(src) if transform and self.bundler == 'copy' else src
    @cached_property
    def bundled_sources(self) -> list[str|Path]:
        "Bundle the sources using `esbuild` or `copy`. Return sources and paths to the bundled files."
        if self.command: _ = run_command(self.command, **self.cmd_kwargs)
        if not self.bundle: return self.sources
        outdir = self.outdir
        if self.bundler == 'copy':
            srcs = [shutil.copy(_, outdir) if _.resolve().parent != outdir else _ for _ in self.sources if isinstance(_, Path)]
        else:  # esbuild
            if srcs := ' '.join([_.resolve().as_posix() for _ in self.sources if isinstance(_, Path)]):
                cmd = f"./node_modules/.bin/esbuild --bundle --format=esm --outdir={outdir} {srcs}"
                try: _ = run_command(cmd, cwd=nbdev.config.get_config().config_path)
                except Exception as e: raise ValueError(f"Error bundling sources: {e}")
        return [(outdir / _.name if isinstance(_, Path) else _) for _ in self.sources]
    def bundle_path_of(self, source: str|Path): return self.outdir / Path(source).name
    @cached_property
    def source(self): return anysource(*self.bundled_sources)
    def join(self, *sources: str|Path):
        return type(self)(*self.sources, *sources, bundle=self.bundle, outdir=self.outdir, 
            bundler=self.bundler, command=self.command, **self.cmd_kwargs)


@FC.delegates(Bundle.__init__, keep=True)  # type: ignore
def bundled(*sources: str|Path, **kwargs):
    return Bundle(*sources, **kwargs)

# %% ../nbs/10_bridge_widget.ipynb
_valid_schemes = {
    'http', 'https', # Web resources
    'data',          # Data URLs
    'file',          # File URLs
    'node',          # Node.js built-ins
    'ftp', 'ftps',   # FTP resources
    'blob',          # Blob URLs (browser)
}

def _resolve_local(spec, bases) -> Path | None:
    "Resolve a local file path relative to `bases` list of dirs."
    spec = spec[spec.startswith('/'):]
    for base in bases:
        if (resolved := base / spec).exists(): return resolved

def resolve_ESM(spec: str, base:str|Path|None=None) -> Path | ParseResult | None:
    "Resolve a JavaScript module specifier relative to `base` or `bundle_cfg.out_dir`."
    bases = [Path(base)] if base else [*bridge_cfg.bundle_cfg.out_dir, Path.cwd()]
    if spec.startswith(('/', './', '../')): return _resolve_local(spec, bases)  # Relative specifier
    parsed = urlparse(spec)
    if (scheme := parsed.scheme) in _valid_schemes:
        if scheme != 'file': return parsed
        return _resolve_local(parsed.path, bases)

# %% ../nbs/10_bridge_widget.ipynb
def get_ESM(module_spec):
    "Contents of a JS module"
    mod = resolve_ESM(module_spec)
    if isinstance(mod, Path): return Bundle.transform(mod.read_text())
    if isinstance(mod, ParseResult): return mod.geturl()

# %% ../nbs/10_bridge_widget.ipynb
def exp_backoff(base:float=1.552, max_value:float=10.0):
    "Exponential backoff generator of values until cumulative value is max_value, then yields 0 and stops."
    if base <= 0: yield 0; return
    i, cum_sum, prev_t = 1, 0, 0
    while cum_sum < max_value:
        t = max(base**i, prev_t) if base > 1 else base*i
        t = min(t, max_value - cum_sum)
        yield t
        cum_sum += t
        prev_t = t
        i += 1
    yield 0

# %% ../nbs/10_bridge_widget.ipynb
_xx = ['-_-', 'o_o']
def _show(finish: bool=False):
    if finish: print('._.')
    else: print(_xx[0], end="\r", flush=True); _xx[:] = _xx[::-1]

# %% ../nbs/10_bridge_widget.ipynb
def blocks(
    pred:Callable[..., bool],
    timeout:float=1, sleep:float=0.0, n:int=10,
    show:Callable[[bool], None]|None=None,
):
    "Block until `pred` is True, or at least `timeout` seconds have passed. Return `False` if timeout."
    boff = iter(exp_backoff(timeout*0.1, timeout))
    timeout, start_time, done = next(boff), time.time(), False
    try:
        with ui_events() as ui_poll:
            while True:
                if pred(): done = True; break
                if show: show(False)
                ui_poll(n)
                if (time.time() - start_time) > timeout:
                    timeout, start_time = next(boff), time.time()
                    if not timeout: break
                if sleep: time.sleep(sleep)
        if show: show(True)
    except KeyboardInterrupt: pass
    return done

async def ablocks(
    pred:Callable[..., bool],
    timeout:float=1, sleep:float=0.0, n:int=10,
    show:Callable[[bool], None]|None=None,
):
    "Return True when `pred` returns True, or False when at least `timeout` seconds have passed."
    boff = iter(exp_backoff(timeout*0.1, timeout))
    timeout, start_time, done = next(boff), time.time(), False
    async with ui_events() as ui_poll:
        while True:
            if pred(): done = True; break
            if show: show(False)
            await ui_poll(n)
            if (time.time() - start_time) > timeout:
                timeout, start_time = next(boff), time.time()
                if not timeout: break
            if sleep: await asyncio.sleep(sleep)
    if show: show(True)
    return done

@contextmanager
def blocking(
    timeout:float=1, sleep:float=0.0, n:int=10,
    show:Callable[[bool], None]|None=None,
):
    def _f(pred:Callable[..., bool]):
        return blocks(pred, timeout, sleep, n, show)
    yield _f

# %% ../nbs/10_bridge_widget.ipynb
class BlockingMixin(W.Widget):
    "Mixin for widgets that supports blocking custom messages with the front-end."
    _loaded = T.Bool(False).tag(sync=True)

    def loaded(self): return self._loaded
    
    def setup_init_on_msg(self, callback=None):
        "Helper to setup the blocking mechanism. Call it before super().__init__(...)"
        def on_init_message(self, content, buffers):
            self._loaded = True
            self.on_msg(on_init_message, remove=True)
            if callback:
                self.on_msg(callback)
                callback(self, content, buffers)
        self.on_msg(on_init_message)
    
    @classmethod
    def create(cls, *args, 
        factory:Callable[..., Any]|None=None,
        timeout:float=10, sleep:float=0.0, n:int=10, show:Callable[[bool], None]|None=None,
        **kwargs
    ) -> Self:
        self: Self = (factory or cls)(*args, **kwargs)
        blocks(self.loaded, timeout, sleep, n, show)
        return self
    
    @classmethod
    async def acreate(cls, *args, 
        factory:Callable[..., Any]|None=None,
        timeout:float=10, sleep:float=0.0, n:int=10, show:Callable[[bool], None]|None=None,
        **kwargs
    ) -> Self:
        self: Self = (factory or cls)(*args, **kwargs)
        await ablocks(self.loaded, timeout, sleep, n, show)
        return self

    @overload
    def send(self, msg, buffers=None, *, timeout=None, 
            sleep: float = 1/15, n: int = 10, show: Callable[[bool], None]|None = None
    ) -> None: ...
    @overload
    def send(self, msg, buffers=None, *, timeout: float, 
            sleep: float = 1/15, n: int = 10, show: Callable[[bool], None]|None = None
    ) -> tuple[Any|Empty, Any|Empty]: ...
    def send(self, msg, buffers=None, *, timeout: float|None=None, 
            sleep: float = 1/15, n: int = 10, show: Callable[[bool], None]|None = None):
        """Send `msg` to the front-end. If `timeout` seconds is not None, the call blocks.
        NOTE: front-end can yet send back a result even if python timeout was triggered.
        """
        if timeout is None: return super().send(msg, buffers)
        if 'msg_id' not in msg: msg['msg_id'] = f"msg-{kounter('blocking')}"  # need to discriminate blocking calls
        return self._send_msg(msg, buffers, timeout, sleep, n, show)
    
    async def asend(self, msg, buffers=None, *, timeout: float=5.0, 
            sleep: float = 1/15, n: int = 10, show: Callable[[bool], None]|None = None
    ) -> tuple[Any|Empty, Any|Empty]:
        """Send `msg` to the front-end. Call will end after `timeout` seconds.
        NOTE: front-end can yet send back a result even if python timeout was triggered.
        """
        if 'msg_id' not in msg: msg['msg_id'] = f"msg-{kounter('blocking')}"
        return await self._asend_msg(msg, buffers, timeout, sleep, n, show)

    def _send_msg(self, msg, buffers=None, timeout: float = 5.0, 
            sleep: float = 0, n: int = 10, show: Callable[[bool], None]|None = None
    ) -> tuple[Any|Empty, Any|Empty]:
        "Send blocking `msg`. Return response tuple (content, buffers), or (empty, empty) if `timeout`."
        result, idx = None, msg.get('msg_id')
        def _on_msg(_, msg, buffers):
            nonlocal result
            if result is None and msg.get('msg_id', None) == idx: result = (msg, buffers)
        super().on_msg(_on_msg)
        try:
            super().send(msg, buffers)
            done = blocks(lambda: result is not None, timeout, sleep, n, show)
            if done:
                content, buffers = result  # type: ignore
                if content is empty: return (empty, empty)
                return content, buffers
            return (empty, empty)
        except Exception as e:  # something weird happened with IPython msg handling 
            if isinstance(e, RuntimeError): raise
            raise RuntimeError(f"Error during message processing: {str(e)}") from e
        finally:  # make sure to remove the temporary message handler
            super().on_msg(_on_msg, True)

    async def _asend_msg(self, msg, buffers=None, timeout: float = 5.0, 
            sleep: float = 0, n: int = 10, show: Callable[[bool], None]|None = None
    ) -> tuple[Any|Empty, Any|Empty]:
        "Send async `msg`. Return response tuple (content, buffers), or (empty, empty) if `timeout`."
        result, idx = None, msg.get('msg_id')
        def _on_msg(_, msg, buffers):
            nonlocal result
            if result is None and msg.get('msg_id', None) == idx: result = (msg, buffers)
        super().on_msg(_on_msg)
        try:
            super().send(msg, buffers)
            done = await ablocks(lambda: result is not None, timeout, sleep, n, show)
            if done:
                content, buffers = result  # type: ignore
                if content is empty: return (empty, empty)
                return content, buffers
            return (empty, empty)
        except Exception as e:
            if isinstance(e, RuntimeError): raise
            raise RuntimeError(f"Error during message processing: {str(e)}") from e
        finally:
            super().on_msg(_on_msg, True)

# %% ../nbs/10_bridge_widget.ipynb
class BridgeWidget(anywidget.AnyWidget, BlockingMixin):
    def __init__(self, *args, **kwargs):
        self._esm = bundled(self._esm)()
        super().__init__(*args, **kwargs)

# %% ../nbs/10_bridge_widget.ipynb
brdimport_js = BUNDLE_PATH / 'js/brdimport.js'
brdimport_esm = bundled(brdimport_js)()

# %% ../nbs/10_bridge_widget.ipynb
__brdimport__ = None

class BridgeImport(anywidget.AnyWidget):
    _esm = anysource(brdimport_esm, '''
export default { async initialize({ model, experimental }) {
  return brdimport.init(model, experimental.invoke);
}}
''')

    _loaded = T.Bool(False).tag(sync=True)

    def __init__(self, getter: Callable[[str], str|None]|None=None, **kwargs):
        self._get_module = getter or get_ESM
        super().__init__(**kwargs)

    @T.observe('_loaded')
    def _on_loaded(self, change):
        global __brdimport__
        __brdimport__ = self if change['new'] else None
        print(f"'brdimport' {'loaded' if __brdimport__ else 'unloaded'}")

    @anywidget.experimental.command  # type: ignore
    def get_module(self, moduleName, buffers):
        if DEBUG(): print(f'{moduleName=} {buffers=}')
        return self._get_module(moduleName), buffers

# %% ../nbs/10_bridge_widget.ipynb
def get_brdimport():
    if not __brdimport__:
        brdimport = BridgeImport()
        blocks(lambda: brdimport._loaded, 3, sleep=0.2)  # needed when running all above/below cells
        assert __brdimport__ is not None
    return __brdimport__

# %% ../nbs/10_bridge_widget.ipynb
get_brdimport()
