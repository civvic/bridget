# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/14_bridge_helpers.ipynb.

# %% ../nbs/14_bridge_helpers.ipynb 1
from __future__ import annotations

# %% auto 0
__all__ = ['bridge_js', 'bridge_esm', 'defaultLogConfig', 'logger_js', 'logger_esm', 'loader_js', 'loader_esm', 'observer_js',
           'observer_scr', 'Brd_Mark', 'marker_js', 'marker_scr', 'debug', 'notdebug', 'to_js', 'ScriptsDetails',
           'handle_message', 'BridgeWidget', 'Links', 'load_links', 'BLogger', 'Loader', 'get_loader', 'JupyUviB']

# %% ../nbs/14_bridge_helpers.ipynb
import os
import time
from collections import defaultdict
from pathlib import Path
from typing import Any
from typing import Callable

import anywidget
import fastcore.all as FC
import traitlets as T
from fastcore.all import L
from fastcore.all import NotStr
from fastcore.xml import escape
from fastcore.xml import to_xml
from fasthtml.core import FT
from fasthtml.jupyter import JupyUvi
from fasthtml.xtend import Script
from IPython.display import display
from IPython.display import HTML
from olio.basic import bundle_path
from olio.common import update_
from traitlets.config import SingletonConfigurable


# %% ../nbs/14_bridge_helpers.ipynb
from fasthtml.components import Div,B, Details, Summary, Pre

# %% ../nbs/14_bridge_helpers.ipynb
from .display_helpers import LogCanvas
from .display_helpers import LogCanvas_css
from .display_helpers import NBLogger
from .display_helpers import NoopLogger
from .helpers import bridge_cfg
from .helpers import id_gen
from .widget_helpers import anysource
from .widget_helpers import BlockingMixin
from .widget_helpers import bundled

# %% ../nbs/14_bridge_helpers.ipynb
new_id = id_gen()
DEBUG = os.environ.get('DEBUG', None) == 'True'
BUNDLE_PATH = bundle_path(__name__)

# %% ../nbs/14_bridge_helpers.ipynb
def debug(jsstr: str): return f"debugger;\n{jsstr}"
def notdebug(jsstr: str): return jsstr

# %% ../nbs/14_bridge_helpers.ipynb
def _to_js(ft):
    if isinstance(ft, FT): 
        return [ft.tag, [_to_js(_) for _ in ft.children], ft.attrs]
    return str(ft)

def to_js(*fts: FT|str):
    return f"[\n  {',\n  '.join(repr(_to_js(_)) if isinstance(_, FT) else repr(_) for _ in fts)}\n]"

# %% ../nbs/14_bridge_helpers.ipynb
class ScriptsDetails:
    def __init__(self, scs, title='Loaded scripts', open=True): 
        self.scs = scs; self.title = title; self.open = open
    def __ft__(self):
        return Details(open=self.open)(
            Summary(B(self.title)),
            Pre(NotStr('\n'.join(escape(to_xml(_, indent=False, do_escape=False).strip()) for _ in self.scs))),
        )

# %% ../nbs/14_bridge_helpers.ipynb
bridge_js = BUNDLE_PATH / 'js/bridge.js'
bridge_esm = bundled(bridge_js, bundle=__name__, bundler='copy')

# %% ../nbs/14_bridge_helpers.ipynb
class BridgeBoot(anywidget.AnyWidget, BlockingMixin, SingletonConfigurable):
    _esm = anysource(bridge_esm(debugger=DEBUG), '''
export default { 
    initialize({ model }) {
        $Brd.model = model;
        return () => $Brd.model = null;
    }
}
''')
    _css = LogCanvas_css

    def __init__(self, *args, **kwargs):
        self.on_msg(self.on_init_message)
        super().__init__(*args, **kwargs)
    @classmethod
    async def create(cls, *args, **kwargs):
        return await super().create(*args, factory=cls.instance, **kwargs)
    def loaded(self): return not self._loading
    def on_init_message(self, *_):
        "One-time init msg handler"
        self._loading = False
        self.on_msg(self.on_init_message, remove=True)
        time.sleep(0.1)
        self.close()

# %% ../nbs/14_bridge_helpers.ipynb
async def get_bridge(*args, **kwargs):
    if not BridgeBoot.initialized():
        bridge = await BridgeBoot.create(*args, **kwargs)
        if not bridge.loaded(): bridge = None
    else: 
        if not BridgeBoot.instance().loaded(): BridgeBoot.clear_instance()
        bridge = BridgeBoot.instance()
    return bridge

# def get_bridge(*args, **kwargs):
#     async def _arun(): return await _get_bridge(*args, **kwargs)
#     with from_thread.start_blocking_portal() as portal: return portal.call(_arun)

# %% ../nbs/14_bridge_helpers.ipynb
def handle_message(
        o: Any, 
        *args: Any, 
        ctx:str, kind:str, 
        prefix:str='on_', forward:bool=True, forward_name:str='_msg_hndlr', 
        **kwargs: Any):
    """if `o` has an attr named `ctx`, look for a handler with the form `on_{kind}` 
    passing the rest of `msg` and `args` to it. 
    If `forward`and `o` has an attr named `forward_name`, call it with `o`, `msg` and `args`."""
    # print(f"handle_message: {o=} {args=} {ctx=}, {kind=} {kwargs=}")
    if ctx in getattr(o, 'ctx_names', ()) and (fn := getattr(o, f"{prefix}{kind}", None)): fn(*args, **kwargs)
    if forward and (fn := getattr(o, forward_name, None)): fn(o, *args, ctx=ctx, kind=kind, **kwargs)

# %% ../nbs/14_bridge_helpers.ipynb
class BridgeWidget(anywidget.AnyWidget, BlockingMixin):
    _esm = anysource('''
export default { 
    initialize({ model }) {
        $Brd.model = model;
        model.send({ ctx: model.get('ctx_name'), kind: 'info', info: 'loaded' });
        return () => $Brd.model = null;
    }
}
''')

    ctx_name = T.Unicode('bridge').tag(sync=True)
    ctx_names: set[str]
    logger = T.Instance(NBLogger, default_value=NoopLogger())
    
    def __init__(self, msg_hndlr:Callable|None=None, **kwargs):
        self._loading, self._pending, self._msg_hndlr = True, defaultdict(dict), msg_hndlr
        self.on_msg(self.on_init_message)
        super().__init__(**kwargs)
        self.logger.log(f"Loading {self.__class__.__name__}...")
        # Warning: AnyWidget calls `self.add_traits()`: self.__class__ before 
        # super()__init__ is not self.__class__ now
        self.ctx_names = set(L(type(self).mro()).attrgot('ctx_name.default_value').filter())
    
    @classmethod
    async def create(cls, *args, **kwargs):
        if not await get_bridge(): raise RuntimeError("Bridge is not loaded.")
        self = await super().create(*args, **kwargs)
        if self._loading: self.logger.log(f"Timeout loading {cls.__name__}@{hex(id(self))}")
        else: self.logger.log(f"----")
        return self

    def msg(self, tracker:Any=None, **kwargs): 
        msg_id = new_id()
        if tracker: self._pending[msg_id] = tracker
        return update_(kwargs, msg_id=msg_id)

    def on_info(self, *args, info:str, **kwargs):
        "Handle info messages from the front-end."
        if info == 'loaded':
            self.logger.log(f"{self.__class__.__name__}@{hex(id(self))} loaded.")
            self.logger.log(str(vars(bridge_cfg)))
        if info == 'model-setup':
            self.logger.log(f"{self.__class__.__name__}@{hex(id(self))} model set.")
        if info == 'model-unset':
            self.logger.log(f"{self.__class__.__name__}@{hex(id(self))} model unset.")

    def on_error(self, *args, error:str, **kwargs):
        "Handle error messages from the front-end."
        self.logger.log(f"{self.__class__.__name__}@{hex(id(self))} error: {error}")

    def on_init_message(self, _, content, buffers):
        "One-time init msg handler"
        self._loading = False
        self.on_msg(self.on_init_message, remove=True)
        self.on_msg(self.on_message)
        handle_message(self, buffers, **content)
    
    def on_message(self, _, content, buffers):
        tracker = self._pending[msg_id] if (msg_id := content.get('msg_id')) else None
        handle_message(self, buffers, **content, tracker=tracker)
        if msg_id and not tracker: self._pending.pop(msg_id)

# %% ../nbs/14_bridge_helpers.ipynb
def Links(*fts: FT):
    return Script(notdebug("""
if (window.$Ls) requestAnimationFrame(() => $Ls(%s));
""" % to_js(*fts)), type='module')

# %% ../nbs/14_bridge_helpers.ipynb
def load_links(*fts: FT, feedback: str=''):
    dh = display(HTML(to_xml(Links(*fts)) + feedback), display_id=True)
    # if not feedback and dh: dh.update(HTML(''))
    # if not feedback: clear_output()

# %% ../nbs/14_bridge_helpers.ipynb
defaultLogConfig = {
    'ns': 'brd',
    'color': '#000000',
    'fmt': 'htmlFmt',
    'tsDelta': True,
    'INFO': {
        'level': 'INFO',
    },
    'ERROR': {
        'level': 'ERROR',
        'color': '#FF0000',
    },
}

logger_js = BUNDLE_PATH / 'js/logger.js'
logger_esm = bundled(logger_js, bundle=__name__, bundler='copy')

class BLogger(anywidget.AnyWidget, NBLogger):
    "Configure a LogCanvas as the Bridge logger."
    _esm = anysource(logger_esm(debugger=DEBUG), '''
export default { 
    initialize({ model }) { return initLogger(model); }
};
''')
    
    canvas: LogCanvas
    logger_config = T.Dict(default_value=defaultLogConfig).tag(sync=True)
    elid = T.Unicode('').tag(sync=True)
    
    def __init__(self, canvas:LogCanvas|None=None, show:bool=True, **kwargs):
        self.canvas = canvas or LogCanvas()
        T.link((self.canvas, 'elid'), (self, 'elid'))
        if show: 
            def _on_init_message(self, *_):
                self.on_msg(_on_init_message, remove=True)
                self.display()
            self.on_msg(_on_init_message)
        super().__init__(**kwargs)

    def display(self, content:str=''): self.canvas.display(content)
    
    # @T.observe('canvas')
    # def canvas_changed(self, change):
    #     if change['new']: 
    #         self.logger_config = { **self.logger_config, 'elid': change['new'].elid }

    def config(self, **kwargs): self.logger_config = { **self.logger_config, **kwargs }
    def log(self, msg:str, clear:bool=False):
        self.send({'rec':{'message':msg, 'level': 'INFO'}, 'clear':clear or None})
    def clear_log(self): self.send({'clear':True})
    def close(self, msg:str|None=None):
        if self.comm is not None:
            self.send({'rec':{ 'message':msg if msg else 'logger closed.', 'level': 'INFO' }})
            self.send = FC.noop  # type: ignore
            super().close()

# %% ../nbs/14_bridge_helpers.ipynb
loader_js = BUNDLE_PATH / 'js/loader.js'
loader_esm = bundled(loader_js, bundle=__name__, bundler='copy')

class Loader(BridgeWidget, SingletonConfigurable):
    _esm = anysource(loader_esm(debugger=DEBUG), '''
export default { 
    initialize({ model }) { 
        $Brd.model = model;
        initializeLoader(model);
        model.send({ ctx: model.get('ctx_name'), kind: 'info', info: 'loaded' });
        return () => $Brd.model = null;
    }
};
''')

    ctx_name = T.Unicode('loader').tag(sync=True)
    lnks = {}
    _loaded = T.Set()

    def __init__(self, 
            lnks: dict[str, FT]|None = None, 
            esms: list[str|Path]|None = None, 
            *, logger:NBLogger|None=None, **kwargs
        ):
        if lnks: self.lnks = lnks
        if logger is None: logger = BLogger(canvas=LogCanvas())
        logger.display()
        super().__init__(logger=logger, **kwargs)

    @classmethod
    async def create(cls, *args, **kwargs):
        return await super().create(*args, factory=cls.instance, **kwargs)

    def on_info(self, *args, info:str, **kwargs):
        super().on_info(*args, info=info, **kwargs)
        if info == 'loaded': # now we can initialize the scripts
            self.load_links(**self.lnks)

    def loaded(self, name:str|None=None):
        if not name: return not self._loading
        return name in self._loaded
    
    def on_load(self, *args, success:list[str], failed:list[dict[str,str]], tracker:dict, **kwargs):
        for name in success: self.logger.log(f"'{name}' loaded.")
        for res in failed: self.logger.log(f"'{res['name']}' failed: {res['error']}")
        self._loaded = self._loaded.union(success)
        
    def on_loadLinks(self, *args, success:list[str], failed:list[dict[str,str]], tracker:dict, **kwargs):
        for name in success: self.logger.log(f"'{name}' loaded.")
        for res in failed: self.logger.log(f"'{res['name']}' failed: {res['error']}")
        self._loaded = self._loaded.union(success)

    def load(self, **esms: str|Path):
        if not esms: return
        msg = self.msg(esms, ctx='loader', cmd='load', 
            args={n:esm.read_text() if isinstance(esm, Path) else esm for n,esm in esms.items()})
        self.send(msg)
    def load_links(self, **lnks: FT):
        if not lnks: return
        msg = self.msg(lnks, ctx='loader', cmd='loadLinks', args={n:_to_js(_) for n,_ in lnks.items()})
        self.send(msg)

    async def _asend(self, msg, kind:str):
        res = await self.asend(msg)
        try:
            msg_id = res[0]['msg_id']  # type: ignore
            if msg_id in self._pending: self.logger.log(f"Timeout loading {kind} {msg_id}")
        except Exception: pass
    async def aload(self, **esms: str|Path):
        if not esms: return
        msg = self.msg(esms, ctx='loader', cmd='load', 
            args={n:esm.read_text() if isinstance(esm, Path) else esm for n,esm in esms.items()})
        await self._asend(msg, 'ESMs')
    async def aload_links(self, **lnks: FT):
        if not lnks: return
        msg = self.msg(lnks, ctx='loader', cmd='loadLinks', args={n:_to_js(_) for n,_ in lnks.items()})
        await self._asend(msg, 'links')

# %% ../nbs/14_bridge_helpers.ipynb
# def get_loader():
#     async def _arun(): return await Loader.create()
#     with from_thread.start_blocking_portal() as portal: return portal.call(_arun)
async def get_loader(*args, **kwargs): 
    if not Loader.initialized():
        return await Loader.create(*args, **kwargs)
    loader = Loader.instance()
    loader.logger.display()
    return loader

# %% ../nbs/14_bridge_helpers.ipynb
observer_js = BUNDLE_PATH / 'js/observer.js'
observer_scr = Script(debug(observer_js.read_text()), type='module', id='brd-observer-manager')

# %% ../nbs/14_bridge_helpers.ipynb
def htmx_config_port(host='localhost', port=8000):
    display(HTML('''
<script>
document.body.addEventListener('htmx:configRequest', (event) => {
    if(event.detail.path.includes('://')) return;
    htmx.config.selfRequestsOnly=false;
    event.detail.path = `http://%s:%s${event.detail.path}`;
});
</script>''' % (host, port)))

# %% ../nbs/14_bridge_helpers.ipynb
class JupyUviB(JupyUvi):
    "Start and stop a Jupyter compatible uvicorn server with ASGI `app` on `port` with `log_level`"
    def __init__(self, app, log_level="error", host='0.0.0.0', port=8000, start=True, **kwargs):
        self.kwargs = kwargs
        FC.store_attr(but='start')
        self.server = None
        if start: self.start()
        htmx_config_port(host, port)

# %% ../nbs/14_bridge_helpers.ipynb
def render_ft():
    @FC.patch
    def _repr_html_(self:FT): 
        return to_xml(
            (Div(self), 
            Script('if (window.htmx) htmx.process(document.body)'))
        )

# %% ../nbs/14_bridge_helpers.ipynb
_all_ = ['Brd_Mark']

Brd_Mark = FT('brd-mark', (), {})

marker_js = '''
if (!customElements.get('brd-mark')) {
    class BridgetMarker extends HTMLElement {
        connectedCallback() {
            this.style.display = 'none';
            const pel = this.parentElement;
            if (pel) {
                const bridgetId = this.getAttribute('id');
                if (bridgetId) {
                    if (!pel.hasAttribute('data-brt-id')) pel.setAttribute('data-brt-id', bridgetId);
                    $Brd.logger.log('bridget marker set', bridgetId);
                    this.remove();
                }
                if (window.htmx) htmx.process(pel);
            }
        }
    }
    customElements.define('brd-mark', BridgetMarker);
    $Brd.logger.log('brd-mark defined');
} else {
    $Brd.logger.log('brd-mark is already defined');
}
'''

marker_scr = Script(notdebug(marker_js), id='brd-mark')
