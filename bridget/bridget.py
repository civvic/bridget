"""HTMX + FastHTML - Server for Jupyter Notebooks"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/32_bridget.ipynb.

# %% ../nbs/32_bridget.ipynb 1
from __future__ import annotations

# %% auto 0
__all__ = ['Bridgeable', 'ClientP', 'request2httpx_request', 'HasFT', 'HasHTML', 'request2response', 'httpx_response_to_json',
           'BridgetClient', 'Bridget', 'get_bridget', 'get_app']

# %% ../nbs/32_bridget.ipynb
import time
from types import MethodType
from typing import Any
from typing import Mapping
from typing import Protocol
from typing import TypeAlias

import fastcore.all as FC
from anyio import from_thread
from fastcore.xml import FT
from fastcore.xml import to_xml
from fasthtml.core import APIRouter
from fasthtml.core import Client
from fasthtml.core import FastHTML
from httpx import ASGITransport
from httpx import AsyncClient
from httpx import codes
from httpx import Request
from httpx import Response
from IPython.display import display
from IPython.display import DisplayHandle
from IPython.core.display import HTML
from pote.basic import bundle_path


# %% ../nbs/32_bridget.ipynb
from fasthtml.components import Div, Details, Summary, B, Pre, Span, Strong


# %% ../nbs/32_bridget.ipynb
from .bridge import BridgePlugin
from .bridge import get_bridge
from .bridge_plugins import HTMXCommanderPlugin
from .bridge_plugins import NBHooksPlugin
from .bridge_widget import bundled
from .helpers import bridge_cfg
from .helpers import DetailsJSON
from .helpers import id_gen
from .helpers import nb_app
from .nb_state import get_nb
from .routing import add_routes
from .routing import mount
from .routing import RouteProviderP


# %% ../nbs/32_bridget.ipynb
BUNDLE_PATH = bundle_path(__name__)
new_id = id_gen()
IDISPLAY = display

# %% ../nbs/32_bridget.ipynb
_n = '\n'

# %% ../nbs/32_bridget.ipynb
# if typing.TYPE_CHECKING:
class ClientP(Protocol):
    "HTTP client interface supporting REST operations (get, post, delete)"
    def get(self, url: str, **kwargs) -> Response: ...
    def post(self, url: str, **kwargs) -> Response: ...
    def delete(self, url: str, **kwargs) -> Response: ...
    def put(self, url: str, **kwargs) -> Response: ...
    def patch(self, url: str, **kwargs) -> Response: ...
    def options(self, url: str, **kwargs) -> Response: ...

# %% ../nbs/32_bridget.ipynb
def request2httpx_request(cli:AsyncClient, http_request: dict[str, Any]) -> Request:
    "Convert bridget request dict to httpx Request object"
    r = http_request
    return cli.build_request(r['method'], r['url'], 
        headers=r['headers'] if 'headers' in r else {}, 
        content=r['body'] if 'body' in r else None, timeout=None)


# %% ../nbs/32_bridget.ipynb
class HasFT(Protocol): 
    "Objects that can convert themselves to FastHTML FT components"
    def __ft__(self) -> Any: ...
class HasHTML(Protocol):
    "Objects that can render themselves as HTML strings"
    def __html__(self) -> str: ...

Bridgeable: TypeAlias = str|Mapping|FT|HasFT|HasHTML


def request2response(cli:AsyncClient, http_request) -> Response:
    "Execute bridget request and return httpx Response"
    httpx_request = request2httpx_request(cli, http_request)
    with from_thread.start_blocking_portal() as portal: 
        response = portal.call(cli.send, httpx_request)
    return response


def httpx_response_to_json(response: Response) -> dict[str, Any]:
    "Convert httpx Response to JSON dict with headers and content"
    hdrs = {**response.headers, 
        'last-modified': time.strftime('%a, %d %b %Y %H:%M:%S GMT', time.gmtime()),
        'cache-control': 'no-store, no-cache, must-revalidate',
    }
    data = response.content.decode()
    json_response = {
        "headers": hdrs,
        "status": response.status_code,
        "statusText": codes.get_reason_phrase(response.status_code),
        # "text": data,
        "data": data,
        "xml": None,
        'finalUrl': f"{response.request.url}",
    }
    return json_response


# %% ../nbs/32_bridget.ipynb
class BridgetClient:
    "A simple wrapper around `FastHTML` and `Client`."

    def setup(self, app: FastHTML|None=None):
        if app is None:
            app = nb_app()
            app.user_middleware.clear()
        self.app = app
        cli:ClientP = Client(self.app, 'http://nb)')  # type: ignore
        self.cli = cli
        self._cli = AsyncClient(transport=ASGITransport(self.app), base_url='http://nb')#, headers={'hx-request': '1'})
        return self
    
    def __call__(self, rt:Bridgeable='', method='GET', req=None, **kwargs):
        "Display FastHTML components, routes or requests in notebook cells."
        if isinstance(rt, FT) or hasattr(rt, '__ft__'): cts = HTML(to_xml(rt))  # type: ignore
        # elif hasattr(rt, '__html__'): cts = rt.__html__()  # type: ignore
        elif hasattr(rt, '__html__'): cts = HTML(rt.__html__())  # type: ignore
        else:
            if isinstance(rt, Mapping):
                http_request = {**(req or {}), **rt}
                if 'method' not in http_request: http_request['method'] = method
            else: http_request = {'headers': {'hx-request': '1'}, 'method': method, 'url': rt}
            cts = HTML(request2response(self._cli, http_request).text)
        if not cts:
            try: cts = HTML(to_xml(rt))
            except: pass
        if cts:
            # display_id, update = kwargs.pop('display_id', None), kwargs.pop('update', False)
            display_id = kwargs.pop('display_id', None)
            # dhdl = display_id if isinstance(display_id, DisplayId) else DisplayId(display_id=display_id)
            dhdl = display_id if isinstance(display_id, DisplayHandle) else DisplayHandle(display_id=display_id)
            # if display_id and update: dhdl.update(cts)
            if display_id: dhdl.update(cts)
            # else: dhdl.display(HTML(cts))
            # return None if dhdl is display_id else dhdl
            else: display(cts, display_id=dhdl.display_id)
            return None if dhdl is display_id else dhdl

    # def __call__(self, rt: Bridgeable='', method='GET', req=None, **kwargs):
    #     "Display FastHTML components, routes or requests in notebook cells."
    #     if isinstance(rt, FT) or hasattr(rt, '__ft__'): o = HTML(to_xml(rt))
    #     elif hasattr(rt, '__html__'): o = HTML(getattr(rt, '__html__')())
    #     else:
    #         if isinstance(rt, Mapping):
    #             http_request = {**(req or {}), **rt}
    #             if 'method' not in http_request: http_request['method'] = method
    #         else: http_request = {'headers': {'hx-request': '1'}, 'method': method, 'url': rt}
    #         o = HTML(request2response(self._cli, http_request).text)
    #     if not o:
    #         try: o = HTML(to_xml(rt))
    #         except: pass
    #     if o:
    #         display_id = kwargs.pop('display_id', None)
    #         dh = display_id if isinstance(display_id, DisplayHandle) else DisplayHandle(display_id=display_id)
    #         if display_id: dh.update(o)
    #         else: display(o, display_id=dh.display_id)

    def _response(self, req:dict[str, Any]): return request2response(self._cli, req)
    
    def mount(self, prov:APIRouter|RouteProviderP, 
            path:str|None=None, name:str|None=None, index:str|None=None, 
            show:bool=True):
        ar = mount(self.app, prov, path, name)
        if hasattr(prov, '_mounted'): setattr(prov, '_mounted', True)
        if hasattr(prov, 'bridget'): setattr(prov, 'bridget', self)
        if show: self(index or f"{ar.to()}/")  # type: ignore
        return ar

# %% ../nbs/32_bridget.ipynb
bridget_js = BUNDLE_PATH / 'js/bridget.js'
bridget_esm = bundled(bridget_js)

# %% ../nbs/32_bridget.ipynb
class Bridget(BridgePlugin, BridgetClient):
    src = bundled('''
import { setupBridget } from './bridget.js';

export default async function initializeBridget(bridge) {
    return setupBridget();
}
''')()
    ctx_name = 'bridget'
    
    request: dict   # Incoming HTMX requests
    response: dict  # Outgoing responses
    
    def __init__(self, app: FastHTML|None=None, *args, **kwargs):
        self.setup(app)
        super().__init__(*args, **kwargs)

    def on_request(self, *args, request:dict[str, Any], **kwargs):
        "Handle incoming HTMX requests"
        self.request = request
        response =  self._response(request)
        resp = httpx_response_to_json(response)
        resp['req_id'] = request['req_id']
        self._show_req(request, resp)
        self.response = resp
        self.send({ 'ctx': self.ctx_name, 'cmd': 'response', 'response': resp })
    
    def _show_req(self, req:dict[str, Any], resp:dict[str, Any]):
        # if bridge_cfg.debug_req: self._show_req(request, resp)
        self.log(
                # pretty_repr(req, text=False) + pretty_repr(resp, text=False)
                # to_xml(Div(cls='bridget-debug')(
                #     'Request: ', NotStr(pretty_repr(req, text=False)),
                #     'Response: ', NotStr(pretty_repr(resp, text=False))
                # ))
                to_xml(DetailsJSON({
                    'Request': req,
                    'Response': resp
                }))
            )


@FC.delegates(get_bridge, keep=True)  # type: ignore
def get_bridget(app=None, **kwargs) -> Bridget:
    bridge, plgns = get_bridge(**kwargs), []
    if not bridge.plugins.get('commander'): plgns.append(HTMXCommanderPlugin())
    if not bridge.plugins.get('bridget'): plgns.append(Bridget(app))
    if plgns: bridge = get_bridge(plugins=plgns, wait=5)
    return bridge.plugins['bridget']  # type: ignore

# %% ../nbs/32_bridget.ipynb
@FC.delegates(get_bridge, keep=True)  # type: ignore
def get_app(hooks=False, nb=False, cfg:Mapping|None=None, **kwargs) -> tuple[FastHTML, Bridget, MethodType]:
    if cfg: bridge_cfg.update(**cfg)
    if nb: get_nb()
    plugins = kwargs.pop('plugins', [])
    if not nb and hooks: plugins.append(NBHooksPlugin())
    bridget = get_bridget(plugins=plugins, **kwargs)
    return bridget.app, bridget, bridget.app.route  # type: ignore
