"""HTMX + FastHTML - Server for Jupyter Notebooks"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/22_bridget.ipynb.

# %% ../nbs/22_bridget.ipynb 1
from __future__ import annotations


# %% auto 0
__all__ = ['bridge_cfg', 'Bridgeable', 'Config', 'BridgeCfg', 'ScriptsDetails', 'bridget_scripts', 'ClientP', 'Script', 'Style',
           'autoid', 'DisplayId', 'request2httpx_request', 'HasFT', 'HasHTML', 'request2response',
           'httpx_response_to_json', 'BridgeBase', 'Bridget', 'get_app']

# %% ../nbs/22_bridget.ipynb 6
import dataclasses
import inspect
import time
from contextlib import contextmanager
from pathlib import Path
from types import MethodType
from typing import Any
from typing import Mapping
from typing import Protocol
from typing import TypeAlias

import anywidget
import fastcore.all as FC
import traitlets as T
from anyio import from_thread
from fastcore.xml import escape
from fastcore.xml import FT
from fastcore.xml import NotStr
from fastcore.xml import to_xml
from fasthtml.basics import ft_html
from fasthtml.core import Client
from fasthtml.core import FastHTML
from httpx import ASGITransport
from httpx import AsyncClient
from httpx import codes
from httpx import Request
from httpx import Response
from IPython.display import display
from IPython.display import DisplayHandle
from IPython.display import HTML


# %% ../nbs/22_bridget.ipynb 7
from fasthtml.components import Div, Details, Summary, B, Pre


# %% ../nbs/22_bridget.ipynb 8
import bridget
from .helpers import cleanupwidgets
from .helpers import id_gen
from .helpers import nb_app
from .helpers import pops_
from .helpers import pretty_repr
from .helpers import read_vfile
from .htmx import swap
from .htmx import SwapStyleT
from .route_provider import add_routes
from .route_provider import APIRouterB
from .route_provider import RoutesProviderP


# %% ../nbs/22_bridget.ipynb 12
DEBUG = True
new_id = id_gen()
IDISPLAY = display


# %% ../nbs/22_bridget.ipynb 17
_BUNDLER_PATH = Path() if __name__ == "__main__" else Path(inspect.getfile(bridget)).parent


# %% ../nbs/22_bridget.ipynb 19
_n = '\n'

# %% ../nbs/22_bridget.ipynb 22
class Config:
    def update(self, **kwargs):
        for k,v in kwargs.items(): 
            try: setattr(self, k, v)
            except AttributeError: pass
    def show(self): print(vars(self))
    @contextmanager
    def __call__(self, **kwargs):
        vv = vars(self)
        old = {k:vv[k] for k in kwargs if k in vv}
        for k,v in kwargs.items(): setattr(self, k, v)
        yield
        for k,v in old.items(): setattr(self, k, v)


# %% ../nbs/22_bridget.ipynb 24
@dataclasses.dataclass
class BridgeCfg(Config):
    auto_show: bool = False
    auto_mount: bool = False
    auto_id: bool = False
    current_did: str|None = None
    debug_req: bool = False

bridge_cfg = BridgeCfg()


# %% ../nbs/22_bridget.ipynb 29
@FC.patch
def _repr_mimebundle_(self: FT, include=None, exclude=None):
    mb = {'text/plain': repr(self)}
    if not bridge_cfg.auto_show: mb['text/markdown'] = self._repr_markdown_()
    else: mb['text/html'] = self.__html__()
    return mb


# %% ../nbs/22_bridget.ipynb 30
@FC.patch
def _ipython_display_(self: FT):
    IDISPLAY(self._repr_mimebundle_(), raw=True, display_id=bridge_cfg.current_did)


# %% ../nbs/22_bridget.ipynb 37
class ScriptsDetails:
    def __init__(self, scs, title='Loaded scripts', open=True): 
        self.scs = scs; self.title = title; self.open = open
    def __ft__(self):
        return Details(open=self.open)(
            Summary(B(self.title)),
            Pre(NotStr('\n'.join(escape(to_xml(_, indent=False, do_escape=False).strip()) for _ in self.scs))),
        )

def _bridget_scripts_extra():
    from fasthtml.core import surrsrc, scopesrc
    return {'surreal': surrsrc, 'css_scope_inline': scopesrc}

def bridget_scripts(load=False):
    from fasthtml.core import fhjsscr
    from fasthtml.xtend import Script
    htmxsrc = Script(src=f"https://unpkg.com/htmx.org@next/dist/htmx.{'' if DEBUG else 'min.'}js")()
    scs = {'htmx': htmxsrc, 'fasthtml_js': fhjsscr, **_bridget_scripts_extra()}
    if load: display(HTML(to_xml((*(scvals := [_ for _ in scs.values()]), ScriptsDetails(scvals)))))
    return scs


# %% ../nbs/22_bridget.ipynb 42
# if typing.TYPE_CHECKING:
class ClientP(Protocol):
    def get(self, url: str, **kwargs) -> Response: ...
    def post(self, url: str, **kwargs) -> Response: ...
    def delete(self, url: str, **kwargs) -> Response: ...
    def put(self, url: str, **kwargs) -> Response: ...
    def patch(self, url: str, **kwargs) -> Response: ...
    def options(self, url: str, **kwargs) -> Response: ...


# %% ../nbs/22_bridget.ipynb 44
@FC.delegates(ft_html, keep=True)  # type: ignore
def Script(code:str="", **kwargs)->FT:
    "A Script tag that doesn't escape its code"
    return ft_html('script', (_n, NotStr(FC.ifnone(read_vfile(code), code))), **kwargs)

@FC.delegates(ft_html, keep=True)  # type: ignore
def Style(*c, **kwargs)->FT:
    "A Style tag that doesn't escape its code"
    return ft_html('style', tuple(NotStr(FC.ifnone(read_vfile(_), _)) for _ in c), **kwargs)


# %% ../nbs/22_bridget.ipynb 52
__autoid_scr = '''
//debugger;
me().attribute('id', 'output-{0}').classAdd('bridge');
setTimeout(el => {{ el.remove(); }}, 100, me('#{0}'))
'''
def autoid(idx=None):
    idx = idx or new_id()
    return Script(__autoid_scr.format(idx), id=idx), idx


# %% ../nbs/22_bridget.ipynb 56
class DisplayId(DisplayHandle):
    def __init__(self, display_id=None):
        super().__init__(display_id or new_id())
        self._contents = None
        self._sc = to_xml(autoid(self.display_id)[0]) if bridge_cfg.auto_id else ''

    def display(self, obj='', **kwargs):
        from IPython.display import display
        self._contents = str(obj)
        display(HTML(self._contents + self._sc), display_id=self.display_id, **kwargs)

    def update(self, obj='', **kwargs):
        kwargs['update'] = True
        self.display(obj, **kwargs)

    def contents(self):
        return self._contents


# %% ../nbs/22_bridget.ipynb 66
def request2httpx_request(cli:AsyncClient, http_request: dict[str, Any]) -> Request:
    r = http_request
    return cli.build_request(r['method'], r['url'], 
        headers=r['headers'] if 'headers' in r else {}, 
        content=r['body'] if 'body' in r else None, timeout=None)


# %% ../nbs/22_bridget.ipynb 67
class HasFT(Protocol): 
    def __ft__(self) -> Any: ...
class HasHTML(Protocol):
    def __html__(self) -> str: ...

Bridgeable: TypeAlias = str|Mapping|FT|HasFT|HasHTML


def request2response(cli:AsyncClient, http_request) -> Response:
    httpx_request = request2httpx_request(cli, http_request)
    with from_thread.start_blocking_portal() as portal: 
        response = portal.call(cli.send, httpx_request)
    return response


def httpx_response_to_json(response: Response) -> dict[str, Any]:
    hdrs = {**response.headers, 
        'last-modified': time.strftime('%a, %d %b %Y %H:%M:%S GMT', time.gmtime()),
        'cache-control': 'no-store, no-cache, must-revalidate',
    }
    data = response.content.decode()
    json_response = {
        "headers": hdrs,
        "status": response.status_code,
        "statusText": codes.get_reason_phrase(response.status_code),
        # "text": data,
        "data": data,
        "xml": None,
        'finalUrl': f"{response.request.url}",
    }
    return json_response


# %% ../nbs/22_bridget.ipynb 70
class BridgeBase:
    "A simple wrapper around `FastHTML` and `Client`."

    def __init__(self, app: FastHTML, *args, **kwargs):
        self.app = app
        cli:ClientP = Client(self.app, 'http://nb)')  # type: ignore
        self.cli = cli
        self._cli = AsyncClient(transport=ASGITransport(self.app), base_url='http://nb')#, headers={'hx-request': '1'})
        super().__init__(*args, **kwargs)
    
    def __call__(self, rt:Bridgeable='', method='GET', req=None, **kwargs):
        "Display FastHTML components, routes or requests in notebook cells."
        if isinstance(rt, FT) or hasattr(rt, '__ft__'): cts = to_xml(rt)  # type: ignore
        elif hasattr(rt, '__html__'): cts = rt.__html__()  # type: ignore
        else:
            if isinstance(rt, Mapping):
                http_request = {**(req or {}), **rt}
                if 'method' not in http_request: http_request['method'] = method
            else: http_request = {'headers': {'hx-request': '1'}, 'method': method, 'url': rt}
            cts = request2response(self._cli, http_request).text
        if not cts:
            try: cts = to_xml(rt)
            except: pass
        if cts:
            display_id, update = kwargs.pop('display_id', None), kwargs.pop('update', False)
            dhdl = display_id if isinstance(display_id, DisplayId) else DisplayId(display_id=display_id)
            if display_id and update: dhdl.update(cts)
            else: dhdl.display(cts)
            return None if dhdl is display_id else dhdl

    def _response(self, req:dict[str, Any]): return request2response(self._cli, req)
    
    def mount(self, prov:APIRouterB|RoutesProviderP, 
            path:str|None=None, name:str|None=None, index:str|None=None, 
            show:bool=True):
        ar = add_routes(self.app, prov, True, path, name)
        if hasattr(prov, 'bridget'): setattr(prov, 'bridget', self)
        if show: self(index or f"{ar.to}/")
        return ar

    def swap(self,
            target, 
            content, 
            *, 
            # ---- swapSpec:SwapSpec, 
            swapStyle: SwapStyleT='innerHTML',
            swapDelay: int|None=None, settleDelay: int|None=None,
            transition: bool|None=None,
            # ignoreTitle: bool|None=None, head: Literal['merge', 'append']|None=None,
            scroll: str|None=None, scrollTarget: str|None=None,
            show: str|None=None, showTarget: str|None=None, focusScroll: bool|None=None,
            # ---- swapOptions=None,
            select: str|None=None, selectOOB: str|None=None,
            # eventInfo: dict|None=None,
            anchor: str|None=None,        
            # contextElement: str|None=None,
            # afterSwapCallback: Callable|None=None, afterSettleCallback: Callable|None=None,
        ): ...


FC.patch_to(BridgeBase)(swap)


# %% ../nbs/22_bridget.ipynb 92
class Bridget(BridgeBase, anywidget.AnyWidget):
    "Bridge this notebook kernel and front-end, intercepting HTMX Ajax requests."
    _esm = _BUNDLER_PATH / 'bridget.js'

    request = T.Dict({}).tag(sync=True)   # Incoming HTMX requests
    response = T.Dict({}).tag(sync=True)  # Outgoing responses

    htmx = T.Bool(True).tag(sync=True)
    htmx_sels = T.List(['.output', '.jp-Cell-outputArea']).tag(sync=True)

    libraries = T.Dict({k:v.src for k,v in bridget_scripts().items()}).tag(sync=True)

    def __new__(cls, *args, **kwargs) -> Bridget:
        "Ensure single instance per notebook"
        if '__instance__' not in cls.__dict__: cls.__instance__ = super().__new__(cls, *args, **kwargs)
        return cls.__instance__
    
    def __init__(self, app=None, *args, display=False, **kwargs):
        "Initialize with FastHTML app and optional display"
        if not hasattr(self, 'app'):
            assert app, "Bridget must be initialized with an app"
            super().__init__(app, *args, **kwargs)
            self.dhdl = None
        if display: self.display()

    def display(self):
        "Display widget and initialize debug output"
        from IPython.display import display
        if self.dhdl:
            self.dhdl.update('')
        display(self)
        self.dhdl = DisplayId()
        self.dhdl.display()
    
    def close(self):
        "Clean up widget instance and display"
        if hasattr(self, '__instance__'):
            del Bridget.__instance__
            if self.dhdl:
                self.dhdl.update('')  # type: ignore
                self.dhdl = None
        super().close()

    @T.observe('request')
    def _on_request(self, chg):
        "Handle incoming HTMX requests"
        req = chg['new']
        response = self._response(req)
        resp = httpx_response_to_json(response)
        resp['req_id'] = req['req_id']
        if bridge_cfg.debug_req: self._show_req(req, resp)
        self.response = resp
    
    def _show_req(self, req:dict[str, Any], resp:dict[str, Any]):
        if self.dhdl:
            self.dhdl.update(
                # pretty_repr(req, text=False) + pretty_repr(resp, text=False)
                to_xml(Div(cls='bridget-debug', style='border: 1px solid black; height: 40em; overflow: auto')(
                    'Request: ', NotStr(pretty_repr(req, text=False)),
                    'Response: ', NotStr(pretty_repr(resp, text=False))
                ))
            )



# %% ../nbs/22_bridget.ipynb 95
def get_app(setup_scripts=False, app=None, appkw:dict[str, Any]={}, **cfargs) -> tuple[FastHTML, Bridget, MethodType]: 
    bridge_cfg.update(**cfargs)
    if setup_scripts: bridget_scripts(True)
    app = app or nb_app(**appkw)
    return app, Bridget(app, display=True), app.route  # type: ignore

