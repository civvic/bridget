"""..."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/11_logger.ipynb.

# %% ../nbs/11_logger.ipynb 1
from __future__ import annotations

# %% auto 0
__all__ = ['FCanvas_css', 'FCanvas_stl', 'Canvas', 'DhCanvas', 'FCanvas', 'NBLogger', 'NoopLogger', 'BasicLogger', 'FLogger']

# %% ../nbs/11_logger.ipynb
import json
import typing
from collections import deque
from functools import partialmethod
from typing import Callable

import fastcore.all as FC
import traitlets as T
from fasthtml.xtend import Style
from IPython.display import display
from olio.basic import bundle_path
from olio.basic import empty
from olio.common import shorten


# %% ../nbs/11_logger.ipynb
from .bridge_widget import BridgeWidget
from .bridge_widget import bundled
from .helpers import displaydh
from .helpers import HTML
from .helpers import id_gen


# %% ../nbs/11_logger.ipynb
new_id = id_gen()
BUNDLE_PATH = bundle_path(__name__)

# %% ../nbs/11_logger.ipynb
_n = '\n'

# %% ../nbs/11_logger.ipynb
class Canvas:
    def show(self, content=None, **kwargs):...
    def hide(self):...
    def add(self, content, **kwargs):...
    def clear(self, history:bool=True):...

# %% ../nbs/11_logger.ipynb
class DhCanvas(Canvas):
    _stl = 'border: 0.5px solid lightblue; overflow: auto;'
    def __init__(self, height:int=200):
        self.height, self._h, self._dh =  height, '', None
    @property
    def dh(self):
        if not self._dh: self._dh = displaydh()
        return self._dh
    def show(self, content=None, **kwargs):
        if self._dh: self.hide(); self._dh = None
        self.add(content or '', **kwargs)
    def hide(self): self.dh.update(HTML(''))
    def add(self, content, **kwargs):
        if content is not None:
            self._h = str(content) + self._h
            self.dh.update(HTML(f"<div style='max-height:{self.height}px;{self._stl}'>{self._h}</div>"), metadata=kwargs)
    def clear(self): self._h = ''; self.hide()

# %% ../nbs/11_logger.ipynb
FCanvas_css = '''
  @scope (.brd-logger) {
    :scope { 
      border: 1px solid steelblue; 
      overflow: auto; 
      font-family: monospace; 
      font-size: 13px; 
    }
    .ts { color:lightgray; }
  }
'''
FCanvas_stl = Style(FCanvas_css, id='brd-logger-stl')

# %% ../nbs/11_logger.ipynb
fcanvas_js = BUNDLE_PATH / 'js/fcanvas.js'
fcanvas_esm = bundled(fcanvas_js)()

# %% ../nbs/11_logger.ipynb
class FCanvas(BridgeWidget, Canvas):
    # _esm = anysource(fcanvas_esm, '''
    _esm = '''
const { FCanvas } = await brdimport('./fcanvas.js');
export default { initialize({ model }) {
  let fcanvas = new FCanvas(model);
  model.set('_loaded', true); model.save_changes();
  return () => { fcanvas.model = null; fcanvas = null; console.log('Canvas cleanup!'); }
}}
'''
    _css = FCanvas_css

    height = T.Int(200).tag(sync=True)
    elid = T.Unicode('').tag(sync=True)
    _displayed = T.Bool(False).tag(sync=True)
    
    def __init__(self, height:int=200, elid:str='', **kwargs):
        if elid: display(self.tmpl(elid, height or self.height))
        super().__init__(height=height, elid=elid, **kwargs)

    @classmethod
    def new_elid(cls): return new_id('brd-logger')

    @classmethod
    def tmpl(cls, elid, height, content=''):
        return HTML(
            f"<div id='{elid}' class='brd-logger' "
            f"style='width: 100%; max-height: {height}px;'>{content}</div>")
    
    def displayed(self): return self._displayed
    def show(self, content=None, **kwargs):
        self.elid = elid = self.new_elid()
        display(self.tmpl(elid, self.height))
        res = self.send({'cmd': 'show', 'content': elid}, timeout=2)
        if res[0] != empty:  # type: ignore
            self._displayed = True
            if content is not None: self.add(content, **kwargs)
    def hide(self): self.send({'cmd': 'hide'})
    def add(self, content, **kwargs): self.send({ 'cmd': 'update', 'content':str(content), 'kw':kwargs})
    def clear(self): self.send({'cmd': 'clear'})
    
    def close(self, msg:str|None=None):
        if self.comm is not None:
            self.add('FCanvas Closed.<br>')
            self.send = self.show = FC.noop  # type: ignore
            super().close()

# %% ../nbs/11_logger.ipynb
_l2l = {'log':'INFO', 'error': 'ERROR', 'warn': 'WARN'}

class NBLogger:
    @property
    def canvas(self) -> Canvas:...
    def close_canvas(self):...
    def show(self, msg=None, clear:bool=False, **kwargs):...
    def msg(self, msg, clear:bool=False, **kwargs):...
    def clear_log(self):...
    def active(self, flag:bool|None=None, msg=None):...
    
    # hate stupid wiggly reds
    if typing.TYPE_CHECKING:
        def log(self, msg, clear:bool=False, **kwargs): ...
        def error(self, msg, clear:bool=False, **kwargs): ...
        def warn(self, msg, clear:bool=False, **kwargs): ...

    def __init_subclass__(cls) -> None:
        for n,l in _l2l.items(): setattr(cls, n, partialmethod(cls.msg, level=l))

class NoopLogger(NBLogger):
    def __getattr__(self, name:str): return FC.noop

# %% ../nbs/11_logger.ipynb
class BasicLogger(NBLogger):
    fmt, format, max_len = str, True, 140
    def __init__(self, msg=None, canvas:Canvas|None=None, height:int=200, show:bool=True, history:bool=True, **kwargs):
        self._canvas, self._active, self.height, self._closed = canvas, False, height, False
        self._msgs = deque(maxlen=30) if history else None
        if canvas : self.active(True)
        elif show: self.show()
        if msg: self.msg(msg, **kwargs)
    
    @property
    def canvas(self): return self._canvas
    def _setup_canvas(self, height:int): self._canvas = DhCanvas(height=height)
    def close_canvas(self):
        self.active(False)
        if self._canvas and hasattr(self._canvas, 'close'): self._canvas.close()  # type: ignore
        setattr(self, '_canvas', None); self._closed = True

    def show(self, msg=None, clear:bool=False, **kwargs):
        if self._closed: print('This logger is closed.'); return
        if self.active() and self.canvas:
            self.canvas.hide()
            if clear: self.clear_log()
        if self.canvas is None: self._setup_canvas(self.height)
        if self.canvas:
            self.canvas.show()
            self.active(True, msg)
    def _format(self, msg, fmt: Callable[[str], str]|str|None=None, truncate:bool=True, sep:str='<br>') -> str:
        fmt = fmt or self.fmt
        if self.max_len and truncate: s=shorten(msg, mode='r', limit=self.max_len)
        if isinstance(fmt, str): return fmt.format(s=s)
        return f"{fmt(s)}{sep}"
    def msg(self, msg, clear:bool=False, format:bool|None=True, 
            fmt: Callable[[str], str]|str|None=None, truncate:bool=True, sep:str='<br>', **kwargs):
        if not self.active(): return
        if clear: self.clear_log()
        if not msg: return
        format =  format if format is not None else self.format
        self.canvas.add(self._format(msg, fmt, truncate, sep) if format else msg, **kwargs)  # type: ignore
        if self._msgs is not None: self._msgs.append(msg)
    def clear_log(self):
        if self.canvas: self.canvas.clear()
        if self._msgs is not None: self._msgs.clear()
    def active(self, flag: bool|None=None, msg=None):
        if self.canvas is None: return False
        if flag is not None:
            if not flag and self._active: self.msg(msg)
            self._active = flag
            if flag: self.msg(msg)
        return self._active
    
    def history(self) -> tuple: return tuple(self._msgs or ())

# %% ../nbs/11_logger.ipynb
class FLogger(BasicLogger):
    canvas: FCanvas
    def _setup_canvas(self, height:int): self._canvas = FCanvas.create(height=height, timeout=2)

# %% ../nbs/11_logger.ipynb
level_colors = {
    "DEBUG": "#666666",    # gray
    "INFO": "#000000",     # black
    "SUCCESS": "#007700",  # green
    "WARNING": "#ff8800",  # orange
    "ERROR": "#ff0000",    # red
    "CRITICAL": "#880000", # dark red
}

# %% ../nbs/11_logger.ipynb
@FC.patch
def setup_loguru_sink(self: BasicLogger, logger):
    def sink(message:str) -> None:
        rec = getattr(message, 'record', None) or json.loads(message)
        formatted_msg = (
            f"<div style='display: flex; gap: 8px'>"
            f"<span style='color: #888'>{rec['time'].strftime('%H:%M:%S.%f')}</span>"
            f"<span style='width: 4em; color: {level_colors[rec['level'].name]}'>{rec['level'].name.lower():8}</span>"
            # f"<span>{rec['level'].icon}</span>"
            f"<span>{shorten(rec['message'], mode='r', limit=self.max_len or 140)}</span>"
            f"</div>"
        )
        self.msg(formatted_msg, format=False)
    
    logger.remove()
    logger.add(
        sink, 
        # format="<span style='color: {level.color}'>{message}</span>",
        # colorize=True
        # serialize=True
    )
    return sink
