"""Pure IPython facilities to help us inspect, control, and modify cell outputs."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/15_nb_hooks.ipynb.

# %% ../nbs/15_nb_hooks.ipynb 1
from __future__ import annotations

# %% auto 0
__all__ = ['cellspec_from', 'CellExecInfo', 'get_info', 'get_lastinfo', 'get_csi', 'Bridged', 'get_bridged', 'CaptureTransformer',
           'get_capturer']

# %% ../nbs/15_nb_hooks.ipynb
import ast
import urllib.parse
import uuid
from collections import deque

import fastcore.all as FC
from fastcore.xml import to_xml
from fasthtml.core import unqid
from IPython.core.error import InputRejected
from IPython.core.getipython import get_ipython
from IPython.display import display
from IPython.core.display import DisplayHandle
from olio.basic import bundle_path
from olio.basic import val_at as at
from olio.common import AD
from olio.common import update_


# %% ../nbs/15_nb_hooks.ipynb
from .helpers import Brd_Mark
from .helpers import bridge_cfg
from .helpers import DEBUG
from .helpers import id_gen
from .nb import NB
from .nb import NBCell
from .nb import NBOutput


# %% ../nbs/15_nb_hooks.ipynb
BUNDLE_PATH = bundle_path(__name__)
new_id = id_gen()
_n = '\n'

# %% ../nbs/15_nb_hooks.ipynb
def _cellid_from(s): return urllib.parse.unquote(urllib.parse.urlparse(s).fragment)
def _nburi_from(s): return urllib.parse.urlparse(s).netloc + urllib.parse.urlparse(s).path
def cellspec_from(s): return (uri := urllib.parse.urlparse(s)).path, urllib.parse.unquote(uri.fragment)

# %% ../nbs/15_nb_hooks.ipynb
@FC.patch
def update(self:NB, cell_id, source=None, execution_count=None, outputs=None):
    if not (cell := self[cell_id]): 
        cell = NBCell(dict(idx=len(self.cells), source=source, id=cell_id, cell_type='code'))
        self._apply_diff({"added": [cell], "cellCount": len(self.cells)+1})
    else: 
        update_(cell, source=source, execution_count=execution_count, outputs=outputs)
        self._rebuild()

# %% ../nbs/15_nb_hooks.ipynb
shell = get_ipython()
assert shell is not None

def _get_outputs(exec_result):
    outputs = []
    if exec_result and exec_result.result is not None:
        format_dict, md_dict = shell.display_formatter.format(exec_result.result)  # type: ignore
        if format_dict: outputs.append(NBOutput(dict(
            output_type='execute_result',
            execution_count=exec_result.execution_count,
            data=format_dict,
            metadata=md_dict,
        )))
    return outputs

# %% ../nbs/15_nb_hooks.ipynb
class CellExecInfo:
    def __init__(self, start=False): 
        self._evts, self._ns = get_ipython().events, get_ipython().user_ns  # type: ignore
        # self._active, self._nb, self._invscode = False, self._ns['__nb__'], '__vsc_ipynb_file__' in self._ns
        self._active, self._invscode = False, '__vsc_ipynb_file__' in self._ns
        if start: self.start()
    @property
    def active(self): return self._active
    def start(self):
        if not self._active: 
            self._evts.register('pre_run_cell', self.pre_run_cell)
            self._ns.update(__cellinfo__=AD(), __lastcellinfo__=None)
    def stop(self):
        if self._active:
            self._active = False
            self._evts.unregister('pre_run_cell', self.pre_run_cell)
            self._evts.unregister('post_run_cell', self.post_run_cell)
            self._ns['__cellinfo__'] = None
            self._ns['__lastcellinfo__'] = None
    def __del__(self): self.stop()

    def _getid(self, info):
        if not (id := info.cell_id): return unqid()
        return _cellid_from(id) if self._invscode else id
    def pre_run_cell(self, info): 
        if not self._active: 
            self._evts.register('post_run_cell', self.post_run_cell)
            self._active = True
        try:
            if not info.store_history: return  # debugpy usually
            self._ns['__lastcellinfo__'] = self._ns['__cellinfo__']
            self._ns['__cellinfo__'] = info =AD(source=info.raw_cell, cell_id=self._getid(info), 
                                                exec_result=AD(result=None))
            _update_cell(info.cell_id, source=info.source)
        except Exception as e:
            print(e)
    def post_run_cell(self, result):
        if not (self._active and result.info.store_history): return
        try:
            if info := self._ns['__cellinfo__']:
                info.exec_result.update(
                    execution_count=result.execution_count,
                    error_before_exec=result.error_before_exec,
                    error_in_exec=result.error_in_exec,
                )
                # info.exec_result.result may have been updated elsewhere (capture...), so don't overwrite it
                if result.result is not None and info.exec_result.result is None:
                    info.exec_result.result = result.result
                _update_cell(info.cell_id, exec_result=result)
        except Exception as e:
            print(e)


def get_info() -> AD: return get_ipython().user_ns['__cellinfo__']  # type: ignore
def get_lastinfo() -> AD: return get_ipython().user_ns['__lastcellinfo__']  # type: ignore

__csi__ = None
def get_csi(start=False):
    global __csi__
    if __csi__ is None: __csi__ = CellExecInfo()
    if start: __csi__.start()
    return __csi__

# %% ../nbs/15_nb_hooks.ipynb
def _update_cell(cell_id, source=None, exec_result=None, display_cnt=None, output_did=None):
    if source is not None:  # only with run cell, reset outputs
        __nb__.update(cell_id, source=source, execution_count=None, outputs=[])  # type: ignore
    if cell := __nb__[cell_id]:
        upd = {'outputs': cell.get('outputs', [])}
        if display_cnt is not None:
            data, metadata, did = display_cnt['data'], display_cnt['metadata'], at(display_cnt, 'transient.display_id', None)
            kw = {'data': data, 'metadata': metadata.copy()}
            if did: kw['metadata']['brd_did'] = did
            if output_did and (output := FC.last(upd['outputs'], lambda o: o.did == output_did)):
                output.data.update(**kw['data']); output.metadata.update(**kw['metadata'])
            else: upd['outputs'].append(NBOutput(dict(output_type='display_data', **kw)))
        if exec_result is not None:
            upd['execution_count'] = exec_result.execution_count
            upd['outputs'].extend(_get_outputs(exec_result))
        __nb__.update(cell_id, **upd)  # type: ignore

# %% ../nbs/15_nb_hooks.ipynb
class Bridged:
    "Augment display messages with bridge stuff."
    def __init__(self, start=False):
        self._active, self._ns = False, get_ipython().user_ns  # type: ignore
        if start: self.start()
        else: self._reset()
    @property
    def active(self): return self._active
    def _reset(self):
        self.dhs = deque(maxlen=100)
        if DEBUG(): self.msgs = []
    def start(self):
        if not self._active:
            self._active = True
            get_ipython().display_pub.register_hook(self.bridged)  # type: ignore
        self._reset()
    def stop(self):
        if self._active: 
            self._active = False
            get_ipython().display_pub.unregister_hook(self.bridged)  # type: ignore
    def __del__(self): self.stop()
    
    @property
    def dh(self): return self.dhs[-1] if self.dhs else None
    def bridged(self, msg):
        if not self._active: return msg
        if DEBUG(): self.msgs.append(msg)
        if (msg_type := msg['msg_type']) not in ('display_data', 'update_display_data'): return msg
        content, did = msg['content'], None
        d, md = content['data'], content['metadata']
        # if brd_md := md.get('bridge'):
        #     if brd_md.get('skip'): return msg
        #     # captured = brd_md.get('captured', False)
        skip = at(md, 'bridge.skip', False)
        if _BRDD_MIMES & d.keys() and not skip: 
            if trn := content['transient']: did = trn['display_id']
            elif md: 
                for k,v in md.items():
                    if v.get('skip'): skip=True; break
                    if brd_id := v.get('brd_did'):  # hoist `brd_did` one level
                        md['brd_did'] = did = brd_id
                        del v['brd_did']
                        if not v: del md[k]
                        break
            if not did and bridge_cfg.auto_id and not skip: did = new_id()
            if did: 
                if 'display_id' not in trn: trn['display_id'] = did
                if not self.dhs or (did != self.dhs[-1].display_id): self.dhs.append(DisplayHandle(display_id=did))
                # add brd-mark to HTML output
                if 'text/html' in d: d['text/html'] += _n + to_xml(Brd_Mark(id=did))
        if info := self._ns.get('__cellinfo__'):
            if msg_type == 'display_data':
                _update_cell(info.cell_id, display_cnt=content)
            else:  # update_display_data
                if did and (cell := __nb__.cell_by_did(did)):  # type: ignore
                    _update_cell(cell.id, display_cnt=content, output_did=did)
        return msg


_BRDD_MIMES = {'text/html', 'text/markdown', 'application/json', 'application/javascript', 'text/plain'}


__bridged__ = None
def get_bridged(start=False):
    global __bridged__
    get_csi(True)
    if __bridged__ is None : __bridged__ = Bridged()
    if start: __bridged__.start()
    return __bridged__    

# %% ../nbs/15_nb_hooks.ipynb
class CaptureTransformer(ast.NodeTransformer):
    def __init__(self, mode='direct'):
        self.mode, self._active, self._temp_var_prefix = mode, False, f"_ast_cap_{uuid.uuid4().hex[:8]}_"
        self._global_function_name = '_ast_process_result'
        self._transform = self._transform_expr_direct if mode == 'direct' else self._transform_expr_conditional

    @property
    def active(self): return self._active
    __is_transformer__ = True
    def start(self):
        if not (shell := get_ipython()) or self._active: return
        self._active = True
        shell.ast_transformers = [t for t in shell.ast_transformers if not getattr(t, '__is_transformer__', False)]
        shell.ast_transformers.append(self)
        shell.user_ns[self._global_function_name] = _ast_process_result
    def stop(self):
        if not (shell := get_ipython()) or not self._active: return
        self._active = False
        shell.ast_transformers = [t for t in shell.ast_transformers if not getattr(t, '__is_transformer__', False)]
    def __del__(self): self.stop()

    def visit_Module(self, node: ast.Module):
        node = self.generic_visit(node)  # type: ignore
        if not node.body or not isinstance(node.body[-1], ast.Expr): return node
        last_stmt = node.body[-1]
        expr = last_stmt.value
        if self._should_reject_input(expr): raise InputRejected(f"Cannot transform {type(expr).__name__} expressions")
        # if self.mode == 'direct': self._transform_expr_direct(node, expr)
        # else: self._transform_expr_conditional(node, expr)
        self._transform(node, expr)
        ast.fix_missing_locations(node)
        return node
    def _transform_expr_direct(self, node: ast.Module, expr: ast.expr):
        call_node = ast.Call(func=ast.Name(id=self._global_function_name, ctx=ast.Load()), args=[expr],keywords=[])
        node.body[-1] = ast.Expr(value=call_node)
    def _transform_expr_conditional(self, node: ast.Module, expr: ast.expr):
        temp_var = f"{self._temp_var_prefix}result"
        assign_node = ast.Assign(targets=[ast.Name(id=temp_var, ctx=ast.Store())], value=expr)
        call_result = ast.Call(func=ast.Name(id=self._global_function_name, ctx=ast.Load()),
                                args=[ast.Name(id=temp_var, ctx=ast.Load())],keywords=[])
        node.body[-1] = assign_node
        node.body.append(ast.Expr(value=call_result))
    def _should_reject_input(self, expr):
        unsafe_types = (ast.Yield, ast.YieldFrom, ast.Await)
        return isinstance(expr, unsafe_types)


__capturer__ = None
def get_capturer(start=False):
    global __capturer__
    get_bridged(True)
    if __capturer__ is None: __capturer__ = CaptureTransformer(mode='direct')
    if start: __capturer__.start()
    return __capturer__

# %% ../nbs/15_nb_hooks.ipynb
def _ast_process_result(result):
    if result is not None:
        if not (shell := get_ipython()): return result
        info = shell.user_ns['__cellinfo__']
        if result is not info: info.exec_result.result = result
        # this is only called during cell execution; displayhook should be the custom one, not sys.displayhook
        displayhook = shell.displayhook  # type: ignore
        if not displayhook.quiet():
            if not getattr(result, '_ipython_display_', None):
                display(result, metadata={'bridge': {'captured': True}})
            displayhook.update_user_ns(result)
            displayhook.fill_exec_result(result)

# %% ../nbs/15_nb_hooks.ipynb
def stop_hooks():
    get_csi().stop()
    get_bridged().stop()
    get_capturer().stop()

# %% ../nbs/15_nb_hooks.ipynb
def get_nb_from_hooks() -> NB:
    get_csi(True)
    get_bridged(True)
    get_capturer(True)
    return __nb__

# %% ../nbs/15_nb_hooks.ipynb
__nb__ = NB()
if shell := get_ipython():
    if '__nb__' not in shell.user_ns: shell.user_ns['__nb__'] = __nb__
    shell.user_ns['__cellinfo__'] = None
    shell.user_ns['__lastcellinfo__'] = None
    if dformatter := shell.display_formatter:
        _BRDD_MIMES = set(dformatter.format_types)# - {'text/plain'}  # type: ignore

if bridge_cfg.bootstrap: get_nb_from_hooks()
