"""Enables method-based routing in fasthtml by extending `APIRouter` capabilities."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_route_provider.ipynb.

# %% ../nbs/04_route_provider.ipynb 1
from __future__ import annotations

# %% auto 0
__all__ = ['ar', 'RouteProviderP', 'RouteProvider', 'APIRouterD', 'APIRoute', 'add_routes', 'mount']

# %% ../nbs/04_route_provider.ipynb
import functools
from contextlib import contextmanager
from functools import update_wrapper
from types import FunctionType
from types import MethodType
from typing import Any
from typing import Callable
from typing import NamedTuple
from typing import overload
from typing import Protocol
from typing import Sequence

import fastcore.all as FC
import fasthtml.core
from fasthtml.core import all_meths
from fasthtml.core import APIRouter
from fasthtml.core import FastHTML
from fasthtml.core import noop_body


# %% ../nbs/04_route_provider.ipynb
from .helpers import id_gen
from .helpers import nb_app

# %% ../nbs/04_route_provider.ipynb
new_id = id_gen()

# %% ../nbs/04_route_provider.ipynb
@contextmanager
def _patched(o, nm, f):
    original = getattr(o, nm)    
    setattr(o, nm, update_wrapper(f, original))
    try: yield
    finally: setattr(o, nm, original)

# %% ../nbs/04_route_provider.ipynb
_AR_MARK = '__routes__'

class RouteProviderP(Protocol): 
    __routes__: Sequence  # of (func, path, methods, name, include_in_schema, body_wrap) like `APIRouter`'s routes attr.
    ar: APIRouter

class RouteProvider:  # noop class, only to alliviate the stupid wiggly reds
    __routes__: Sequence
    ar: APIRouter

# %% ../nbs/04_route_provider.ipynb
def _replace(s, sep:str|None='.', rep:str|None='_'):
    return s.strip(sep).replace(sep, rep)

# %% ../nbs/04_route_provider.ipynb
def _fn(f):
    return f.fget.__name__ if isinstance(f, property) else f.__name__  # type: ignore

def _path(path):
    if isinstance(path, str): return path
    if isinstance(path, property): return f"/{getattr(path.fget, '__name__')}"
    if callable(path) or isinstance(path, classmethod): return f"/{path.__name__}"
    raise TypeError(f"Invalid path type: {type(path)}")

_prop2mth = list(zip(('fget', 'fset', 'fdel'), (['GET'], ['POST', 'PUT'], ['DELETE'])))

def _bound(func, o):
    if isinstance(func, FunctionType): return MethodType(func, o)
    if isinstance(func, (staticmethod, classmethod)): return getattr(o, func.__name__)
    if isinstance(func, classmethod): return getattr(type(o), 'd')
    raise TypeError(f"Invalid function type: {type(func)}")

def _unravel_prop(func, o):
    if isinstance(func, property):
        yield from ((f, m) for fn, m in _prop2mth if (f := getattr(func, fn, None)))
    else: yield func, None
def _reg_mth(ar, func, args, o):
    for mth, m in _unravel_prop(func, o):
        path, methods, *_ = args
        ar(path, methods or m or 'get', *_)(mth)

# %% ../nbs/04_route_provider.ipynb
class MountPoint(NamedTuple):
    "Path and name of a mount point where a group of routes can be added"
    path: str
    name: str
    def mount(self, path, name):
        return type(self)(self.path + path, f"{self.name+(':' if self.name else '')}{name}")

# %% ../nbs/04_route_provider.ipynb
def nested_name(f):
    "Get name of function `f` using '_' to join nested function names"
    return f.__name__


class APIRouterC(APIRouter):
    # __routepath__ = ''  # path of mount
    # __routename__ = ''  # name of mount
    __mount__ = MountPoint('', '')  # to allow nested mounts

    def _wrap_func(self, func, path:str, rname=None):
        name = func.__name__
        wrapped = fasthtml.core._mk_locfunc(func, self.__mount__.path + path)  # <--- diff from APIRouter
        wrapped.__routename__ = rname or name
        # If you are using the def get or def post method names, this approach is not supported
        if name not in all_meths: setattr(self.rt_funcs, name, wrapped)
        if rname and rname != name: setattr(self.rt_funcs, rname, wrapped)  # <--- diff from APIRouter
        return wrapped

    # Don't like monkey-patching `core`, let's see if transient patching suffices
    def to_app(self, app):
        "Add routes to `app`"
        with _patched(fasthtml.core, 'nested_name', nested_name):
            for args in self.routes:
                f, p, methods, name, include_in_schema, body_wrap = args
                p = self.prefix + p
                wrapped = app._add_route(f, p, methods, name, include_in_schema, body_wrap or self.body_wrap)
                self._wrap_func(f, p, wrapped.__routename__)
            for args in self.wss: app._add_ws(*args)
        self.prefix = self.__mount__.path + self.prefix

    def to(self, fn=None, /, **kw) -> str: 
        if fn is None: return self.prefix
        if wrp := getattr(self.rt_funcs, fn, None): return f"{wrp.to(**kw)}"
        raise NameError(f"Endpoint {fn} not found.")

    def name(self, fn=None) -> str:
        rn = self.__mount__.name#getattr(self, '__routename__', '')
        if fn is None: return rn
        if not (wrp := getattr(self.rt_funcs, fn, None)): raise NameError(f"Endpoint {fn} not found.")
        return f"{rn+(':' if rn else '')}{wrp.__routename__}"

# %% ../nbs/04_route_provider.ipynb
def _gather_routes(rtargs:dict, owner:type):
    routes, fns = [], dict()
    for f, args in rtargs.items(): 
        for mth, m in _unravel_prop(f, owner):
            path, methods, *rest = args
            routes.append(r := (mth, path, methods or m or 'get', *rest))
            fns[mth.__name__] = r
    for base in owner.mro()[1:-1]: 
        if rr := getattr(base, _AR_MARK, None):
            # routes.extend(_ for _ in rr if _ not in routes)
            for r in rr:
                f, p, m, *rest = r
                if f.__name__ not in fns:
                    routes.append(r)
                    fns[f.__name__] = r
                else: # check methods
                    if fns[f.__name__][2] != m:
                        routes.append(r)
            # routes.extend(_ for _ in rr if _ not in routes)
    return routes


class APIRouterD(APIRouterC):
    def __init__(self, *args, **kwargs):
        self._rtargs, self._name, self.routes = {}, None, []
        super().__init__(*args, **kwargs)
    
    # docs and trying to avoid hateful wiggly reds...
    @overload
    def __call__(self, *args, **kwargs) -> Callable: ...
    @overload
    def __call__(self, path:FunctionType, *args, **kwargs) -> Callable: ...
    @overload
    def __call__(self, path:classmethod, *args, **kwargs) -> classmethod: ...
    @overload
    def __call__(self, path:property, *args, **kwargs) -> property: ...
    @overload
    def __call__(self, path:str, *args, **kwargs) -> Callable: ...
    def __call__(self, path:Any=None, methods=None, name=None, 
                        include_in_schema=True, body_wrap=noop_body):
        "Collect precursors of routes."
        def f(func):
            p = _path(path)
            self._rtargs[func] = '/' if p == '/index' else p, methods, name, include_in_schema, body_wrap
            return func  # let methods be methods
        return f if path is None or isinstance(path, str) else f(path)

    def __set_name__(self, owner, name): 
        assert not self._name, f"APIRouterD already named {self._name}."
        self._name = name
        self.routes = _gather_routes(self._rtargs, owner)
        setattr(owner, _AR_MARK, self.routes)  # mark class as routes provider

    def __get__(self, instance, owner):
        if not self._name: # shouldn't happen
            raise AttributeError(f"APIRouterD {self._name} not bound to {owner}")
        if not instance: return self
        ar = APIRouterC(self.prefix, self.body_wrap)  # final APIRouter used by this instance
        # final routes w/ bounded endpoint will be setup by APIRouterC.to_app(...).
        # Here just bind routes to instance.
        ar.routes = [(_bound(func, instance), *args) for func, *args in self.routes]  # type: ignore
        setattr(instance, self._name, ar)  # instance doesn't need the descriptor any more
        return ar


    def to_app(self, app): raise TypeError("APIRouterD can't add routes to an app")

    def _rts(self, fn): return list(filter(lambda x: x[0].__name__==fn, self.routes))
    
    def to(self, fn=None, /, **kw) -> str: 
        if fn is None: return self.prefix
        if not (rr := self._rts(fn)): raise NameError(f"Endpoint {fn} not found.")
        return fasthtml.core.qp(f"{self.prefix}{rr[0][1]}", **kw)  # type: ignore

    def name(self, fn=None) -> str:
        rn = getattr(self, '__routename__', '')
        if fn is None: return rn
        if not (rr := self._rts(fn)): raise NameError(f"Endpoint {fn} not found.")
        return f"{(nm:=rn)+(':' if nm else '')}{nested_name(rr[0][0])}"

    # hate stupid wiggly reds
    post: Callable; get: Callable; put: Callable; delete: Callable; patch: Callable; head: Callable; options: Callable;


for o in all_meths: setattr(APIRouterD, o, functools.partialmethod(APIRouterD.__call__, methods=o))

# %% ../nbs/04_route_provider.ipynb
class _APIRouterD(APIRouterD):
    def __set_name__(self, owner, name): raise AttributeError(f"_APIRouterD should not be used explicitly.")
    def __get__(self, instance, owner):
        if not instance: return self
        for base in reversed(owner.mro()[1:-1]):
            if hasattr(base, _AR_MARK):
                _ar = getattr(base, 'ar', None)
                if _ar and not _ar._name: super(_APIRouterD, _ar).__set_name__(base, 'ar')  # type: ignore
        if not self._name: super().__set_name__(owner, 'ar')    
        return super().__get__(instance, owner)


class APIRoute:
    _attr_name = 'ar'

    def __init__(self, path=None, methods=None, name=None, include_in_schema=True, body_wrap=noop_body):
        if path and not isinstance(path, str): self.func, path = path, _path(path)
        self._rtargs = '/' if path == '/index' else path, methods, name, include_in_schema, body_wrap

    def __call__(self, func) -> Callable:  self.func = func; return self
    def __getattr__(self, name): return getattr(self.func, name)  # getter, setter, deleter
    
    def __set_name__(self, owner, name):
        if not self._attr_name in vars(owner):
            setattr(owner, self._attr_name, ar := _APIRouterD())
            setattr(owner, _AR_MARK, ar._rtargs)
        getattr(owner, _AR_MARK)[self.func] = self._rtargs  # collect rt args
        setattr(owner, name, self.func)  # let methods be methods; wipe out myself

    # hate stupid wiggly reds
    post: Callable; get: Callable; put: Callable; delete: Callable; patch: Callable; head: Callable; options: Callable;

for o in all_meths: setattr(APIRoute, o, functools.partialmethod(APIRoute, methods=o))

# %% ../nbs/04_route_provider.ipynb
def _ar(o):
    if v := getattr(o, 'ar', None): return v
    # search the type; if `ar` is a descriptor, could not be valued yet.
    t = type(o)
    k = FC.first(vars(t), lambda x: isinstance(getattr(t, x), APIRouterD)) or ''
    return getattr(o, k, None)

def add_routes(self: FastHTML,  # we could patch FastHTML, but that´s a big deal better served by PRs
        prov:APIRouter|RouteProviderP|Any,  # APIRouterC or RouteProvider
        mount:bool=False,       # mount routes under `path`; if false will add routes under APIRouter prefix
        path:str|None=None,     # if `mount`, submount path (or auto-generated based on `prov` class)
        name:str|None=None,     # if `mount`, name for submount (or auto-generated based on path)
        appcls:Callable=nb_app  # use FastHTML factory for submounts
    ) -> APIRouter:
    "Register provider routes"
    if path == '': path = None
    # ar = prov if isinstance(prov, APIRouter) else prov.ar  # TODO: search for the class attribute actually used
    ar = prov if isinstance(prov, APIRouter) else _ar(prov)  # TODO: search for the class attribute actually used
    if not ar: return#raise ValueError(f"No APIRouter found in {prov}")  # type: ignore
    if not len(ar.routes): return ar
    if not isinstance(ar, APIRouterC):
        # As APIRouter has already backed its routes, we can´t do anything more here.
        return add_routes(self, ar, False)
    # It's unclear how to handle APIRouterC prefix + path; skip altogether for now (got to think more about that)
    if not mount:  # CASE 1: mount=False, path=None
        if path is None:
            ar.to_app(self)
            return ar
        else:  # CASE 2: mount=False, path=...
            self.router.routes = [
                # r for r in self.router.routes if not (r.path==path and r.name == name)]  # type: ignore
                r for r in self.router.routes if not r.path==path]  # type: ignore
            if not name:# and ar.__mount__.name:
                name = _replace(path, '/')
            self.mount(path, app := appcls(), name=name)
            ar.prefix = ''
            ar.__mount__ = ar.__mount__.mount(path, name)
            path, name = None, None
    else:
        if ar is prov:
            app = self # ????
        else:
            cls_nn = f"{nested_name(type(prov))}"
            ar.__mount__ = MountPoint(f"/{cls_nn}", cls_nn)  # type: ignore
            if mnt := FC.first(self.routes, lambda x: x.name==cls_nn): app = mnt.app
            else: self.mount(ar.__mount__.path, app := appcls(), name=cls_nn)
            if path is None:  # CASE 3: mount = True, path=None => auto mount under /<class name>/<instance name>/...
                arn = new_id(prov)
                path = f"/{arn}"
                if not name: name = arn
            else:  # CASE 4: mount = True, path=...
                if path == '' or path == '/': path = None
    return add_routes(app, ar, False, path, name, appcls)


def mount(app: FastHTML, prov:APIRouter|RouteProviderP, path:str|None=None, name:str|None=None):
    return add_routes(app, prov, True, path, name)

# %% ../nbs/04_route_provider.ipynb
ar = APIRoute
