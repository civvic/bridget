"""..."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_widget_helpers.ipynb.

# %% ../nbs/02_widget_helpers.ipynb 1
from __future__ import annotations

# %% auto 0
__all__ = ['read_vfile', 'ScriptV', 'StyleV', 'SourceProvider', 'anysource', 'Bundle', 'bundled', 'exp_backoff', 'BlockingMixin']

# %% ../nbs/02_widget_helpers.ipynb
import asyncio
import shutil
import time
from functools import cached_property
from pathlib import Path
from typing import Any
from typing import Callable
from typing import Protocol
from typing import Self

import fastcore.all as FC
import ipywidgets as W
import nbdev.config
from fastcore.xml import FT
from fastcore.xml import NotStr
from fasthtml.basics import ft_html
from jupyter_ui_poll import ui_events
from olio.basic import _get_globals
from olio.basic import Empty
from olio.basic import empty


# %% ../nbs/02_widget_helpers.ipynb
from .helpers import run_command


# %% ../nbs/02_widget_helpers.ipynb
_n = '\n'

# %% ../nbs/02_widget_helpers.ipynb
def read_vfile(cts:str)->str|None:
    # %load_ext anywidget should have been previously run for this to work
    import anywidget
    from anywidget._file_contents import _VIRTUAL_FILES
    if isinstance(cts, str) and cts.startswith('vfile:'):
        if fn := _VIRTUAL_FILES.get(cts, None):
            return fn.contents

# %% ../nbs/02_widget_helpers.ipynb
@FC.delegates(ft_html, keep=True)  # type: ignore
def ScriptV(code:str="", **kwargs)-> FT:
    "A Script w/ code or `vfile:` contents that doesn't escape its code"
    return ft_html('script', (_n, NotStr(FC.ifnone(read_vfile(code), code))), **kwargs)

@FC.delegates(ft_html, keep=True)  # type: ignore
def StyleV(*c, **kwargs)-> FT:
    "A Style w/ code or `vfile:` contents that doesn't escape its code"
    return ft_html('style', tuple(NotStr(FC.ifnone(read_vfile(_), _)) for _ in c), **kwargs)


# %% ../nbs/02_widget_helpers.ipynb
class SourceProvider(Protocol):
    @property
    def source(self) -> str | cached_property[str]: ...

def _source(o: str|Path|SourceProvider) -> str:
    if hasattr(o, 'source'): return o.source  # type: ignore
    return FC.ifnone(read_vfile(o), o if isinstance(o, str) else o.read_text())  # type: ignore

def anysource(*args: str|Path|SourceProvider):
    "Read and join text from files, vfiles or strings"
    return '\n'.join(filter(None, (_source(_) for _ in args)))

# %% ../nbs/02_widget_helpers.ipynb
class Bundle:
    "Basic JS bundler class."
    def __init__(self, 
        *sources: str|Path,         # Concat javascript `sources`
        bundle:str|bool=False,      # Bundle using `esbuild` withs sources as entry points
        outdir:str|Path|None=None,  # Output directory for bundled files
        bundler:str='esbuild',      # Bundler to use, one of 'esbuild', 'copy'
        command:str|None=None,      # Run `command` first if not None
        **cmd_kw                    # Command kwargs
    ):
        self.sources, self.bundler = list(sources), bundler;
        self.outdir, self.command, self.cmd_kwargs = outdir, command, cmd_kw
        self.bundle = bundle if isinstance(bundle, bool) else bundle == '__main__'
    def __str__(self): return self.source
    def __call__(self, debugger=False):
        "Insert `debugger` at the beginning of the bundle."
        return self.source if not debugger else anysource('debugger;', self.source)
    @cached_property
    def bundled_sources(self) -> list[str|Path]:
        "Bundle the sources using `esbuild`. Return the paths to the bundled files."
        if self.command: _ = run_command(self.command, **self.cmd_kwargs)
        if not self.bundle: return self.sources
        nbdev_cfg = nbdev.config.get_config()
        outdir = nbdev_cfg.lib_path/'js' if not self.outdir else Path(self.outdir)
        if self.bundler == 'copy':
            srcs = [shutil.copy(_, outdir) for _ in self.sources if isinstance(_, Path)]
        else:
            srcs = ' '.join([_.resolve().as_posix() for _ in self.sources if isinstance(_, Path)])
            cmd = f"./node_modules/.bin/esbuild --bundle --format=esm --outdir={outdir} {srcs}"
            _ = run_command(cmd, cwd=nbdev_cfg.config_path)
        return [(outdir / _.name if isinstance(_, Path) else _) for _ in self.sources]
    @cached_property
    def source(self): return anysource(*self.bundled_sources)
    def join(self, *sources: str|Path):
        return type(self)(*self.sources, *sources, bundle=self.bundle, outdir=self.outdir, 
            bundler=self.bundler, command=self.command, **self.cmd_kwargs)


@FC.delegates(Bundle.__init__, keep=True)  # type: ignore
def bundled(*sources: str|Path, **kwargs):
    return Bundle(*sources, **kwargs)

# %% ../nbs/02_widget_helpers.ipynb
def exp_backoff(base:float=1.552, max_value:float=20.0):
    "Exponential backoff generator of values until cumulative value is max_value, then yields 0 and stops."
    if base <= 0: yield 0; return
    i, cum_sum, prev_t = 1, 0, 0
    while cum_sum < max_value:
        t = max(base**i, prev_t) if base > 1 else base*i
        t = min(t, max_value - cum_sum)
        yield t
        cum_sum += t
        prev_t = t
        i += 1
    yield 0

# %% ../nbs/02_widget_helpers.ipynb
_xx = ['-_-', 'o_o']
def _show(finish: bool=False):
    if finish: print('._.')
    else: print(_xx[0], end="\r", flush=True); _xx[:] = _xx[::-1]

# %% ../nbs/02_widget_helpers.ipynb
class BlockingMixin(W.Widget):
    "Mixin for widgets that supports blocking custom messages with the front-end."
    _loading = True

    @classmethod
    async def create(cls, 
        *args, 
        sleep:float=0.2, timeout:float=4.0,
        factory:Callable[..., Any]|None=None, on_end:Callable[[Any, bool], None]|None=None,
        **kwargs
    ) -> Self:
        start_time = time.time()
        self: Self = (factory or cls)(*args, **kwargs)
        if self._loading:
            async with ui_events() as ui_poll:
                while True:
                    await ui_poll(10)
                    if (time.time() - start_time) > timeout:
                        if on_end: on_end(self, False)
                        break
                    if not self._loading:
                        if on_end: on_end(self, True)
                        break
                    if sleep: await asyncio.sleep(sleep)
        return self

    def send(self, msg, timeout: float|None=None, buffers=None, 
            sleep: float = 1/15, n: int = 10, show: Callable[[bool], None]|None = None
    ) -> tuple[Any|Empty, Any|Empty]|None:
        """Send `msg` to the front-end. If `timeout` seconds is not None, the calling blocks.
        NOTE: front-end can yet send back a result even if python timeout was triggered.
        """
        if timeout is None: return super().send(msg, buffers)
        return self._send_msg(msg, buffers, timeout, sleep, n, show)
    
    async def asend(self, msg, timeout: float=5.0, buffers=None, 
            sleep: float = 1/15, n: int = 10, show: Callable[[bool], None]|None = None
    ) -> tuple[Any|Empty, Any|Empty]|None:
        """Send `msg` to the front-end. Call will end after `timeout` seconds if `timeout` is not None.
        NOTE: front-end can yet send back a result even if python timeout was triggered.
        """
        return await self._asend_msg(msg, buffers, timeout, sleep, n, show)

    def _send_msg(self, msg, buffers=None, timeout: float = 5.0, 
            sleep: float = 1/15, n: int = 10, show: Callable[[bool], None]|None = None
    ) -> tuple[Any|Empty, Any|Empty]:
        "Send blocking `msg` to the front-end. Return response tuple (content, buffers), or (empty, empty) if `timeout`."
        boff = iter(exp_backoff(timeout*0.776, timeout))
        timeout, start_time = next(boff), time.time()
        result = None
        def _on_msg(w, msg, buffers):
            nonlocal result
            if result is None: result = (msg, buffers)
        super().on_msg(_on_msg)
        try:
            super().send(msg, buffers)
            with ui_events() as ui_poll:
                while True:
                    if sleep: time.sleep(sleep)
                    ui_poll(n)
                    if (time.time() - start_time) > timeout:
                        timeout, start_time = next(boff), time.time()
                        if not timeout: result = (empty, empty)
                    if result is not None:
                        content, buffers = result
                        if content is empty: return (empty, empty)
                        return content, buffers
                    if show: show(False)
        except Exception as e:
            if isinstance(e, RuntimeError): raise
            raise RuntimeError(f"Error during message processing: {str(e)}") from e
        finally:
            super().on_msg(_on_msg, True)
            if show: show(True)

    async def _asend_msg(self, msg, buffers=None, timeout: float = 5.0, 
            sleep: float = 0, n: int = 10, show: Callable[[bool], None]|None = None
    ) -> tuple[Any|Empty, Any|Empty]:
        "Send async `msg` to the front-end. Return response tuple (content, buffers), or (empty, empty) if `timeout`."
        boff = iter(exp_backoff(timeout*0.776, timeout))
        timeout = next(boff)
        start_time, result = time.time(), None
        def _on_msg(w, msg, buffers):
            nonlocal result
            if result is None: result = (msg, buffers)
        super().on_msg(_on_msg)
        try:
            super().send(msg, buffers)
            async with ui_events() as ui_poll:
                while True:
                    await ui_poll(10)
                    if (time.time() - start_time) > timeout:
                        timeout = next(boff)
                        if not timeout: result = (empty, empty)
                    if result is not None:
                        content, buffers = result
                        if content is empty: return (empty, empty)
                        return (content, buffers)
                    if sleep: await asyncio.sleep(sleep)
                    if show: show(False)
        except Exception as e:
            if isinstance(e, RuntimeError): raise
            raise RuntimeError(f"Error during message processing: {str(e)}") from e
        finally:
            super().on_msg(_on_msg, True)
            if show: _show(True)
