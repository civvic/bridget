"""..."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_helpers.ipynb.

# %% ../nbs/01_helpers.ipynb 1
from __future__ import annotations

# %% auto 0
__all__ = ['emptyd', 'emptyl', 'emptyt', 'bridge_cfg', 'kounter', 'BridgeCfg', 'arun_command', 'run_command', 'Singleling',
           'Kounter', 'simple_id', 'id_gen', 'patch_cached', 'patch_cached_property', 'cached_property',
           'bridge_metadata', 'skip', 'compose_first']

# %% ../nbs/01_helpers.ipynb
import dataclasses
import functools
import importlib
import os
import sys
from binascii import hexlify
from functools import cache
from functools import partial
from pathlib import Path
from types import ModuleType
from typing import Any
from typing import DefaultDict

import fastcore.all as FC
from olio.common import Config


# %% ../nbs/01_helpers.ipynb
emptyd, emptyl, emptyt = {}, [], ()

# %% ../nbs/01_helpers.ipynb
# @dataclasses.dataclass
class BridgeCfg(Config):
    """
    Settings for core `Bridget` behavior.
    
    if `True`:
    - `auto_show`: FastHTML objects display as HTML instead of markdown.
    - `auto_mount`: components with routes are automatically mounted.
    - `auto_id`: display elements get auto-generated IDs.
    - `bootstrap`: load bridget.js on import.
    - `current_did`: the ID of the current display cell.
    - `debug_req`: request debugging is enabled.
    """
    auto_show: bool = False
    auto_mount: bool = False
    auto_id: bool = False
    bootstrap: bool = os.environ.get('BRIDGET_BOOTSTRAP', '').lower() in ('true', '1', 'on', 'yes', 'y')
    current_did: str|None = None
    debug_req: bool = False

bridge_cfg = BridgeCfg()

# %% ../nbs/01_helpers.ipynb
async def arun_command(command: str, cwd: Path|None=None, **kwargs):
    import anyio
    import subprocess
    try:
        process = await anyio.run_process(
            command,
            cwd=cwd or Path().absolute().parent,
            **kwargs
        )
        return process.stdout.decode('utf-8'), process.stderr.decode('utf-8')
    except subprocess.CalledProcessError as e:
        return e.stdout.decode('utf-8'), e.stderr.decode('utf-8')

def run_command(command: str, cwd: Path|None=None, **kwargs):
    import subprocess
    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        cwd=cwd or Path().absolute().parent,
        check=True,
        **kwargs
    )
    if result.returncode != 0:
        raise RuntimeError(result.stderr)
    return result.stdout, result.stderr

# %% ../nbs/01_helpers.ipynb
def _noop(*args, **kwargs): pass
class Singleling:
    def __new__(cls, *args, **kwargs):
        if '__instance__' not in cls.__dict__: cls.__instance__ = super().__new__(cls, *args, **kwargs)
        cls.__instance__.__init__(*args, **kwargs)
        setattr(type(cls.__instance__), '__init__', _noop)
        return cls.__instance__

# %% ../nbs/01_helpers.ipynb
class Kounter:
    def __init__(self): self.d = DefaultDict(int)
    def __call__(self, k): d = self.d; d[k] += 1; return self.d[k]

kounter = Kounter()

# %% ../nbs/01_helpers.ipynb
def simple_id():
    return 'b'+hexlify(os.urandom(16), '-', 4).decode('ascii')

def id_gen():
    kntr = Kounter()
    def _(o:Any=None): 
        if o is None: return simple_id()
        # return f"{type(o).__name__}_{hash(o) if isinstance(o, Hashable) else kntr(type(o).__name__)}"
        return f"{type(o).__name__}_{kntr(type(o).__name__)}"
    return _

# %% ../nbs/01_helpers.ipynb
def patch_cached(cls, f, name:str|None=None):
    name = name or (f if not isinstance(f, partial) else f.func).__name__ 
    setattr(cls, name, cache(f))

# %% ../nbs/01_helpers.ipynb
def patch_cached_property(cls, f, name:str|None=None):
    is_partial, prop = isinstance(f, partial), functools.cached_property(f)
    if is_partial: prop.__doc__ = f.func.__doc__
    prop.attrname = name or (f if not is_partial else f.func).__name__ 
    setattr(cls, prop.attrname, prop)

# %% ../nbs/01_helpers.ipynb
class cached_property(functools.cached_property):
    def __init__(self, func):
        super().__init__(func)
        for o in functools.WRAPPER_ASSIGNMENTS: setattr(self, o, getattr(func, o))
    # def __set_name__(self, owner, name):
    #     super().__set_name__(owner, name)
    #     if self.attrname is None:
    #         self.__qualname__ = f"{owner.__name__}.{name}"

# %% ../nbs/01_helpers.ipynb
def bridge_metadata(metadata:dict|None=None, **kwargs):
    if not metadata: metadata = {'bridge': {**kwargs}}
    elif not 'bridge' in metadata: metadata['bridge'] = {**kwargs}
    else: metadata['bridge'].update(**kwargs)
    return metadata

def skip(metadata:dict|None=None, **kwargs): return bridge_metadata(metadata, skip=True, **kwargs)

# %% ../nbs/01_helpers.ipynb
def compose_first(*funcs, order=None):
    "Create a function that composes all functions in `funcs`, passing along remaining `*args` and `**kwargs` to first function"
    funcs = FC.listify(funcs)
    if len(funcs)==0: return FC.noop
    if len(funcs)==1: return funcs[0]
    if order is not None: funcs = FC.sorted_ex(funcs, key=order)
    def _inner(x, *args, **kwargs):
        x = funcs[0](x, *args, **kwargs)  # type: ignore
        for f in funcs[1:]: x = f(x)  # type: ignore
        return x
    return _inner

