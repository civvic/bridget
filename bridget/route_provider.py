"""Enables method-based routing in fasthtml by extending `APIRouter` capabilities."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/20_route_provider.ipynb.

# %% ../nbs/20_route_provider.ipynb 1
from __future__ import annotations


# %% auto 0
__all__ = ['ar', 'APIRouterB', 'RoutesProviderP', 'RoutesProvider', 'provider_routes', 'add_routes', 'APIRoute']

# %% ../nbs/20_route_provider.ipynb 4
import inspect
import typing
from types import MethodType
from typing import Any
from typing import Callable
from typing import ClassVar
from typing import Protocol

import fastcore.all as FC
from fasthtml.core import APIRouter
from fasthtml.core import FastHTML
from fasthtml.core import noop_body


# %% ../nbs/20_route_provider.ipynb 5
from .helpers import id_gen
from .helpers import nb_app


# %% ../nbs/20_route_provider.ipynb 8
new_id = id_gen()


# %% ../nbs/20_route_provider.ipynb 21
class APIRouterB(APIRouter):
    routes: list  # here to make type-checkers happy
    idx: str = '' # Instance identifier
    to: str = ''  # Base path for routes
    name: str = '' # Router name
    
    def __init__(self, routes=None, wss=None): 
        self.routes,self.wss = FC.listify(routes or [], use_list=True), FC.listify(wss or [], use_list=True)

    def __call__(self, path:str|None=None, methods=None, name=None, include_in_schema=True, body_wrap=noop_body):
        "Add a route at `path`"
        def f(func): 
            self.routes.append((func, path,methods,name,include_in_schema,body_wrap))
            return func
        return f(path) if callable(path) else f



# %% ../nbs/20_route_provider.ipynb 26
@typing.runtime_checkable
class RoutesProviderP(Protocol):
    __ar__: ClassVar[APIRouterB]
    ar: APIRouterB  # instance property with the final routes

class RoutesProvider:
    __ar__: ClassVar[APIRouterB]
    ar: APIRouterB
    def __init_subclass__(cls): 
        if not '__ar__' in vars(cls): setattr(cls, '__ar__', APIRouterB())
    # def __new__(cls, *args, **kwargs):
    #     if not hasattr(cls, '__ar__'): cls.__ar__ = APIRouterB()
    #     self = object.__new__(cls)
    #     return self

def _provider_routes(o: object):
    # Walk up the MRO chain, skipping object
    for base in (o if isinstance(o, type) else type(o)).__mro__[:-1]:  
        if not isinstance(base, type) or not hasattr(base, '__ar__'): continue
        yield from base.__ar__.routes
def provider_routes(prov: object):
    "Yield all route descriptors from class hierarchy in mro order"
    yield from _provider_routes(prov)



# %% ../nbs/20_route_provider.ipynb 32
def _ar_from_provider(prov:RoutesProviderP, name:str|None=None):
    ar, rr, funcs = (ar := APIRouterB()), ar.routes, []
    for f,_path,methods,_name,include_in_schema,body_wrap in provider_routes(prov):
        if inspect.isfunction(f):
            rr.append((getattr(prov, f.__name__), _path,methods,_name,include_in_schema,body_wrap))  # use method
            funcs.append(f)
        elif isinstance(f, property):
            for func,*m in ((f.fget, 'GET'), (f.fset, 'POST', 'PUT'), (f.fdel, 'DELETE')):
                if not func or func in funcs: continue
                mth = MethodType(func, prov)
                rr.append((mth, _path,methods or m,_name,include_in_schema,body_wrap))
                funcs.append(func)
    return ar


def add_routes(self: FastHTML, 
        prov:APIRouterB|RoutesProviderP,  # Router or provider containing routes
        mount:bool=False,                 # If True, mount routes under a sub-path
        path:str|None=None,               # Optional base path for mounting
        name:str|None=None                # Optional name for the route group
    ):
    "Register routes from a provider into a FastHTML app"
    if isinstance(prov, APIRouterB):
        is_ar, ar = True, prov
        if not mount and ar.routes: prov.to_app(self); return prov
    else:
        is_ar, ar = False, _ar_from_provider(prov, name)
        setattr(prov, 'ar', ar)
    ar.idx = new_id(prov)
    if not path: path = f"/{ar.idx}"; name = name or path.strip('/')
    ar.to, ar.name = path if mount else '', name or ''
    cls, rapp = type(prov), nb_app() if mount else self  # type: ignore
    # can't use ar.to_app(rapp), as we need to get the modified endpoints
    # to provide route introspection for methods
    for args in ar.routes:
        lf = rapp._add_route(*args)
        # a property can't have to()
        if not is_ar and not isinstance(getattr(cls, args[0].__name__), property):
            setattr(prov, args[0].__name__, lf)
    if mount and ar.routes: 
        self.mount(path, rapp, name=name)
    return ar


# %% ../nbs/20_route_provider.ipynb 48
class APIRoute:
    def __init__(self, path:str|None=None, methods=None, name=None, include_in_schema=True, body_wrap=noop_body):
        self.rargs = path, methods, name, include_in_schema, body_wrap

    def __call__(self, func: Callable[..., Any]) -> Callable: self.func = func; return self

    def __set_name__(self, owner, name):
        if not '__ar__' in vars(owner): setattr(owner, '__ar__', APIRouterB())
        owner.__ar__.routes.append((self.func, *self.rargs))
        setattr(owner, name, self.func)  # let methods be methods
    
ar = APIRoute

