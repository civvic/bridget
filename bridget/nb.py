"""Notebook cells and outputs and helpers."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/20_nb.ipynb.

# %% ../nbs/20_nb.ipynb 1
from __future__ import annotations

# %% auto 0
__all__ = ['CellTypesT', 'copycell', 'JSONVal', 'ts', 'NBCell', 'NBCellRaw', 'NBCellMarkdown', 'NBCellCode', 'NBOutput',
           'NBOutputStream', 'NBOutputDisplayData', 'NBOutputExecuteResult', 'NBOutputError', 'has_directive', 'did',
           'dids', 'by_type', 'idx2cell', 'withOutputs', 'idx2outputs', 'by_directive', 'NBProvider', 'NBProcessor',
           'NB', 'check', 'apply_diffsMessage', 'IpynbOutput', 'IpynbCell', 'St2Ipynb', 'IpynbConvertCB', 'find',
           'found']

# %% ../nbs/20_nb.ipynb
import collections
import inspect
import operator as op
from datetime import datetime
from functools import cache
from functools import partial
from typing import Callable
from typing import Iterable
from typing import Literal
from typing import Mapping
from typing import Protocol
from typing import runtime_checkable
from typing import Sequence
from typing import TypeAlias

import fastcore.all as FC
from fastcore.all import L
from fastcore.all import nested_idx
from nbdev.process import extract_directives
from nbdev.showdoc import add_docs
from olio.basic import empty
from olio.basic import gets
from olio.basic import pops_values_
from olio.callback import Callback
from olio.callback import CollBack
from olio.callback import FuncCB
from olio.common import AD
from olio.common import update_
from olio.common import vals_at
from rich.pretty import pretty_repr

# %% ../nbs/20_nb.ipynb
from .helpers import cached_property
from .helpers import compose_first
from .helpers import emptyd

# %% ../nbs/20_nb.ipynb
def ts(): return f"{datetime.now():%H:%M:%S.%f}"[:-3]

# %% ../nbs/20_nb.ipynb
CellTypesT: TypeAlias = Literal['code', 'markdown']

copycell = op.methodcaller('copy')

def _relevant_kw(o, kw:Mapping):
    ks = tuple(FC.flatten(map(inspect.get_annotations, type(o).mro())))
    return FC.filter_keys(kw, FC.in_(ks))  # type: ignore


class NBCell(AD, metaclass=FC.NewChkMeta):
    idx: str
    cell_type: str
    source: str
    metadata: dict
    def __new__(cls, cell: Mapping):
        if cls is NBCell: cls = _CTYP[cell.get('cell_type', 'raw')]
        return AD.__new__(cls, cell)
    def __init__(self, cell: Mapping):
        super().__init__(_relevant_kw(self, cell))
        self.source = ''.join(getattr(self, 'source', ()))
    def _repr_markdown_(self): 
        return f'> {self.get('cell_type', 'raw')}\n```json\n{pretty_repr(self, indent_size=2, max_width=120)}\n```'
#     def _repr_markdown_(self): 
#         return f"""
# <details><summary>{self.cell_type}</summary>

# ```json\n{pretty_repr(self, indent_size=2, max_width=120)}\n```

# </details>"""
    
    def copy(self) -> NBCell: return NBCell(dict(self))
    
    @cached_property
    def directives_(self) -> dict[str, list[str]]: return extract_directives(self, False)
    def has_directive(self, directive: str, *args): return has_directive(self, directive, *args)
    @cached_property
    def hidden(self): return has_directive(self, 'hide') or has_directive(self, 'include', 'false')


class NBCellRaw(NBCell): attachments: dict
class NBCellMarkdown(NBCellRaw):...
class NBCellCode(NBCell): 
    outputs: tuple[NBOutput, ...]
    execution_count: int | None
    def __init__(self, cell: Mapping):
        super().__init__(cell)
        self.outputs = tuple(NBOutput(o) for o in cell.get('outputs', ()))


class NBOutput(AD, metaclass=FC.NewChkMeta): 
    output_type: str
    def __new__(cls, out: Mapping):
        if cls is NBOutput: cls = _OUTTYP[out.get('output_type', 'stream')]
        return AD.__new__(cls, out)
    def __init__(self, out: Mapping):
        ks = tuple(FC.flatten(map(inspect.get_annotations, type(self).mro())))
        out = FC.filter_keys(out, FC.in_(ks))  # type: ignore
        super().__init__(out)

class NBOutputStream(NBOutput):
    name: Literal['stdout', 'stderr']
    text: str

class NBOutputDisplayData(NBOutput):
    data: dict
    metadata: dict

class NBOutputExecuteResult(NBOutput):
    execution_count: int
    data: dict
    metadata: dict

class NBOutputError(NBOutput):
    ename: str
    evalue: str
    traceback: list[str]


_CTYP = {'raw':NBCellRaw, 'markdown':NBCellMarkdown, 'code':NBCellCode}
# _CTYPInv = {v:k for k,v in _CTYP.items()}
_OUTTYP = {'stream':NBOutputStream, 'display_data':NBOutputDisplayData, 'execute_result':NBOutputExecuteResult, 'error':NBOutputError}
# _OUTTYPInv = {v:k for k,v in _OUTTYP.items()}

def has_directive(c: NBCell, directive: str, *args):
    return directive in c.directives_ and c.directives_[directive] == list(args)

# %% ../nbs/20_nb.ipynb
def did(o:NBOutputDisplayData) -> str|None: 
    return nested_idx(o, 'metadata', 'transient', 'display_id')  # type: ignore

FC.patch(did, as_prop=True)

# %% ../nbs/20_nb.ipynb
def dids(o:NBCell)->L[str|None]: return L(o.outputs).map(did)  # type: ignore

FC.patch(dids, as_prop=True)

# %% ../nbs/20_nb.ipynb
def by_type(cells: Sequence[NBCell]|L, cell_type: CellTypesT):
    return L(cells).argwhere(lambda c: c['cell_type'] == cell_type)

# %% ../nbs/20_nb.ipynb
def idx2cell(cells: Sequence[NBCell]|L, cell_type: CellTypesT|None=None) -> dict[int, L]:
    cells = L(cells)
    idxs = by_type(cells, cell_type) if cell_type else L.range(len(cells))
    return dict(idxs.zipwith(cells[idxs]))

# %% ../nbs/20_nb.ipynb
def withOutputs(cells: Sequence[NBCell]|L):
    'Return indices of cells with outputs'
    return L(cells).argwhere(lambda c: 'outputs' in c)

# %% ../nbs/20_nb.ipynb
def idx2outputs(cells: Sequence[NBCell]|L) -> dict[int, L]:
    'Return dict of indices to cells with outputs'
    cells = L(cells)
    outputs_idx = withOutputs(cells)
    return dict(outputs_idx.zipwith(cells[outputs_idx]))

# %% ../nbs/20_nb.ipynb
def by_directive(cells: Sequence[NBCell]|L, directive: str, *args):
    return L(cells).argwhere(lambda c: has_directive(c, directive, *args))

# %% ../nbs/20_nb.ipynb
@runtime_checkable
class NBProvider(Protocol):
    @property
    def nb(self) -> NB: ...

@runtime_checkable
class NBProcessor(Protocol):
    def __call__(self, nb:NB, *args, **kwargs) -> NB: ...


class NB(AD):
    "Bridget representation of notebook state"
    cells: L[NBCell]  # type: ignore
    nbData: dict
    type: str
    timestamp: str
    origin: str
    def __init__(self, cells: Sequence[NBCell]|L=(), **kwargs):
        self.cells = L(NBCell(_) for _ in cells)
        d = update_({'nbData':{}, 'type':'state', 'timestamp':'', 'origin':''}, **_relevant_kw(self, kwargs))
        super().__init__(**d)
    
    @classmethod
    def fromStateMessage(cls, message):
        message = message.copy()
        cells = pops_values_(message, 'cells')[0]
        return cls(cells, **message)
    
    def by_type(self, cell_type: CellTypesT): return by_type(self.cells, cell_type)
    @cached_property
    def codes(self): return by_type(self.cells, 'code')
    @cached_property
    def mds(self): return by_type(self.cells, 'markdown')

    def idx2cell(self, cell_type: CellTypesT|None=None): return idx2cell(self.cells, cell_type)
    @cached_property
    def idx2code(self): return idx2cell(self.cells, 'code')
    @cached_property
    def idx2md(self): return idx2cell(self.cells, 'markdown')

    @cached_property
    def withOutputs(self): return withOutputs(self.cells)
    @cached_property
    def idx2outputs(self) -> dict[int, L]: return idx2outputs(self.cells)

    def by_directive(self, directive: str, *args): return by_directive(self.cells, directive)
    @cached_property
    def hiddens(self): return self.by_directive('hide') + self.by_directive('include', 'false')

    @cache
    def select(self, k='source'): return self.cells.attrgot(k, None)

    def _process(self, items, cbs):
        collections.deque(CollBack(items, context=self, cbs=cbs), maxlen=0)
        return FC.first(cbs.attrgot('nb')[::-1]) or self
    
    def process(self, /,
            cbs: Callback|Sequence[Callback]=(), 
            slc:slice|None=None, 
            pred:Callable[[NBCell], bool]|None=None, 
            **kwargs  # FuncCB kwargs
        ) -> NB:
        "Process a subset `slc` of cells filtered by `pred` with `cbs` and `FuncCB` callbacks."
        _cbs = FC.L(FC.tuplify(cbs) + ((FuncCB(**kwargs),) if kwargs else ()))
        items = self.cells[slc or slice(None)].filter(pred) if pred or slc else self.cells  # type: ignore
        if _cbs: return self._process(items, _cbs)
        else: return NB(items, nbData=self.nbData, type=self.type, timestamp=self.timestamp)
    
    def pipe(self, funcs:Iterable[NBProcessor], *args, **kwargs) -> NB: 
        return compose_first(*funcs)(self, *args, **kwargs)  # type: ignore
    
    @classmethod
    def from_NB(cls, nb: NB, cells: Sequence[NBCell]|L|None=None, **kwargs): 
        return NB(cells if cells is not None else nb.cells, 
			**update_({'nbData':nb.nbData, 'type':nb.type, 'timestamp':nb.timestamp}, **kwargs))


for k in ('source', 'metadata', 'outputs'): setattr(NB, k, property(NB.select.__wrapped__,))

# %% ../nbs/20_nb.ipynb
add_docs(NB,
    by_type="Return indices of cells of type `cell_type`",
    codes="Cell indices of type `code`",
    mds="Cell indices of type `markdown`",
    idx2cell="Return dict of indices to cells of type `cell_type`",
    idx2code="Return dict of indices to cells of type `code`",
    idx2md="Return dict of indices to cells of type `markdown`",
    withOutputs="Return indices of cells with outputs",
    idx2outputs="Return dict of indices to cells with outputs",
    by_directive="Return indices of cells with directive `directive`",
    hiddens="Return indices of cells with `hide` or `include:false` directives",
    pipe="Pipe a sequence of `NBProcessor`s",
    from_NB="Create a new `NB` from an existing `NB`",
    select="Return `k` attribute of cells",
    source="Return `source` attribute of all cells",
    metadata="Return `metadata` attribute of all cells",
    outputs="Return `outputs` attribute of all cells",
)

# %% ../nbs/20_nb.ipynb
@FC.patch
def check(self:NB):
    assert self.nbData['cellCount'] == len(self.cells)
    for n, c in enumerate(self.cells):
        assert c.idx == n

# %% ../nbs/20_nb.ipynb
@FC.patch
def _apply_diff(self:NB, diff):
    cells = self.cells
    changed, added, removed, cellCount = gets(diff, 'cells', 'added', 'removed', 'cellCount')
    if isinstance(removed, list) and removed:
        for idx in sorted(removed, reverse=True):  # type: ignore
            del cells[idx]
            for cell in cells[idx:]: cell.idx -= 1
    elif isinstance(added, list) and added:
        for cell in added:  # type: ignore
            idx = cell['idx']
            cells.insert(idx, NBCell(cell))
            for cell in cells[idx+1:]: cell.idx += 1
    for cell in changed: cells[cell['idx']] = NBCell(cell)  # type: ignore
    self.nbData['cellCount'] = cellCount

# %% ../nbs/20_nb.ipynb
@FC.patch
def apply_diffsMessage(self:NB, diffs):
    for diff in diffs['changes']: self._apply_diff(diff)
    self.check()

# %% ../nbs/20_nb.ipynb
class IpynbOutput(AD): ...
class IpynbCell(AD): outputs: tuple[IpynbOutput, ...]

class St2Ipynb(FC.Transform): 
    def encodes(self, x: NBOutput) -> IpynbOutput:  # type: ignore
        fmt = IpynbOutput(x)
        if fmt['output_type'] in ('display_data', 'execute_result'): fmt.metadata=x.get('metadata', {})
        fmt.get('metadata', emptyd).pop('transient', None)
        return fmt
    def decodes(self, x: IpynbOutput) -> NBOutput:  # type: ignore
        return NBOutput(x)

    def encodes(self, x: NBCell) -> IpynbCell:
        fmt = update_(IpynbCell(x), metadata=x.get('metadata', {}))
        fmt.pop('idx', None)
        if 'outputs' in x: fmt['outputs'] = self(x.outputs)
        # if x['cell_type'] == 'code': 
        #     fmt['execution_count'] = fmt.get('execution_count', None)
        return fmt
    def decodes(self, x: IpynbCell) -> NBCell:
        return NBCell(x)


# %% ../nbs/20_nb.ipynb
class IpynbConvertCB(Callback):
    def before_iter(self, istat): 
        nb = istat.context
        d, ks, mdks = nb.nbData['metadata'], ('nbformat', 'nbformat_minor'), ('kernelspec', 'language_info')
        self.notebook = {
            'cells': [],
            **FC.filter_keys(d, FC.in_(ks)),  # type: ignore
            'metadata': FC.filter_keys(d['metadata'], FC.in_(mdks)),  # type: ignore
        }
        self.cell_counter = 0
        self._fmt = St2Ipynb()
    
    def on_iter(self, _, cell):
        # fmt = update_(St2Ipynb()(cell), id=self.cell_counter)
        self.notebook['cells'].append(self._fmt(cell))
        self.cell_counter += 1


# %% ../nbs/20_nb.ipynb
def _there(where, what, op, c):
    res = vals_at(c, where)
    if res is empty: return False
    else: return op(res, what) if '*' not in where else any(op(r, what) for r in res)  # type: ignore


# %% ../nbs/20_nb.ipynb
JSONVal: TypeAlias = str | int | float | bool | None | dict[str, 'JSONVal'] | list['JSONVal']

@FC.patch
def find(self: NB, what:JSONVal|Callable[[NBCell], bool], where:str='source', op=op.contains) -> L:
    "Find cells matching `what` in `where` using `op`"
    # if isinstance(what, str): what = lambda c: False if (res := _F(c, where, None)) is None else what in res
    if not isinstance(what, Callable): what = partial(_there, where, what, op)
    return self.cells.filter(what)


# %% ../nbs/20_nb.ipynb
@FC.patch
def found(self: NB, 
        what:JSONVal|Callable[[NBCell], bool], where='source', op=op.contains, 
        cbs:Callback|Sequence[Callback]=()
    ) -> NB:
    return NB.from_NB(self, self.find(what, where, op)).process(cbs)

