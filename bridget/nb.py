"""Notebook cells and outputs and helpers."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/07_nb.ipynb.

# %% ../nbs/07_nb.ipynb 1
from __future__ import annotations

# %% auto 0
__all__ = ['CellTypesT', 'copycell', 'JSONVal', 'NBCell', 'NBCellRaw', 'NBCellMarkdown', 'NBCellCode', 'NBOutput',
           'NBOutputStream', 'NBOutputDisplayData', 'NBOutputExecuteResult', 'NBOutputError', 'has_directive', 'did',
           'dids', 'by_type', 'idx2cell', 'withOutputs', 'idx2outputs', 'idx2dids', 'by_directive', 'NBProvider',
           'NBProcessor', 'NB', 'apply_diffsMessage', 'IpynbOutput', 'IpynbCell', 'St2Ipynb', 'IpynbConvertCB', 'find',
           'found']

# %% ../nbs/07_nb.ipynb
import collections
import inspect
import operator as op
from copy import deepcopy
from functools import cache
from functools import partial
from typing import Callable
from typing import Iterable
from typing import Literal
from typing import Mapping
from typing import overload
from typing import Protocol
from typing import runtime_checkable
from typing import Sequence
from typing import SupportsIndex
from typing import TypeAlias

import fastcore.all as FC
from fastcore.all import L
from fastcore.xml import to_xml
from fasttransform import Transform
from nbdev.process import extract_directives
from nbdev.showdoc import add_docs
from olio.basic import empty
from olio.basic import gets
from olio.callback import Callback
from olio.callback import CollBack
from olio.callback import FuncCB
from olio.common import AD
from olio.common import update_
from olio.common import val_atpath
from olio.common import vals_at
from rich.pretty import pretty_repr


# %% ../nbs/07_nb.ipynb
import bridget.fasthtml_patching
from .helpers import cached_property
from .helpers import compose_first
from .helpers import DetailsJSON
from .helpers import emptyd


# %% ../nbs/07_nb.ipynb
CellTypesT: TypeAlias = Literal['code', 'markdown']

copycell = op.methodcaller('copy')

def _relevant_kw(o, kw:Mapping):
    ks = tuple(FC.flatten(map(inspect.get_annotations, type(o).mro())))
    return FC.filter_keys(kw, FC.in_(ks))  # type: ignore


class NBCell(AD, metaclass=FC.NewChkMeta):
    idx: str
    cell_type: str
    source: str
    metadata: dict
    id: str
    def __new__(cls, cell: Mapping):
        if cls is NBCell: cls = _CTYP[cell.get('cell_type', 'raw')]
        return AD.__new__(cls, cell)
    def __init__(self, cell: Mapping):
        super().__init__(_relevant_kw(self, cell))
        self.source = ''.join(getattr(self, 'source', ()))
    def __ft__(self): return DetailsJSON(self, openall=True).__ft__()
    def _repr_markdown_(self): 
        return f'> {self.get('cell_type', 'raw')}\n\n```json\n{pretty_repr(self, indent_size=2, max_width=120)}\n```'
    def _repr_html_(self): return to_xml(DetailsJSON(self, summary=f"NBCell@{self.idx}", openall=True, skip=('application/json', 'metadata')))
    def copy(self) -> NBCell: return NBCell(dict(self))
    
    @cached_property
    def directives_(self) -> dict[str, list[str]]: return extract_directives(self, False)
    def has_directive(self, directive: str, *args): return has_directive(self, directive, *args)
    @cached_property
    def hidden(self): return has_directive(self, 'hide') or has_directive(self, 'include', 'false')


class NBCellRaw(NBCell): attachments: dict
class NBCellMarkdown(NBCellRaw):...
class NBCellCode(NBCell): 
    outputs: list[NBOutput]
    execution_count: int | None
    def __init__(self, cell: Mapping):
        super().__init__(cell)
        self.outputs = list(NBOutput(o) for o in cell.get('outputs', []))


class NBOutput(AD, metaclass=FC.NewChkMeta): 
    output_type: str
    def __new__(cls, out: Mapping):
        if cls is NBOutput: cls = _OUTTYP[out.get('output_type', 'stream')]
        return AD.__new__(cls, out)
    def __init__(self, out: Mapping):
        ks = tuple(FC.flatten(map(inspect.get_annotations, type(self).mro())))
        out = FC.filter_keys(out, FC.in_(ks))  # type: ignore
        super().__init__(out)

class NBOutputStream(NBOutput):
    name: Literal['stdout', 'stderr']
    text: str

class NBOutputDisplayData(NBOutput):
    data: dict
    metadata: dict

class NBOutputExecuteResult(NBOutput):
    execution_count: int
    data: dict
    metadata: dict

class NBOutputError(NBOutput):
    ename: str
    evalue: str
    traceback: list[str]


_CTYP = {'raw':NBCellRaw, 'markdown':NBCellMarkdown, 'code':NBCellCode}
# _CTYPInv = {v:k for k,v in _CTYP.items()}
_OUTTYP = {'stream':NBOutputStream, 'display_data':NBOutputDisplayData, 'execute_result':NBOutputExecuteResult, 'error':NBOutputError}
# _OUTTYPInv = {v:k for k,v in _OUTTYP.items()}

def has_directive(c: NBCell, directive: str, *args):
    return directive in c.directives_ and c.directives_[directive] == list(args)

# %% ../nbs/07_nb.ipynb
def did(o:NBOutput) -> str|None:
    if not (o and o['output_type'] == 'display_data'): return None
    md = o.metadata
    return md.get('brd_did') or val_atpath(md, 'transient', 'display_id', default=None) or None

FC.patch(did, as_prop=True)

# %% ../nbs/07_nb.ipynb
def dids(o:NBCell)->L[str]: return L(o.outputs if 'outputs' in o else () ).map(did).filter() # type: ignore

FC.patch(dids, as_prop=True)

# %% ../nbs/07_nb.ipynb
def by_type(cells: Sequence[NBCell]|L, cell_type: CellTypesT) -> L:
    "Return 'L' of indices of cells of type `cell_type`"
    return L(cells).argwhere(lambda c: c['cell_type'] == cell_type)

# %% ../nbs/07_nb.ipynb
def idx2cell(cells: Sequence[NBCell]|L, cell_type: CellTypesT|None=None) -> Mapping[int, NBCell]:
    "Return mapping of indices to cells of type `cell_type`"
    cells = L(cells)
    idxs = by_type(cells, cell_type) if cell_type else L.range(len(cells))
    return dict(idxs.zipwith(cells[idxs]))

# %% ../nbs/07_nb.ipynb
def withOutputs(cells: Sequence[NBCell]|L):
    'Return indices of cells with outputs'
    return L(cells).argwhere(lambda c: 'outputs' in c)

# %% ../nbs/07_nb.ipynb
def idx2outputs(cells: Sequence[NBCell]|L) -> dict[int, L]:
    'Return dict of indices to cells with outputs'
    outputs_idx = withOutputs(cells := L(cells))
    return dict(outputs_idx.zipwith(cells[outputs_idx]))

# %% ../nbs/07_nb.ipynb
def idx2dids(cells: Sequence[NBCell]|L) -> dict[int, L]:
    'Return dict of indices to cells with transient outputs'
    idxs = withOutputs(cells := L(cells))
    return dict(idxs.zipwith(cells[idxs].map(dids)).filter(lambda c: c[1]))  # type: ignore

# %% ../nbs/07_nb.ipynb
def by_directive(cells: Sequence[NBCell]|L, directive: str, *args):
    return L(cells).argwhere(lambda c: has_directive(c, directive, *args))

# %% ../nbs/07_nb.ipynb
JSONVal: TypeAlias = str | int | float | bool | None | dict[str, 'JSONVal'] | list['JSONVal']

@runtime_checkable
class NBProvider(Protocol):
    @property
    def nb(self) -> NB: ...

@runtime_checkable
class NBProcessor(Protocol):
    def __call__(self, nb:NB, *args, **kwargs) -> NB: ...


class NB:
    "Bridget representation of notebook state"
    cells: L[NBCell]  # type: ignore
    nbData: dict
    type: str
    timestamp: str
    origin: str
    def __init__(self, cells: Sequence[NBCell]|L=(), **kwargs): self.setup(cells, **kwargs)
    def setup(self, cells: Sequence[NBCell]|L=(), **kwargs):
        self.cells = L(NBCell(_) for _ in cells)
        d = update_({'nbData':{}, 'type':'state', 'timestamp':'', 'origin':''}, **_relevant_kw(self, kwargs))
        for k,v in d.items(): setattr(self, k, v)
        self._rebuild()
    @classmethod
    def fromStateMessage(cls, message): return cls(**message)
    @classmethod
    def from_NB(cls, nb: NB, cells: Sequence[NBCell]|L|None=None, **kwargs): 
        return NB(cells if cells is not None else nb.cells, 
			**update_({'nbData':nb.nbData, 'type':nb.type, 'timestamp':nb.timestamp}, **kwargs))
    def as_dict(self): return _relevant_kw(self, vars(self)) 

    def _indxs(self):
        self._id2idx = {c.id:i for i,c in enumerate(self.cells)}  # type: ignore
    
    def __iter__(self): return iter(self.cells)
    @overload
    def __getitem__(self, key: SupportsIndex|str, /) -> NBCell: ...
    @overload
    def __getitem__(self, key: slice, /) -> L: ...
    def __getitem__(self, key) -> NBCell|L: 
        if isinstance(key, str):
            if (idx := self._id2idx.get(key)) is not None: return self.cells[idx]  # type: ignore
            # cc = self.cells.filter(lambda c: c.id == key)
            # if cc: return cc[0] if len(cc) else L()  # type: ignore
            cc = self.cells.filter(lambda c: 'metadata' in c and c.metadata['cell_id'] == key)
            return cc[0] if len(cc) else L()  # type: ignore
        return self.cells[key]  # type: ignore
    
    def by_type(self, cell_type: CellTypesT): return by_type(self.cells, cell_type)
    @cached_property
    def codes(self): return by_type(self.cells, 'code')
    @cached_property
    def mds(self): return by_type(self.cells, 'markdown')

    def idx2cell(self, cell_type: CellTypesT|None=None): return idx2cell(self.cells, cell_type)
    @cached_property
    def idx2code(self): return idx2cell(self.cells, 'code')
    @cached_property
    def idx2md(self): return idx2cell(self.cells, 'markdown')

    @cached_property
    def withOutputs(self): return withOutputs(self.cells)
    @cached_property
    def idx2outputs(self) -> dict[int, L]: return idx2outputs(self.cells)
    @cached_property
    def idx2dids(self) -> dict[int, L]: return idx2dids(self.cells)

    def by_directive(self, directive: str, *args): return by_directive(self.cells, directive)
    @cached_property
    def hiddens(self): return self.by_directive('hide') + self.by_directive('include', 'false')

    @cache
    def cell_by_did(self, did:str) -> NBCell|None:
        cc = self.cells[tuple(self.idx2dids.keys())].filter(lambda c: did in dids(c))  # type: ignore
        return cc[0] if len(cc) else None  # type: ignore

    @cache
    def select(self, k='source'): return self.cells.attrgot(k, None)

    _cks = {'codes', 'mds', 'idx2code', 'idx2md', 'withOutputs', 'idx2outputs', 'idx2dids', 'hiddens'}
    def _rebuild(self):
        self.select.cache_clear()
        self.cell_by_did.cache_clear()
        self._indxs()
        vv = vars(self).keys() & self._cks
        for k in vv:delattr(self, k)

    def _process(self, items, cbs):
        collections.deque(CollBack(items, context=self, cbs=cbs), maxlen=0)
        return FC.first(cbs.attrgot('nb')[::-1]) or self
    
    def process(self, /,
            cbs: Callback|Sequence[Callback]=(), 
            slc:slice|None=None, 
            pred:Callable[[NBCell], bool]|None=None, 
            **kwargs  # FuncCB kwargs
        ) -> NB:
        "Process a subset `slc` of cells filtered by `pred` with `cbs` and `FuncCB` callbacks."
        _cbs = FC.L(FC.tuplify(cbs) + ((FuncCB(**kwargs),) if kwargs else ()))
        items = self.cells[slc or slice(None)].filter(pred) if pred or slc else self.cells  # type: ignore
        if _cbs: return self._process(items, _cbs)
        else: return NB(items, nbData=self.nbData, type=self.type, timestamp=self.timestamp)
    
    def pipe(self, funcs:Iterable[NBProcessor], *args, **kwargs) -> NB: 
        return compose_first(*funcs)(self, *args, **kwargs)  # type: ignore
    
    # hate but a lot wiggly reds but mostly hate pyright's hatred of notebooks
    def _apply_diff(self, diff:dict): ...
    def apply_diffsMessage(self, diffs): ...
    def find(self, what:JSONVal|Callable[[NBCell], bool], where:str='source', op=op.contains) -> L: ...
    def found(self, 
        what:JSONVal|Callable[[NBCell], bool], where='source', op=op.contains, 
        cbs:Callback|Sequence[Callback]=()
    ) -> NB: ...
    @property
    def source(self) -> L: ...
    @property
    def metadata(self) -> L: ...
    @property
    def outputs(self) -> L: ...


for k in ('source', 'metadata', 'outputs'): setattr(NB, k, property(NB.select.__wrapped__,))

# %% ../nbs/07_nb.ipynb
add_docs(NB,
    setup="Setup with new data",
    as_dict="Return dict of all attributes",
    by_type="Return indices of cells of type `cell_type`",
    codes="Cell indices of type `code`",
    mds="Cell indices of type `markdown`",
    idx2cell="Return dict of indices to cells of type `cell_type`",
    idx2code="Return dict of indices to cells of type `code`",
    idx2md="Return dict of indices to cells of type `markdown`",
    withOutputs="Return indices of cells with outputs",
    idx2outputs="Return dict of indices to cells with outputs",
    by_directive="Return indices of cells with directive `directive`",
    hiddens="Return indices of cells with `hide` or `include:false` directives",
    pipe="Pipe a sequence of `NBProcessor`s",
    from_NB="Create a new `NB` from an existing `NB`",
    cell_by_did="Return cell with `did` or None",
    select="Return `k` attribute of cells",
    source="Return `source` attribute of all cells",
    metadata="Return `metadata` attribute of all cells",
    outputs="Return `outputs` attribute of all cells",
    apply_diffsMessage="Apply a diffsMessage to the `NB`",
    find="Find cells matching `what` in `where` using `op`",
    found="Find cells matching `what` in `where` using `op` and process them with `cbs`",
)

# %% ../nbs/07_nb.ipynb
@FC.patch
def _apply_diff(self:NB, diff:dict):
    changed, added, removed, cell_count = gets(diff, 'cells', 'added', 'removed', 'cellCount')
    final_count = len(self.cells) - len(removed if isinstance(removed, list) else []) + len(added if isinstance(added, list) else [])
    if cell_count != final_count:
        raise IndexError(f"---- inconsistent diff cell_count: {cell_count} != {final_count=}")
    cells = self.cells
    if isinstance(removed, list) and removed:
        if (n := max(removed)) >= len(cells):
            raise IndexError(f"---- inconsistent diff removed: {n} > {len(cells)}")
        for idx in sorted(removed, reverse=True):
            del cells[idx]
            for cell in cells[idx:]: cell.idx -= 1
    elif isinstance(added, list) and added:
        for cell in added:
            if (idx := cell['idx']) > len(cells):
                raise IndexError(f"---- inconsistent diff added: {idx} > {len(cells)=}")
            cells.insert(idx, NBCell(cell))
            for cell in cells[idx+1:]: cell.idx += 1
    ln = len(cells)
    if isinstance(changed, list):
        for cell in changed: 
            if (idx := cell['idx']) > ln:
                raise IndexError(f"---- inconsistent diff changed: {idx} > {len(cells)=}")
            cells[idx] = NBCell(cell)
    self.nbData['cellCount'] = cell_count
    for n, c in enumerate(self.cells):
        if c.idx != n:
            raise IndexError(f"---- inconsistent diff cell idx: {c.idx} != {n=}")
    self._rebuild()

# %% ../nbs/07_nb.ipynb
@FC.patch
def apply_diffsMessage(self:NB, diffs):
    for diff in diffs['changes']: 
        try: self._apply_diff(diff)  # type: ignore
        except IndexError as e:
            print(f"---- inconsistent diff: {e}")
            raise e

# %% ../nbs/07_nb.ipynb
class IpynbOutput(AD): ...
class IpynbCell(AD): outputs: list[IpynbOutput]

class St2Ipynb(Transform): 
    def __init__(self, in_vscode: bool=False): self.in_vscode = in_vscode
    def encodes(self, x: NBOutput) -> IpynbOutput:  # type: ignore
        fmt = IpynbOutput(x)
        if fmt['output_type'] in ('display_data', 'execute_result'): fmt.metadata=x.get('metadata', {})
        fmt.get('metadata', emptyd).pop('transient', None)
        return fmt
    def decodes(self, x: IpynbOutput) -> NBOutput: return NBOutput(x)  # type: ignore
        

    def encodes(self, x: NBCell) -> IpynbCell:
        fmt = update_(IpynbCell(x), metadata=x.get('metadata', {}))
        if self.in_vscode:
            fmt['metadata'] = deepcopy(fmt['metadata'])
            brd = fmt['metadata']['brd']
            brd['cell_id'], fmt['id'] = fmt['id'], brd['id']
            del brd['id']
        fmt.pop('idx', None)
        if 'outputs' in x: fmt['outputs'] = self(tuple(x.outputs))
        # if x['cell_type'] == 'code': 
        #     fmt['execution_count'] = fmt.get('execution_count', None)
        return fmt
    def decodes(self, x: IpynbCell) -> NBCell: return NBCell(x)

# %% ../nbs/07_nb.ipynb
class IpynbConvertCB(Callback):
    def __init__(self, in_vscode: bool=False): self.in_vscode = in_vscode
    def before_iter(self, istat): 
        nb = istat.context
        d, ks, mdks = nb.nbData['metadata'], ('nbformat', 'nbformat_minor'), ('kernelspec', 'language_info')
        self.notebook = {
            'cells': [],
            **FC.filter_keys(d, FC.in_(ks)),  # type: ignore
            'metadata': FC.filter_keys(d['metadata'], FC.in_(mdks)),  # type: ignore
        }
        self.notebook['nbformat_minor'] = 5
        self.cell_counter = 0
        self._fmt = St2Ipynb(self.in_vscode)
    
    def on_iter(self, _, cell):
        # fmt = update_(St2Ipynb()(cell), id=self.cell_counter)
        self.notebook['cells'].append(self._fmt(cell))
        self.cell_counter += 1

# %% ../nbs/07_nb.ipynb
def _there(where, what, op, c):
    res = vals_at(c, where)
    if res is empty: return False
    return any(op(r, what) for r in res)

# %% ../nbs/07_nb.ipynb
@FC.patch
def find(self: NB, what:JSONVal|Callable[[NBCell], bool], where:str='source', op=op.contains) -> L:
    "Find cells matching `what` in `where` using `op`"
    # if isinstance(what, str): what = lambda c: False if (res := _F(c, where, None)) is None else what in res
    if not isinstance(what, Callable): what = partial(_there, where, what, op)
    return self.cells.filter(what)

# %% ../nbs/07_nb.ipynb
@FC.patch
def found(self: NB, 
        what:JSONVal|Callable[[NBCell], bool], where='source', op=op.contains, 
        cbs:Callback|Sequence[Callback]=()
    ) -> NB:
    return NB.from_NB(self, self.find(what, where, op)).process(cbs)
