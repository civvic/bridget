[
  {
    "objectID": "helpers.html",
    "href": "helpers.html",
    "title": "Helpers",
    "section": "",
    "text": "source",
    "crumbs": [
      "Core Components",
      "Helpers"
    ]
  },
  {
    "objectID": "helpers.html#id_gen",
    "href": "helpers.html#id_gen",
    "title": "Helpers",
    "section": "id_gen",
    "text": "id_gen\n\nGenerate unique session IDs\n\n\nimport random\nimport re\nfrom pathlib import Path\n\n\nlines = Path(\"static/wordlist.txt\").read_text().splitlines()\nwords = [line.strip() for line in lines if line.isalpha()]\n\n\ndef modify_word(word):\n    # Randomly capitalize the first or second letter\n    if len(word) &gt; 1:\n        idx_to_capitalize = random.choice([0, 1])\n        word = word[:idx_to_capitalize] + word[idx_to_capitalize].upper() + word[idx_to_capitalize + 1:]\n    else:\n        word = word.upper()  # If single letter, capitalize it\n    \n    # Randomly add a number (0–99) at the start or end\n    if random.choice([True, False]):\n        number = random.randint(0, 99)\n        # if random.choice([True, False]):\n        #     word = f\"{number}{word}\"  # Number at the start\n        # else:\n        word = f\"{word}{number}\"  # Number at the end\n    \n    return word\n\ndef generate_readable_id(num_words=3):\n    words_part = [modify_word(random.choice(words)) for _ in range(num_words)]\n    id_candidate = '-'.join(words_part)\n\n    # Ensure it's a valid CSS identifier\n    if not re.match(r\"^[a-zA-Z_][\\w\\-]*$\", id_candidate):  # Add '_' if invalid\n        id_candidate = f\"_{id_candidate}\"\n    \n    return f\"{id_candidate}-{random.randint(0, 9999)}\"\n\n\ngenerate_readable_id(), generate_readable_id()\n\n('lOsing-Solution49-Own-7437', 'cLosest-Won10-hIdes-5235')\n\n\n\nsource\n\nid_gen\n\n id_gen ()\n\nCreate ID generator function that produces unique session-based IDs\n\nsource\n\n\nsimple_id\n\n simple_id ()\n\nGenerate simple hex ID using random bytes\n\nsimple_id()\n\n'bb0f5bfa4-b8ad1c79-4bc1cd7b-c96b3532'\n\n\nThe id_gen function creates a function that takes any object and generates an unique Id valid during the current session. Useful for creating unique element IDs in dynamic HTML content.\n\nnew_id = id_gen()\nnew_id(), new_id()\n\n('bd0f6d060-acc69f5f-a6ef89f6-fc1bb445',\n 'b6dcae08c-1ac05807-c47196d0-37cf4666')\n\n\n\nint_id = id_gen()\nint_id(7), int_id(7), int_id(888)\n\n('int_1-1764770571', 'int_2-1764770571', 'int_3-1764770571')\n\n\n\nint_id = id_gen()\nint_id('asdf'), int_id('asdf'), int_id('asdf')\n\n('asdf_1-1764770571', 'asdf_2-1764770571', 'asdf_3-1764770571')\n\n\n\nobj_id = id_gen()\no1, o2 = object(), object()\nprint(obj_id(o1), obj_id(o2))\n\ndict_id = id_gen()\nprint(dict_id(d1 := {'a': 1}), dict_id(d2 := {'b': 7}))\n\npth_id = id_gen()\nprint(pth_id(Path('.')), pth_id(Path()), pth_id(Path('./bin')))\n\nobject_1-1764770571 object_2-1764770571\ndict_1-1764770571 dict_2-1764770571\nPosixPath_1-1764770571 PosixPath_2-1764770571 PosixPath_3-1764770571",
    "crumbs": [
      "Core Components",
      "Helpers"
    ]
  },
  {
    "objectID": "helpers.html#function-composition",
    "href": "helpers.html#function-composition",
    "title": "Helpers",
    "section": "Function Composition",
    "text": "Function Composition\nlike fastcore.compose, but args are passed only to first function\n\nsource\n\ncompose_first\n\n compose_first (*funcs:Callable, order:Optional[Callable]=None)\n\nCreate a function that composes all functions in funcs, passing remaining *args and **kwargs to first function only. order: key function to sort funcs before composing\n\ndef add_one(x): return x + 1\ndef multiply_two(x): return x * 2\ndef add_ten(x): return x + 10\n\nsingle = compose_first(add_one)\ntest_eq(single(5), 6)\n\ntest_eq(single, add_one)\nempty = compose_first()\ntest_eq(empty, FC.noop)\n\ncomposed = compose_first(add_one, multiply_two, add_ten)\ntest_eq(composed(5), 22)  # ((5+1) * 2) + 10 = 22\n\n\ndef tag_a(x): return f\"a({x})\"\ndef tag_b(x): return f\"b({x})\"\ndef tag_c(x): return f\"c({x})\"\n\nnatural = compose_first(tag_c, tag_a, tag_b)\ntest_eq(natural(\"x\"), \"b(a(c(x)))\")\n\nordered = compose_first(tag_c, tag_a, tag_b, order=lambda f: f.__name__)\ntest_eq(ordered(\"x\"), \"c(b(a(x)))\")  # Functions sorted: tag_a, tag_b, tag_c",
    "crumbs": [
      "Core Components",
      "Helpers"
    ]
  },
  {
    "objectID": "helpers.html#detailsjson",
    "href": "helpers.html#detailsjson",
    "title": "Helpers",
    "section": "DetailsJSON",
    "text": "DetailsJSON\n\n&lt;style&gt;\n    details ul { list-style-type:none; list-style-position: outside; padding-inline-start: 22px; margin: 0px; }\n&lt;/style&gt;\n&lt;details open&gt;\n&lt;summary&gt;Apollo astronauts&lt;/summary&gt;\n&lt;ul&gt;\n  &lt;li&gt;&lt;span&gt;1&lt;/span&gt;: Neil Armstrong&lt;/li&gt;\n  &lt;li&gt;&lt;span&gt;2&lt;/span&gt;: Alan Bean&lt;/li&gt;\n  &lt;li&gt;&lt;details&gt;\n&lt;summary&gt;Apollo 11&lt;/summary&gt;\n&lt;ul&gt;\n  &lt;li&gt;&lt;span&gt;1&lt;/span&gt;: Neil Armstrong&lt;/li&gt;\n  &lt;li&gt;&lt;span&gt;2&lt;/span&gt;: Alan Bean&lt;/li&gt;\n  &lt;li&gt;&lt;div&gt;&lt;span&gt;3&lt;/span&gt;: Buzz Aldrin&lt;/div&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;span&gt;4&lt;/span&gt;: Edgar Mitchell&lt;/li&gt;\n  &lt;li&gt;&lt;span&gt;5&lt;/span&gt;: Alan Shepard&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;span&gt;4&lt;/span&gt;: Edgar Mitchell&lt;/li&gt;\n  &lt;li&gt;&lt;span&gt;5&lt;/span&gt;: Alan Shepard&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;/details&gt;\n\n\n\nApollo astronauts\n\n  1: Neil Armstrong\n  2: Alan Bean\n  \nApollo 11\n\n  1: Neil Armstrong\n  2: Alan Bean\n  3: Buzz Aldrin\n  4: Edgar Mitchell\n  5: Alan Shepard\n\n  4: Edgar Mitchell\n  5: Alan Shepard\n\n\n\n\n\n\nsource\n\nDetailsJSON\n\n DetailsJSON (*args, summary:str='', open:bool=True, openall:bool=False,\n              skip:Sequence[str]=(), **kwargs)\n\nInteractive collapsible JSON viewer with HTML details/summary structure\n\nsource\n\n\nNameVal\n\n NameVal (k, v)\n\nRender key-value pair with name and value styling\n\nsource\n\n\nVal\n\n Val (v)\n\nRender value with appropriate CSS class based on type\n\ndtl = DetailsJSON({\n    '1': 'Neil Armstrong',\n    '2': 'Alan Bean',\n    '3': 'Buzz Aldrin',\n    'letters': {\n        'a': 1, \n        'b': 2\n        },\n    '5': 'Edgar Mitchell',\n    '6': 'Alan Shepard'\n}, summary='Apollo astronauts')\n\n# test_eq(val_at(dtl, '5'), 'Edgar Mitchell')\n# test_eq(val_at(dtl, 'letters.a'), 1)\n# cprint(to_xml(dtl))\nshow(dtl)\n\n\nApollo astronauts\n  \n    \n1: Neil Armstrong    \n    \n2: Alan Bean    \n    \n3: Buzz Aldrin    \nletters\n      \n        \na: 1        \n        \nb: 2        \n      \n    \n5: Edgar Mitchell    \n    \n6: Alan Shepard    \n  \n\n\n\n\nd= {\n    \"idx\": 1,\n    \"cell_type\": \"code\",\n    \"source\": \"# cell 1\\nprint('hello')\",\n    \"id\": \"W1sZmlsZQ==\",\n    \"metadata\": {\n        \"brd\": {\n            \"id\": \"717322f8-95fa-425c-839d-8b9e7d4ef921\"\n        }\n    },\n    \"outputs\": [\n        {'output_type': 'stream', 'name': 'stdout', 'text': '1\\n'},\n        {'output_type': 'stream', 'name': 'stdout', 'text': '2\\n'}\n    ],\n    \"execution_count\": 1\n}\nshow(DetailsJSON(d, openall=True))\n\n\nsummary\n  \n    \nidx: 1    \n    \ncell_type: code    \n    \nsource: # cell 1\nprint('hello')    \n    \nid: W1sZmlsZQ==    \nmetadata\n      \nbrd\n          \n            \nid: 717322f8-95fa-425c-839d-8b9e7d4ef921            \n          \n      \noutputs\n      \n0\n          \n            \noutput_type: stream            \n            \nname: stdout            \n            \ntext: 1\n            \n          \n1\n          \n            \noutput_type: stream            \n            \nname: stdout            \n            \ntext: 2\n            \n          \n      \n    \nexecution_count: 1    \n  \n\n\n\nConvenience IPython.display.HTML subclass that accepts fastcore.xml.FT object and adds the kwargs to metadata.\n\nsource\n\n\nHTML\n\n HTML (data=None, url=None, filename=None, metadata=None, **kwargs)\n\nCreate a text display object given raw data.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndata\nNoneType\nNone\nThe raw data or a URL or file to load the data from.\n\n\nurl\nNoneType\nNone\nA URL to download the data from.\n\n\nfilename\nNoneType\nNone\nPath to a local file to load the data from.\n\n\nmetadata\nNoneType\nNone\nDict of metadata associated to be the object when displayed\n\n\nkwargs\nVAR_KEYWORD",
    "crumbs": [
      "Core Components",
      "Helpers"
    ]
  },
  {
    "objectID": "logger.html",
    "href": "logger.html",
    "title": "Loggers",
    "section": "",
    "text": "Unified logging across JavaScript and Python for Bridget monitoring\n\nBridget operates across multiple contexts: browser (JS), kernel (Python), and extensions. This module provides a unified logging system that works identically in all environments.\nArchitecture: - Canvas: Abstraction of a display area (where to write) - Logger: Logging interface (what/how to write)\nBridget loggers write to Bridget canvases, allowing you to monitor all Bridget activity in a single notebook cell - no need to check browser console or configure Python logging separately.\nUsed throughout Bridget for debugging Bridge operations, state updates, and plugin activity.",
    "crumbs": [
      "Bridge",
      "Loggers"
    ]
  },
  {
    "objectID": "logger.html#dhcanvas",
    "href": "logger.html#dhcanvas",
    "title": "Loggers",
    "section": "DHCanvas",
    "text": "DHCanvas\n\nsource\n\nDhCanvas\n\n DhCanvas (height:int=200)\n\nCanvas using IPython DisplayHandle for dynamic updates\n\ncnv = DhCanvas(height=200)\n\n\ncnv.show(\"What's up, world!&lt;br&gt;\")\n\n\n\n\n\ncnv.add(\"Take me to your leader.&lt;br&gt;\")\n\n\ncnv.clear()\n\n\ncnv.add('&lt;b&gt;There and Back Again&lt;/b&gt;&lt;br&gt;')\n\n\ncnv.show()\n\n\nThere and Back Again\n\n\n\ncnv.add('')\n\n\ncnv.add('\\n')\n\n\ncnv.add('&lt;br&gt;')",
    "crumbs": [
      "Bridge",
      "Loggers"
    ]
  },
  {
    "objectID": "logger.html#fcanvas-kernel",
    "href": "logger.html#fcanvas-kernel",
    "title": "Loggers",
    "section": "FCanvas (kernel)",
    "text": "FCanvas (kernel)\n\nHTML element with a well-known id.\n\n\ndisplay(HTML(FCanvas_stl))\n\n\n\n\n\nclass FCanvas(Canvas, T.HasTraits):\n    height = T.Int(200).tag(sync=True)\n    elid = T.Unicode('').tag(sync=True)\n    def show(self, content=None, **kwargs):\n        prev_elid = self.elid\n        elid = new_id('brd-logger-')\n        s = content or ''\n        display(HTML(\n            f\"&lt;div id='{elid}' class='brd-logger' \"\n            f\"style='width: 100%; max-height: {self.height}px;'&gt;{(s+'&lt;br&gt;') if not prev_elid and s else ''}&lt;/div&gt;\"), \n            metadata=kwargs)\n        time.sleep(0.25)\n        self.elid = elid\n        if prev_elid: \n            display(Javascript(f\"\"\"\ndebugger;\nconst prevEl = document.getElementById('{prev_elid}');\nlet prevHtml = prevEl?.innerHTML ?? '';\nif (prevEl) prevEl.style.display = 'none';\nif (prevEl) prevEl.innerHTML = '';\n{self._el()}; if (el) {{ el.innerHTML = prevHtml + '{s.replace(\"'\", \"\\\\'\")}' + '&lt;br&gt;';\nel.scrollTop = el.scrollHeight;}}\n\"\"\"))\n    def hide(self): display(Javascript(f\"{self._el()} el.style.display = 'none'\"))\n    def add(self, content, **kwargs):\n        if content is not None: display(Javascript(self._js(str(content).replace(\"'\", \"\\\\'\"))))\n    def clear(self): display(Javascript(f\"{self._el()} el.innerHTML = ''\"))\n\n    def _el(self): return f\"const el=document.getElementById('{self.elid}')\"\n    def _js(self, s):\n        return f\"{self._el()}; if (el) {{el.innerHTML += '{s}'; el.scrollTop = el.scrollHeight;}}\"\n\n\ncnv = FCanvas(height=100)\n\n\ncnv.show()\n\n\n\n\n\nfor c in 'abcdefgehijk': cnv.add(f\"{c}&lt;br&gt;\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncnv.add(f'&lt;span class=\"ts\"&gt;1234567890&lt;/span&gt; &lt;span class=\"msg\"&gt;msg&lt;/span&gt;&lt;br&gt;')\n\n\n\n\n\ncnv.add(\"lorem ipsum dolor sit 'amet&lt;br&gt;\")\n\n\n\n\n\ncnv.show()\n\n\n\n\n\n\n\n\ncnv.add({\"a\": 1})\n\n\n\n\nThis is obviously ugly and unwieldy. We need a more usable canvas, one that doen’t rely in IPython display system.. The only solution in modern Jupyter envs is a widget.",
    "crumbs": [
      "Bridge",
      "Loggers"
    ]
  },
  {
    "objectID": "logger.html#fcanvas-widget",
    "href": "logger.html#fcanvas-widget",
    "title": "Loggers",
    "section": "FCanvas (widget)",
    "text": "FCanvas (widget)\n\nos.environ['DEBUG_BRIDGET'] = 'True'\n\n\nfcanvas_esm = bundled(fcanvas_js)(debugger=DEBUG(), ts=True)\n\n\nsource\n\nFCanvas\n\n FCanvas (height:int=200, elid:str='', **kwargs)\n\nMain AnyWidget base class.\n\ncleanupwidgets('cnv')\n\ncnv = FCanvas.create(height=100, timeout=3)\ntest_eq(cnv.loaded(), True)\n\n\ncnv.show('hello')\n# test_eq(cnv.displayed(), True)\n\n\n\n\n\ncnv.add(' bye&lt;br&gt;')\n\n\ncnv.clear()\n\n\ncnv.add('Goodbye to all that&lt;br&gt;')\n\n\ncnv.add({'a': str(Path('a'))})  # convert to json, no '&lt;br&gt;'\n\n\ncnv.add(f'&lt;br&gt;&lt;span class=\"ts\"&gt;1234567890&lt;/span&gt; &lt;span class=\"msg\"&gt;msg&lt;/span&gt;&lt;br&gt;')\n\n\ncnv.hide()\ncnv.add('hideous!&lt;br&gt;')\n\n\ncnv.show()\n\n\n\n\n\ncnv.close()\n\n\ncleanupwidgets('cnv')\n\ncnv = FCanvas.create(elid=FCanvas.new_elid())\ntest_eq(cnv.loaded(), True)\n\n\n\n\n\ncnv.add('Hi & Bi&lt;br&gt;')\n\n\ncnv.close()",
    "crumbs": [
      "Bridge",
      "Loggers"
    ]
  },
  {
    "objectID": "logger.html#basiclogger",
    "href": "logger.html#basiclogger",
    "title": "Loggers",
    "section": "BasicLogger",
    "text": "BasicLogger\n\nsource\n\nBasicLogger\n\n BasicLogger (msg=None, canvas:__main__.Canvas|None=None, height:int=200,\n              show:bool=True, history:bool=True, **kwargs)\n\nSimple logger that displays messages in a scrollable div\n\nbl = BasicLogger('BasicLogger initialized', height=100)\n\n\n\n\n\nfor i,x in enumerate(range(10)): bl.log(f'test{i}')\n\n\nbl.msg(f'''&lt;span style=\"color: red;\"&gt;{'red '*100}&lt;/span&gt;''')\n\n\nbl.history()[-1]\n\n'&lt;span style=\"color: red;\"&gt;red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red red &lt;/span&gt;'\n\n\nWrong HTML: the message is shortened with the HTML format\n\nbl.log('green '*100, fmt='&lt;span style=\"color: green;\"&gt;{s}&lt;/span&gt;&lt;br&gt;')\n\n\nbl.show()\n\n\n\n\n\nbl.active(False, 'BasicLogger disabled')\n\nFalse\n\n\n\nbl.error('test')\n\n\nbl.show(\"Enabled\")\n\nEnabledBasicLogger disabledgreen green green green green green green green green green green green green green green green green green green green green green green gr…red red red red red red red red red red red red red red red red red red red red red red red red red red red red re…test9test8test7test6test5test4test3test2test1test0BasicLogger initialized\n\n\n\nbl.close_canvas()\nbl.show()\nbl.log('closed')\ntest_eq(bl.active(), False)\n\nThis logger is closed.",
    "crumbs": [
      "Bridge",
      "Loggers"
    ]
  },
  {
    "objectID": "logger.html#flogger",
    "href": "logger.html#flogger",
    "title": "Loggers",
    "section": "FLogger",
    "text": "FLogger\n\nsource\n\nFLogger\n\n FLogger (msg=None, canvas:__main__.Canvas|None=None, height:int=200,\n          show:bool=True, history:bool=True, **kwargs)\n\nSimple logger that displays messages in a scrollable div\n\nbl = FLogger('FLogger initialized', FCanvas.create(height=100, elid=FCanvas.new_elid(), timeout=2))\n\n\n\n\n\nfor i,x in enumerate(range(5)): bl.log(f'test{i}')\n\n\nbl.error('red '*100, fmt=lambda s: f'&lt;span style=\"color: red;\"&gt;{s}&lt;/span&gt;')\n\n\nbl.show()\n\n\n\n\n\nbl.active(False, 'FLogger disabled')\n\nFalse\n\n\n\nbl.log('test')\n\n\nbl.close_canvas()\nbl.log('closed')\nbl.show()\ntest_eq(bl.active(), False)\n\nThis logger is closed.",
    "crumbs": [
      "Bridge",
      "Loggers"
    ]
  },
  {
    "objectID": "logger.html#loguru-logger-wip",
    "href": "logger.html#loguru-logger-wip",
    "title": "Loggers",
    "section": "Loguru logger (WIP)",
    "text": "Loguru logger (WIP)\n\nclass LoguruBasicLogger(BasicLogger):\n    def __init__(self): \n        super().__init__()\n        self._fmt = FC.noop\n    \n    def write(self, message: str) -&gt; None:\n        if rec := getattr(message, 'record', None):\n            level = rec['level'].name\n        else: \n            for level in level_colors: \n                if level in message: break\n        # message = f\"&lt;span style='color: {level_colors[level]}'&gt;{message}&lt;/span&gt;\"\n        # self.msg(message, fmt=lambda s:f\"&lt;span style='color: {level_colors[level]}'&gt;{s}&lt;/span&gt;\")\n        self.msg(message, fmt=f\"&lt;span style='color: {level_colors[level]}'&gt;\"\"{s}&lt;/span&gt;&lt;br&gt;\")\n\n\nlogger.remove()  # Remove default handler\nhandler_id = logger.add(\n    (lbl := LoguruBasicLogger()).write, \n    format=\"{level} | {message}\",  # Simple format, we'll add HTML in the sink\n    colorize=False  # Disable ANSI colors\n)\n\nERROR | This is an error\nWARNING | This is a warning\nINFO | This is an info message\nDEBUG | This is a debug message\n\n\n\n\nlogger.debug(\"This is a debug message\")\nlogger.info(\"This is an info message\")\nlogger.warning(\"This is a warning\")\nlogger.error(\"This is an error\")\n\n\nclass LoguruBasicLogger(BasicLogger):\n    def __init__(self):\n        super().__init__()\n        self.fmt = FC.noop\n    \n    def _format(self, msg, fmt: Callable[[str], str]|str|None=None, truncate:bool=True, sep:str='') -&gt; str:\n        rec = getattr(msg, 'record', json.loads(msg))\n        return (\n            f\"&lt;div style='display: flex; gap: 8px'&gt;\"\n            f\"&lt;span style='color: #888'&gt;{rec['time'].strftime('%H:%M:%S')}&lt;/span&gt;\"\n            f\"&lt;span style='color: {level_colors[rec['level'].name]}'&gt;{rec['level'].name:8}&lt;/span&gt;\"\n            f\"&lt;span&gt;{shorten(rec['message'], mode='r', limit=self.max_len or 140)}&lt;/span&gt;\"\n            f\"&lt;/div&gt;\"\n        )\n\n    def write(self, message:str) -&gt; None:\n        self.msg(message, sep='')\n        # self.msg(formatted_msg)\n    \n\ndef configure_logger(basic_logger: BasicLogger) -&gt; int:\n    \"\"\"Configure loguru to use a specific BasicLogger instance.\"\"\"\n    logger.remove()\n    return logger.add(\n        basic_logger.write,  # type: ignore\n        serialize=True  # This makes loguru pass a json to write()\n    )\n\n\nlbl = LoguruBasicLogger()\nhandler_id = configure_logger(lbl)\n\n15:13:32ERROR   This is an error15:13:32WARNING This is a warning15:13:32INFO    This is an info message15:13:32DEBUG   This is a debug message\n\n\n\nlogger.debug(\"This is a debug message\")\nlogger.info(\"This is an info message\")\nlogger.warning(\"This is a warning\")\nlogger.error(\"This is an error\")\n\n\n(my_logger := BasicLogger()).setup_loguru_sink(logger);  # type: ignore\n\n15:13:33.608834error   This is an error15:13:33.608047warning This is a warning15:13:33.607341info    This is an info message15:13:33.606536debug   This is a debug message\n\n\n\nlogger.debug(\"This is a debug message\")\nlogger.info(\"This is an info message\")\nlogger.warning(\"This is a warning\")\nlogger.error(\"This is an error\")\n\n\n(my_flogger := FLogger()).setup_loguru_sink(logger);  # type: ignore\n\n\n\n\n\nlogger.debug(\"This is a debug message\")\nlogger.info(\"This is an info message\")\nlogger.warning(\"This is a warning\")\nlogger.error(\"This is an error\")\n\n\nmy_flogger.close_canvas()",
    "crumbs": [
      "Bridge",
      "Loggers"
    ]
  },
  {
    "objectID": "bridget.html",
    "href": "bridget.html",
    "title": "Bridget",
    "section": "",
    "text": "Jupyter notebooks serve two primary functions: 1. Exploratory/Educational: Interactive computing and learning 2. Development: Literate programming and package creation (via nbdev)\nWhile code creation is well-served by various notebook environments (Jupyter, VSCode, Marimo, etc.), the display and interaction capabilities are often limited by IPython’s well-thought but basic and aging display system. Modern development requires:\n\nRich data visualization\nInteractive system integration\nBetter control over output rendering\n\n\n\nNotebooks already run in browsers (or browser-like environments), giving us access to powerful HTML/JavaScript capabilities. The front-end and kernel are inherently connected, suggesting we shouldn’t need additional communication layers.\nHowever, the notebook ecosystem is fragmented: - Jupyter (nbclassic, Notebook, Lab): ipywidgets - VSCode/Cursor: Extensions - Marimo: Custom solutions - Google Colab: Proprietary package\nThis fragmentation forces users needing better display solutions to deal with complex, environment-specific tooling.\n\n\n\nFastHTML provides an innovative approach to web apps, emphasizing HTML-first development through HTMX. While Jupyter support isn’t its core focus, FastHTML itself is developed using nbdev in notebooks.\nCurrent FastHTML notebook integration: - Launches a separate Uvicorn server - Connects HTMX via standard HTTP/AJAX - Works across most notebook variants\nThis approach is general, clean and lightweight but involves spawning a full HTTP server with: - Multi-user capabilities (unnecessary for notebooks) - Async architecture (notebooks are sync) - Complex lifecycle management - Production-level features (overkill for notebook use) - IPython Javascript display object in each cell to trigger HTMX.\n\n\n\nBridget proposes using a widget-based approach that: 1. Simplifies: Replaces HTTP server with direct widget communication 2. Generalizes: Works across notebook environments via AnyWidget 3. Extends: Enables creation of notebook-specific components 4. Integrates: Provides Python API for HTMX functionality\nThis proof-of-concept shows how we can maintain FastHTML’s powerful features while better adapting to the notebook environment’s unique characteristics and constraints.\n\n\n\n\n\n\nNote\n\n\n\nPersonal note: My interest here isn’t web apps, but notebook development.\nI like ipywidgets, or at least the intention. I’ve written several and used them in many personal projects. However, they’re a challenging piece of software with complicated tooling. They inherit all the nightmarish complexity of the JavaScript ecosystem, where the tooling is more involved than the language itself. AnyWidget is a step in the right direction, liberating us Pythonistas from the JS ecosystem. But the notebook part, the Python part, remains an unsolved problem in my opinion.\nOf all solutions I’ve explored for achieving full interactivity in notebooks, HTMX + FastHTML comes closest, feeling more natural and integrating better with the notebook environment.\n\n\n\n\nbridge_cfg.auto_show = True\nbridge_cfg.auto_id = True\n\nThese flags control automatic behaviors throughout this notebook. See 01_helpers.ipynb for full configuration options.",
    "crumbs": [
      "Bridget",
      "Bridget"
    ]
  },
  {
    "objectID": "bridget.html#why-bridget",
    "href": "bridget.html#why-bridget",
    "title": "Bridget",
    "section": "",
    "text": "Jupyter notebooks serve two primary functions: 1. Exploratory/Educational: Interactive computing and learning 2. Development: Literate programming and package creation (via nbdev)\nWhile code creation is well-served by various notebook environments (Jupyter, VSCode, Marimo, etc.), the display and interaction capabilities are often limited by IPython’s well-thought but basic and aging display system. Modern development requires:\n\nRich data visualization\nInteractive system integration\nBetter control over output rendering\n\n\n\nNotebooks already run in browsers (or browser-like environments), giving us access to powerful HTML/JavaScript capabilities. The front-end and kernel are inherently connected, suggesting we shouldn’t need additional communication layers.\nHowever, the notebook ecosystem is fragmented: - Jupyter (nbclassic, Notebook, Lab): ipywidgets - VSCode/Cursor: Extensions - Marimo: Custom solutions - Google Colab: Proprietary package\nThis fragmentation forces users needing better display solutions to deal with complex, environment-specific tooling.\n\n\n\nFastHTML provides an innovative approach to web apps, emphasizing HTML-first development through HTMX. While Jupyter support isn’t its core focus, FastHTML itself is developed using nbdev in notebooks.\nCurrent FastHTML notebook integration: - Launches a separate Uvicorn server - Connects HTMX via standard HTTP/AJAX - Works across most notebook variants\nThis approach is general, clean and lightweight but involves spawning a full HTTP server with: - Multi-user capabilities (unnecessary for notebooks) - Async architecture (notebooks are sync) - Complex lifecycle management - Production-level features (overkill for notebook use) - IPython Javascript display object in each cell to trigger HTMX.\n\n\n\nBridget proposes using a widget-based approach that: 1. Simplifies: Replaces HTTP server with direct widget communication 2. Generalizes: Works across notebook environments via AnyWidget 3. Extends: Enables creation of notebook-specific components 4. Integrates: Provides Python API for HTMX functionality\nThis proof-of-concept shows how we can maintain FastHTML’s powerful features while better adapting to the notebook environment’s unique characteristics and constraints.\n\n\n\n\n\n\nNote\n\n\n\nPersonal note: My interest here isn’t web apps, but notebook development.\nI like ipywidgets, or at least the intention. I’ve written several and used them in many personal projects. However, they’re a challenging piece of software with complicated tooling. They inherit all the nightmarish complexity of the JavaScript ecosystem, where the tooling is more involved than the language itself. AnyWidget is a step in the right direction, liberating us Pythonistas from the JS ecosystem. But the notebook part, the Python part, remains an unsolved problem in my opinion.\nOf all solutions I’ve explored for achieving full interactivity in notebooks, HTMX + FastHTML comes closest, feeling more natural and integrating better with the notebook environment.\n\n\n\n\nbridge_cfg.auto_show = True\nbridge_cfg.auto_id = True\n\nThese flags control automatic behaviors throughout this notebook. See 01_helpers.ipynb for full configuration options.",
    "crumbs": [
      "Bridget",
      "Bridget"
    ]
  },
  {
    "objectID": "bridget.html#clientp",
    "href": "bridget.html#clientp",
    "title": "Bridget",
    "section": "ClientP",
    "text": "ClientP\n\nsource\n\nClientP\n\n ClientP (*args, **kwargs)\n\nHTTP client interface supporting REST operations (get, post, delete)",
    "crumbs": [
      "Bridget",
      "Bridget"
    ]
  },
  {
    "objectID": "bridget.html#bridget-utils",
    "href": "bridget.html#bridget-utils",
    "title": "Bridget",
    "section": "Bridget utils",
    "text": "Bridget utils\n\nsource\n\nrequest2httpx_request\n\n request2httpx_request (cli:httpx.AsyncClient,\n                        http_request:dict[str,typing.Any])\n\nConvert bridget request dict to httpx Request object\n\nsource\n\n\nhttpx_response_to_json\n\n httpx_response_to_json (response:httpx.Response)\n\nConvert httpx Response to JSON dict with headers and content\n\nsource\n\n\nrequest2response\n\n request2response (cli:httpx.AsyncClient, http_request)\n\nExecute bridget request and return httpx Response\n\nsource\n\n\nHasHTML\n\n HasHTML (*args, **kwargs)\n\nObjects that can render themselves as HTML strings\n\nsource\n\n\nHasFT\n\n HasFT (*args, **kwargs)\n\nObjects that can convert themselves to FastHTML FT components\n\n@FC.patch\ndef _ipython_display_(self: Response):\n    # dhdl = DisplayId()\n    # dhdl.display(self.text)\n    IDISPLAY(HTML(self.text))",
    "crumbs": [
      "Bridget",
      "Bridget"
    ]
  },
  {
    "objectID": "bridget.html#bridget-javascript-implementation-bridget.js",
    "href": "bridget.html#bridget-javascript-implementation-bridget.js",
    "title": "Bridget",
    "section": "Bridget JavaScript Implementation bridget.js",
    "text": "Bridget JavaScript Implementation bridget.js\nBridget’s JavaScript code provides the browser-side implementation that: 1. Intercepts HTMX AJAX requests (SSE, WS in the future) 2. Routes them through the widget’s communication channel 3. Processes responses back to HTMX 4. Manages HTMX initialization in notebook output cells\n\nSome details\n\nRequest Flow\n\nHTMX makes an AJAX request\nxhook intercepts it via on_request\nRequest is serialized and sent to kernel via traitlets\nKernel processes request and sends response\nResponse is processed by response_changed\nHTMX receives response and updates DOM\n\n\n\nHTMX Integration\n\nBridgetObserver watches for new notebook output cells\nNew cells are processed with htmx.process()\nHTMX attributes become active\nAJAX requests are intercepted and routed through widget\n\nNote that Bridget JS is backend agnostic. We’re using FastHTML here because its the best for my quest of replacing ipywidgets as the main form of interactivity in a notebook, but it could be any other backend libarary.",
    "crumbs": [
      "Bridget",
      "Bridget"
    ]
  },
  {
    "objectID": "vscode_extension_README.html",
    "href": "vscode_extension_README.html",
    "title": "nbinspect-vscode: VSCode State Inspector for Bridget",
    "section": "",
    "text": "nbinspect-vscode is the companion VSCode and Cursor extension for the Bridget project. It integrates with the VSCode notebook interface to monitor a notebook’s state in real-time and makes that information available to front-end JavaScript components.\n\n\nThe extension runs a monitoring process in the VSCode extension host that listens for all notebook events (cell changes, execution, etc.). It intelligently batches these events and sends them to a custom notebook renderer. This renderer, running in a sandboxed webview, creates a window.$Nb object that acts as a bridge, allowing Bridget’s anywidget components to access the live notebook state.\n\n\n\nThis extension is designed to be installed manually as part of the main bridget repository. Please follow the installation instructions in the main project’s README file.\nYou can find the installable nbinspect-*.vsix file in this directory. To install, open the Extensions view (Ctrl+Shift+X) in VSCode/Cursor, click the “…” menu, and select “Install from VSIX…”.\n\n\n\nnbinspect-vscode is a package within the bridget pnpm monorepo. To contribute, you will need NodeJS and the pnpm package manager.\n\n\nFrom the bridget repository root, run pnpm install to install all JavaScript dependencies for the monorepo, including those for this package.\n# In the Bridget root directory\npnpm install\n\n\n\nFor the best development experience, including debugging and integrated tasks, we recommend opening the packages/nbinspect-vscode folder directly in a new VSCode window.\nYou can then create a .vscode directory inside this folder with the following configuration files.\n\n\nThis file configures the debugger. Pressing F5 will launch a new “Extension Development Host” window with the extension running, allowing you to test changes and use the debugger.\n// .vscode/launch.json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Run nbinspect-vscode\",\n      \"type\": \"extensionHost\",\n      \"request\": \"launch\",\n      \"args\": [\n        \"--extensionDevelopmentPath=${workspaceFolder}\"\n      ],\n      \"outFiles\": [\n        \"${workspaceFolder}/dist/**/*.js\"\n      ],\n      \"debugWebviews\": true,\n      \"sourceMaps\": true\n    }\n  ]\n}\n\n\n\nThis file sets up a background task to automatically recompile the extension when you save a file. The launch.json configuration will run this task automatically when you start debugging.\n// .vscode/tasks.json\n{\n  \"version\": \"2.0.0\",\n  \"tasks\": [\n    {\n      \"label\": \"pnpm: watch\",\n      \"type\": \"npm\",\n      \"script\": \"watch\",\n      \"group\": {\n        \"kind\": \"build\",\n        \"isDefault\": true\n      },\n      \"problemMatcher\": \"$esbuild-watch\",\n      \"isBackground\": true,\n      \"presentation\": {\n        \"reveal\": \"never\"\n      }\n    }\n  ]\n}\n\n\n\n\nTo create a new .vsix package for distribution:\n\nBuild the extension:\n# From this directory (packages/nbinspect-vscode):\npnpm compile\nCreate the package:\n# Install vsce globally if you haven't already\nnpm install -g @vscode/vsce\n\n# Package the extension\npnpm version patch\nvsce package\n\nThis will create a nbinspect-*.vsix file in the current directory that can be installed in VSCode/Cursor."
  },
  {
    "objectID": "vscode_extension_README.html#how-it-works",
    "href": "vscode_extension_README.html#how-it-works",
    "title": "nbinspect-vscode: VSCode State Inspector for Bridget",
    "section": "",
    "text": "The extension runs a monitoring process in the VSCode extension host that listens for all notebook events (cell changes, execution, etc.). It intelligently batches these events and sends them to a custom notebook renderer. This renderer, running in a sandboxed webview, creates a window.$Nb object that acts as a bridge, allowing Bridget’s anywidget components to access the live notebook state."
  },
  {
    "objectID": "vscode_extension_README.html#installation",
    "href": "vscode_extension_README.html#installation",
    "title": "nbinspect-vscode: VSCode State Inspector for Bridget",
    "section": "",
    "text": "This extension is designed to be installed manually as part of the main bridget repository. Please follow the installation instructions in the main project’s README file.\nYou can find the installable nbinspect-*.vsix file in this directory. To install, open the Extensions view (Ctrl+Shift+X) in VSCode/Cursor, click the “…” menu, and select “Install from VSIX…”."
  },
  {
    "objectID": "vscode_extension_README.html#development",
    "href": "vscode_extension_README.html#development",
    "title": "nbinspect-vscode: VSCode State Inspector for Bridget",
    "section": "",
    "text": "nbinspect-vscode is a package within the bridget pnpm monorepo. To contribute, you will need NodeJS and the pnpm package manager.\n\n\nFrom the bridget repository root, run pnpm install to install all JavaScript dependencies for the monorepo, including those for this package.\n# In the Bridget root directory\npnpm install\n\n\n\nFor the best development experience, including debugging and integrated tasks, we recommend opening the packages/nbinspect-vscode folder directly in a new VSCode window.\nYou can then create a .vscode directory inside this folder with the following configuration files.\n\n\nThis file configures the debugger. Pressing F5 will launch a new “Extension Development Host” window with the extension running, allowing you to test changes and use the debugger.\n// .vscode/launch.json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Run nbinspect-vscode\",\n      \"type\": \"extensionHost\",\n      \"request\": \"launch\",\n      \"args\": [\n        \"--extensionDevelopmentPath=${workspaceFolder}\"\n      ],\n      \"outFiles\": [\n        \"${workspaceFolder}/dist/**/*.js\"\n      ],\n      \"debugWebviews\": true,\n      \"sourceMaps\": true\n    }\n  ]\n}\n\n\n\nThis file sets up a background task to automatically recompile the extension when you save a file. The launch.json configuration will run this task automatically when you start debugging.\n// .vscode/tasks.json\n{\n  \"version\": \"2.0.0\",\n  \"tasks\": [\n    {\n      \"label\": \"pnpm: watch\",\n      \"type\": \"npm\",\n      \"script\": \"watch\",\n      \"group\": {\n        \"kind\": \"build\",\n        \"isDefault\": true\n      },\n      \"problemMatcher\": \"$esbuild-watch\",\n      \"isBackground\": true,\n      \"presentation\": {\n        \"reveal\": \"never\"\n      }\n    }\n  ]\n}\n\n\n\n\nTo create a new .vsix package for distribution:\n\nBuild the extension:\n# From this directory (packages/nbinspect-vscode):\npnpm compile\nCreate the package:\n# Install vsce globally if you haven't already\nnpm install -g @vscode/vsce\n\n# Package the extension\npnpm version patch\nvsce package\n\nThis will create a nbinspect-*.vsix file in the current directory that can be installed in VSCode/Cursor."
  },
  {
    "objectID": "jstransform.html",
    "href": "jstransform.html",
    "title": "Javascript import transform",
    "section": "",
    "text": "JS_LANGUAGE = Language(tsjs.language())\nJS_LANGUAGE.field_count\n\n36\n\n\n\nparser = Parser(JS_LANGUAGE)\nparser.language\n\n&lt;Language id=4765155344, version=15, name=\"javascript\"&gt;\n\n\n\n\n\ntree = parser.parse(b'''\nimport x from \"foo\";\n'''\n)\n\n\nroot_node = tree.root_node\nassert root_node.type == 'program'\nassert root_node.start_point == (1, 0)\nassert root_node.end_point == (2, 0)\nroot_node\n\n&lt;Node type=program, start_point=(1, 0), end_point=(2, 0)&gt;\n\n\n\nimport_statement = root_node.children[0]\nassert import_statement.type == 'import_statement'\nassert import_statement.start_point == (1, 0)\nassert import_statement.end_point == (1, 20)\nimport_statement\n\n&lt;Node type=import_statement, start_point=(1, 0), end_point=(1, 20)&gt;\n\n\n\nimport_statement.children\n\n[&lt;Node type=\"import\", start_point=(1, 0), end_point=(1, 6)&gt;,\n &lt;Node type=import_clause, start_point=(1, 7), end_point=(1, 8)&gt;,\n &lt;Node type=\"from\", start_point=(1, 9), end_point=(1, 13)&gt;,\n &lt;Node type=string, start_point=(1, 14), end_point=(1, 19)&gt;,\n &lt;Node type=\";\", start_point=(1, 19), end_point=(1, 20)&gt;]\n\n\n\nassert len(import_statement.children) == 5\nassert import_statement.children[0].type == 'import'\nassert import_statement.children[1].type == 'import_clause'\nassert import_statement.children[2].type == 'from'\nassert import_statement.children[3].type == 'string'\nassert import_statement.children[4].type == ';'\n\n\nassert import_statement.children[0].text == b'import'\nassert import_statement.children[1].text == b'x'\nassert import_statement.children[2].text == b'from'\nassert import_statement.children[3].text == b'\"foo\"'\nassert import_statement.children[4].text == b';'\n\n\ncode = b'''\nimport x from \"foo\";\nconst y = await import(\"bar\");\nconsole.log(\"hello\");\n'''\n\ntree = parser.parse(code)\nroot = tree.root_node\n\ndef walk(node, code):\n    if node.type == \"import_statement\":\n        print(\"Static import:\", code[node.start_byte:node.end_byte].decode())\n    elif node.type == \"call_expression\":\n        # detect dynamic import\n        func = node.child_by_field_name(\"function\")\n        if func and func.type == \"import\":\n            print(\"Dynamic import:\", code[node.start_byte:node.end_byte].decode())\n    for child in node.children:\n        walk(child, code)\n\nwalk(root, code)\n\nStatic import: import x from \"foo\";\nDynamic import: import(\"bar\")\n\n\n\n\n\nWrite a Python function that detects static ES6 import declarations and rewrites them into equivalent dynamic import() statements as per the below mapping. Background:\n\nES6 import declarations (static) are converted at parse time and can use default imports, named imports, namespace imports, etc.\nDynamic import() always returns a module namespace object (a Promise), so to access default or named exports, you must destructure or access properties after the promise resolves.\nDefault import: import x from \"mod\"; Translates to: const {default: x} = await import(\"mod\");\nNamed import: import {a, b} from \"mod\"; Translates to: const {a, b} = await import(\"mod\");\nNamespace import: import * as foo from \"mod\"; Translates to: const foo = await import(\"mod\");\nSide-effect only: import \"mod\"; Translates to: await import(\"mod\");\nNote: await can only be used at top level in modules or inside async functions.\n\nReference:\n\nMDN: import() - module namespace object\n\n\n\n\n\n\n\n\n\n\n\nStatic Import\nDynamic Import Equivalent\n\n\n\n\nimport x from \"mod\";\nconst {default: x} = await import(\"mod\");\n\n\nimport {a, b} from \"mod\";\nconst {a, b} = await import(\"mod\");\n\n\nimport * as foo from \"mod\";\nconst foo = await import(\"mod\");\n\n\nimport \"mod\";\nawait import(\"mod\");\n\n\n\nLet’s see what tree-sitter gives us for the above examples.\n\ndef show_tree(tree):\n    def walk(node, depth=0):\n        print('  '*depth + f\"{node.type}\")\n        for child in node.children:\n            walk(child, depth+1)\n    walk(tree.root_node)\n\n\ndef traverse_tree(node: Tree|Node) -&gt; Generator[Node, None, None]:\n    cursor = node.walk()\n    visited_children = False\n    while True:\n        if not visited_children:\n            yield cursor.node  # type: ignore\n            if not cursor.goto_first_child():\n                visited_children = True\n        elif cursor.goto_next_sibling():\n            visited_children = False\n        elif not cursor.goto_parent():\n            break\n\n\nexamples = [\n    b'import x from \"foo\";',\n    b'import {a, b as c} from \"bar\";',\n    b'import * as ns from \"baz\";',\n    b'import x, {a, b as c} from \"mod\";',\n    b'import \"sidefx\";'\n]\n\nfor code in examples:\n    print(f\"code: '{code.decode()}'\")\n    tree = parser.parse(code)\n    show_tree(tree)\n    print('----')\n\ncode: 'import x from \"foo\";'\nprogram\n  import_statement\n    import\n    import_clause\n      identifier\n    from\n    string\n      \"\n      string_fragment\n      \"\n    ;\n----\ncode: 'import {a, b as c} from \"bar\";'\nprogram\n  import_statement\n    import\n    import_clause\n      named_imports\n        {\n        import_specifier\n          identifier\n        ,\n        import_specifier\n          identifier\n          as\n          identifier\n        }\n    from\n    string\n      \"\n      string_fragment\n      \"\n    ;\n----\ncode: 'import * as ns from \"baz\";'\nprogram\n  import_statement\n    import\n    import_clause\n      namespace_import\n        *\n        as\n        identifier\n    from\n    string\n      \"\n      string_fragment\n      \"\n    ;\n----\ncode: 'import x, {a, b as c} from \"mod\";'\nprogram\n  import_statement\n    import\n    import_clause\n      identifier\n      ,\n      named_imports\n        {\n        import_specifier\n          identifier\n        ,\n        import_specifier\n          identifier\n          as\n          identifier\n        }\n    from\n    string\n      \"\n      string_fragment\n      \"\n    ;\n----\ncode: 'import \"sidefx\";'\nprogram\n  import_statement\n    import\n    string\n      \"\n      string_fragment\n      \"\n    ;\n----\n\n\n\n\n\nLet’s first extract all static imports, parse their structure, and print what their dynamic import replacement would be.\n\ndef extract_string_content(string_node):\n    # The string node contains quotes and string_fragment\n    fragments = []\n    for child in string_node.children:\n        if child.type == 'string_fragment':\n            fragments.append(child.text.decode())\n    return ''.join(fragments)\n\ndef extract_import_specifiers(named_imports_node):\n    specifiers = []\n    for child in named_imports_node.children:\n        if child.type == 'import_specifier':\n            # Could be: identifier OR identifier 'as' identifier\n            if len(child.children) == 1:\n                # Simple: {a}\n                name = child.children[0].text.decode()\n                specifiers.append({'imported': name, 'local': name})\n            elif len(child.children) == 3:\n                # Aliased: {a as b}\n                imported = child.children[0].text.decode()\n                local = child.children[2].text.decode()\n                specifiers.append({'imported': imported, 'local': local})\n    return specifiers\n\ndef parse_import_statement(import_node, code):\n    result = {\n        'type': 'import_statement',\n        'source': None,\n        'default_import': None,\n        'named_imports': [],\n        'namespace_import': None,\n        'side_effect_only': False,\n        'has_mixed_default_namespace': False,\n        'original_text': code[import_node.start_byte:import_node.end_byte].decode()\n    }\n    \n    # Find the source (module path)\n    for child in import_node.children:\n        if child.type == 'string':\n            result['source'] = extract_string_content(child)\n            break\n    \n    # Check if it's side-effect only (no import_clause)\n    import_clause = None\n    for child in import_node.children:\n        if child.type == 'import_clause':\n            import_clause = child\n            break\n    \n    if import_clause is None:\n        result['side_effect_only'] = True\n        return result\n    \n    # Parse import_clause - need to handle mixed default + namespace\n    has_default = False\n    has_namespace = False\n    \n    for child in import_clause.children:\n        if child.type == 'identifier':\n            # Default import\n            result['default_import'] = child.text.decode()\n            has_default = True\n        elif child.type == 'named_imports':\n            # Named imports: {a, b as c}\n            result['named_imports'] = extract_import_specifiers(child)\n        elif child.type == 'namespace_import':\n            # Namespace import: * as ns\n            has_namespace = True\n            # Find the identifier after 'as'\n            for ns_child in child.children:\n                if ns_child.type == 'identifier':\n                    result['namespace_import'] = ns_child.text.decode()\n        # Skip commas\n    \n    # Check for mixed default + namespace\n    if has_default and has_namespace:\n        result['has_mixed_default_namespace'] = True\n    \n    return result\n\ndef generate_dynamic_import(import_data, fn='import'):\n    source = import_data['source']\n    \n    if import_data['side_effect_only']:\n        return f'await {fn}(\"{source}\");'\n    \n    # Handle mixed default + namespace case\n    if import_data['has_mixed_default_namespace']:\n        ns_name = import_data['namespace_import']\n        default_name = import_data['default_import']\n        return f'const {ns_name} = await {fn}(\"{source}\");\\nconst {default_name} = {ns_name}.default;'\n    \n    # Handle pure namespace import\n    if import_data['namespace_import'] and not import_data['default_import']:\n        return f'const {import_data[\"namespace_import\"]} = await {fn}(\"{source}\");'\n    \n    # Build destructuring pattern for default and/or named imports\n    destructure_parts = []\n    \n    # Add default import\n    if import_data['default_import']:\n        destructure_parts.append(f'default: {import_data[\"default_import\"]}')\n    \n    # Add named imports\n    for spec in import_data['named_imports']:\n        if spec['imported'] == spec['local']:\n            destructure_parts.append(spec['imported'])\n        else:\n            destructure_parts.append(f'{spec[\"imported\"]}: {spec[\"local\"]}')\n    \n    if destructure_parts:\n        destructure = '{' + ', '.join(destructure_parts) + '}'\n        return f'const {destructure} = await {fn}(\"{source}\");'\n    \n    # Fallback (shouldn't happen)\n    return f'await {fn}(\"{source}\");'\n\ndef transform_imports(code, fn='import'):\n    tree = parser.parse(code)\n    imports = []\n    \n    def walk(node):\n        if node.type == 'import_statement':\n            import_data = parse_import_statement(node, code)\n            dynamic_equivalent = generate_dynamic_import(import_data, fn)\n            imports.append({\n                'original': import_data['original_text'],\n                'transformed': dynamic_equivalent,\n                'data': import_data\n            })\n        \n        for child in node.children:\n            walk(child)\n    \n    walk(tree.root_node)\n    return imports\n\n\nexamples = [\n    b'import x from \"foo\";',  # default import\n    b'import {a, b as c} from \"bar\";',  # named import\n    b'import * as ns from \"baz\";',  # namespace import\n    b'import x, {a, b as c} from \"mod\";',  # mixed default + named import\n    b'import \"sidefx\";',  # side-effect only\n    b'import defaultExport, * as name from \"module-name\";',  # mixed default + namespace import\n]\n\nprint(\"=== IMPORT TRANSFORMATION RESULTS ===\\n\")\n\nfor code in examples:\n    print(f\"Original: {code.decode()}\")\n    transformations = transform_imports(code)\n    for t in transformations:\n        print(f\"Dynamic:  {t['transformed']}\")\n        print(f\"Data:     {t['data']}\")\n    print(\"---\")\n\n=== IMPORT TRANSFORMATION RESULTS ===\n\nOriginal: import x from \"foo\";\nDynamic:  const {default: x} = await import(\"foo\");\nData:     {'type': 'import_statement', 'source': 'foo', 'default_import': 'x', 'named_imports': [], 'namespace_import': None, 'side_effect_only': False, 'has_mixed_default_namespace': False, 'original_text': 'import x from \"foo\";'}\n---\nOriginal: import {a, b as c} from \"bar\";\nDynamic:  const {a, b: c} = await import(\"bar\");\nData:     {'type': 'import_statement', 'source': 'bar', 'default_import': None, 'named_imports': [{'imported': 'a', 'local': 'a'}, {'imported': 'b', 'local': 'c'}], 'namespace_import': None, 'side_effect_only': False, 'has_mixed_default_namespace': False, 'original_text': 'import {a, b as c} from \"bar\";'}\n---\nOriginal: import * as ns from \"baz\";\nDynamic:  const ns = await import(\"baz\");\nData:     {'type': 'import_statement', 'source': 'baz', 'default_import': None, 'named_imports': [], 'namespace_import': 'ns', 'side_effect_only': False, 'has_mixed_default_namespace': False, 'original_text': 'import * as ns from \"baz\";'}\n---\nOriginal: import x, {a, b as c} from \"mod\";\nDynamic:  const {default: x, a, b: c} = await import(\"mod\");\nData:     {'type': 'import_statement', 'source': 'mod', 'default_import': 'x', 'named_imports': [{'imported': 'a', 'local': 'a'}, {'imported': 'b', 'local': 'c'}], 'namespace_import': None, 'side_effect_only': False, 'has_mixed_default_namespace': False, 'original_text': 'import x, {a, b as c} from \"mod\";'}\n---\nOriginal: import \"sidefx\";\nDynamic:  await import(\"sidefx\");\nData:     {'type': 'import_statement', 'source': 'sidefx', 'default_import': None, 'named_imports': [], 'namespace_import': None, 'side_effect_only': True, 'has_mixed_default_namespace': False, 'original_text': 'import \"sidefx\";'}\n---\nOriginal: import defaultExport, * as name from \"module-name\";\nDynamic:  const name = await import(\"module-name\");\nconst defaultExport = name.default;\nData:     {'type': 'import_statement', 'source': 'module-name', 'default_import': 'defaultExport', 'named_imports': [], 'namespace_import': 'name', 'side_effect_only': False, 'has_mixed_default_namespace': True, 'original_text': 'import defaultExport, * as name from \"module-name\";'}\n---\n\n\n\ndef transform_js_source(code_bytes):\n    \"Transform JavaScript source code, replacing import statements with dynamic imports.\"\n    if isinstance(code_bytes, str):\n        code_bytes = code_bytes.encode('utf-8')\n    \n    tree = parser.parse(code_bytes)\n    imports_with_positions = []\n    \n    def find_imports(node):\n        if node.type == 'import_statement':\n            import_data = parse_import_statement(node, code_bytes)\n            dynamic_equivalent = generate_dynamic_import(import_data)\n            \n            imports_with_positions.append({\n                'start_byte': node.start_byte,\n                'end_byte': node.end_byte,\n                'original': import_data['original_text'],\n                'replacement': dynamic_equivalent,\n                'data': import_data\n            })\n        \n        for child in node.children:\n            find_imports(child)\n    \n    find_imports(tree.root_node)\n    \n    # Sort by start_byte in descending order (work backwards)\n    imports_with_positions.sort(key=lambda x: x['start_byte'], reverse=True)\n    \n    # Start with the original code\n    result = code_bytes\n    \n    # Replace each import statement working backwards\n    for import_info in imports_with_positions:\n        start = import_info['start_byte']\n        end = import_info['end_byte']\n        replacement = import_info['replacement'].encode('utf-8')\n        \n        # Replace the import statement\n        result = result[:start] + replacement + result[end:]\n    \n    return result.decode('utf-8')\n\n\njs_code = '''\nimport x from \"foo\";\nimport {a, b as c} from \"bar\";\nimport * as ns from \"baz\";\nimport x, {a, b as c} from \"mod\";\nimport \"sidefx\";\nimport defaultExport, * as name from \"module-name\";\n\nconsole.log(\"Hello, world!\");\nconst myVar = 42;\n\nfunction doSomething() {\n    return x + a + ns.something;\n}\n\nexport { doSomething };\n'''\n\nprint(\"=== ORIGINAL CODE ===\")\ndisplay(Markdown(f\"```js\\n{js_code}\\n```\"))\nprint(\"\\n=== TRANSFORMED CODE ===\")\ntransformed = transform_js_source(js_code)\ndisplay(Markdown(f\"```js\\n{transformed}\\n```\"))\n\n=== ORIGINAL CODE ===\n\n\n\nimport x from \"foo\";\nimport {a, b as c} from \"bar\";\nimport * as ns from \"baz\";\nimport x, {a, b as c} from \"mod\";\nimport \"sidefx\";\nimport defaultExport, * as name from \"module-name\";\n\nconsole.log(\"Hello, world!\");\nconst myVar = 42;\n\nfunction doSomething() {\n    return x + a + ns.something;\n}\n\nexport { doSomething };\n\n\n\n=== TRANSFORMED CODE ===\n\n\n\nconst {default: x} = await import(\"foo\");\nconst {a, b: c} = await import(\"bar\");\nconst ns = await import(\"baz\");\nconst {default: x, a, b: c} = await import(\"mod\");\nawait import(\"sidefx\");\nconst name = await import(\"module-name\");\nconst defaultExport = name.default;\n\nconsole.log(\"Hello, world!\");\nconst myVar = 42;\n\nfunction doSomething() {\n    return x + a + ns.something;\n}\n\nexport { doSomething };\n\n\n\ndef transform_js_source_with_details(code_bytes):\n    \"Transform JavaScript source and return both result and transformation details.\"\n    if isinstance(code_bytes, str):\n        code_bytes = code_bytes.encode('utf-8')\n    \n    tree = parser.parse(code_bytes)\n    imports_with_positions = []\n    \n    def find_imports(node):\n        if node.type == 'import_statement':\n            import_data = parse_import_statement(node, code_bytes)\n            dynamic_equivalent = generate_dynamic_import(import_data)\n            \n            imports_with_positions.append({\n                'start_byte': node.start_byte,\n                'end_byte': node.end_byte,\n                'original': import_data['original_text'],\n                'replacement': dynamic_equivalent,\n                'data': import_data\n            })\n        \n        for child in node.children:\n            find_imports(child)\n    \n    find_imports(tree.root_node)\n    \n    # Sort by start_byte in descending order (work backwards)\n    imports_with_positions.sort(key=lambda x: x['start_byte'], reverse=True)\n    \n    # Start with the original code\n    result = code_bytes\n    \n    # Replace each import statement working backwards\n    for import_info in imports_with_positions:\n        start = import_info['start_byte']\n        end = import_info['end_byte']\n        replacement = import_info['replacement'].encode('utf-8')\n        \n        # Replace the import statement\n        result = result[:start] + replacement + result[end:]\n    \n    return {\n        'transformed_code': result.decode('utf-8'),\n        'transformations': imports_with_positions,\n        'original_code': code_bytes.decode('utf-8')\n    }\n\n\n# Test with details\nresult = transform_js_source_with_details(js_code)\n\nprint(\"=== TRANSFORMATION DETAILS ===\")\nfor i, t in enumerate(result['transformations']):\n    print(f\"Transform {i+1}:\")\n    print(f\"  Original:  {t['original']}\")\n    print(f\"  Becomes:   {t['replacement']}\")\n    print(f\"  Position:  {t['start_byte']}-{t['end_byte']}\")\n    print()\n\nprint(\"=== FINAL RESULT ===\")\ndisplay(Markdown(f\"```js\\n{result['transformed_code']}\\n```\"))\n\n=== TRANSFORMATION DETAILS ===\nTransform 1:\n  Original:  import defaultExport, * as name from \"module-name\";\n  Becomes:   const name = await import(\"module-name\");\nconst defaultExport = name.default;\n  Position:  131-182\n\nTransform 2:\n  Original:  import \"sidefx\";\n  Becomes:   await import(\"sidefx\");\n  Position:  114-130\n\nTransform 3:\n  Original:  import x, {a, b as c} from \"mod\";\n  Becomes:   const {default: x, a, b: c} = await import(\"mod\");\n  Position:  80-113\n\nTransform 4:\n  Original:  import * as ns from \"baz\";\n  Becomes:   const ns = await import(\"baz\");\n  Position:  53-79\n\nTransform 5:\n  Original:  import {a, b as c} from \"bar\";\n  Becomes:   const {a, b: c} = await import(\"bar\");\n  Position:  22-52\n\nTransform 6:\n  Original:  import x from \"foo\";\n  Becomes:   const {default: x} = await import(\"foo\");\n  Position:  1-21\n\n=== FINAL RESULT ===\n\n\n\nconst {default: x} = await import(\"foo\");\nconst {a, b: c} = await import(\"bar\");\nconst ns = await import(\"baz\");\nconst {default: x, a, b: c} = await import(\"mod\");\nawait import(\"sidefx\");\nconst name = await import(\"module-name\");\nconst defaultExport = name.default;\n\nconsole.log(\"Hello, world!\");\nconst myVar = 42;\n\nfunction doSomething() {\n    return x + a + ns.something;\n}\n\nexport { doSomething };\n\n\n\ndef find_dynamic_imports(node, code_bytes):\n    \"Find all dynamic import call expressions in the AST.\"\n    dynamic_imports = []\n    \n    def walk(node):\n        if node.type == \"call_expression\":\n            # Check if this is a dynamic import call\n            func = node.child_by_field_name(\"function\")\n            if func and func.type == \"import\":\n                dynamic_imports.append({\n                    'start_byte': func.start_byte,\n                    'end_byte': func.end_byte,\n                    'full_start_byte': node.start_byte,\n                    'full_end_byte': node.end_byte,\n                    'original_call': code_bytes[node.start_byte:node.end_byte].decode(),\n                    'original_function': func.text.decode()\n                })\n        \n        for child in node.children:\n            walk(child)\n    \n    walk(node)\n    return dynamic_imports\n\ndef transform_dynamic_imports(code_bytes, new_function_name=\"import\"):\n    \"\"\"Transform dynamic import calls to use a different function name.\"\"\"\n    if isinstance(code_bytes, str):\n        code_bytes = code_bytes.encode('utf-8')\n    \n    tree = parser.parse(code_bytes)\n    dynamic_imports = find_dynamic_imports(tree.root_node, code_bytes)\n    \n    # Sort by start_byte in descending order (work backwards)\n    dynamic_imports.sort(key=lambda x: x['start_byte'], reverse=True)\n    \n    # Start with the original code\n    result = code_bytes\n    \n    # Replace each dynamic import function name working backwards\n    for import_info in dynamic_imports:\n        start = import_info['start_byte']\n        end = import_info['end_byte']\n        replacement = new_function_name.encode('utf-8')\n        \n        # Replace just the function name\n        result = result[:start] + replacement + result[end:]\n    \n    return result.decode('utf-8')\n\n\ntest_dynamic_code = '''\n// Static imports (these should be ignored by dynamic transformer)\nimport x from \"foo\";\nimport {a, b} from \"bar\";\n\n// Dynamic imports (these should be transformed)\nawait import(\"/modules/my-module.js\");\nconst { default: myDefault, foo, bar } = await import(\"/modules/my-module.js\");\nconst module = await import(\"./utils.js\");\nimport(\"./lazy-module.js\").then(m =&gt; console.log(m));\n\n// Other code\nconsole.log(\"Hello world\");\n'''\n\nprint(\"=== DYNAMIC IMPORT DETECTION ===\")\ntree = parser.parse(test_dynamic_code.encode('utf-8'))\ndynamic_imports = find_dynamic_imports(tree.root_node, test_dynamic_code.encode('utf-8'))\n\nfor i, di in enumerate(dynamic_imports):\n    print(f\"Dynamic import {i+1}:\")\n    print(f\"  Full call: {di['original_call']}\")\n    print(f\"  Function:  {di['original_function']}\")\n    print(f\"  Position:  {di['start_byte']}-{di['end_byte']}\")\n    print()\n\nprint(\"=== DYNAMIC IMPORT TRANSFORMATION ===\")\nprint(\"Original:\")\ndisplay(Markdown(f\"```js\\n{test_dynamic_code}\\n```\"))\nprint(\"\\nTransformed (import -&gt; AAAA):\")\ntransformed_dynamic = transform_dynamic_imports(test_dynamic_code, \"AAAA\")\ndisplay(Markdown(f\"```js\\n{transformed_dynamic}\\n```\"))\n\n=== DYNAMIC IMPORT DETECTION ===\nDynamic import 1:\n  Full call: import(\"/modules/my-module.js\")\n  Function:  import\n  Position:  171-177\n\nDynamic import 2:\n  Full call: import(\"/modules/my-module.js\")\n  Function:  import\n  Position:  251-257\n\nDynamic import 3:\n  Full call: import(\"./utils.js\")\n  Function:  import\n  Position:  305-311\n\nDynamic import 4:\n  Full call: import(\"./lazy-module.js\")\n  Function:  import\n  Position:  327-333\n\n=== DYNAMIC IMPORT TRANSFORMATION ===\nOriginal:\n\n\n\n// Static imports (these should be ignored by dynamic transformer)\nimport x from \"foo\";\nimport {a, b} from \"bar\";\n\n// Dynamic imports (these should be transformed)\nawait import(\"/modules/my-module.js\");\nconst { default: myDefault, foo, bar } = await import(\"/modules/my-module.js\");\nconst module = await import(\"./utils.js\");\nimport(\"./lazy-module.js\").then(m =&gt; console.log(m));\n\n// Other code\nconsole.log(\"Hello world\");\n\n\n\nTransformed (import -&gt; AAAA):\n\n\n\n// Static imports (these should be ignored by dynamic transformer)\nimport x from \"foo\";\nimport {a, b} from \"bar\";\n\n// Dynamic imports (these should be transformed)\nawait AAAA(\"/modules/my-module.js\");\nconst { default: myDefault, foo, bar } = await AAAA(\"/modules/my-module.js\");\nconst module = await AAAA(\"./utils.js\");\nAAAA(\"./lazy-module.js\").then(m =&gt; console.log(m));\n\n// Other code\nconsole.log(\"Hello world\");\n\n\n\ndef transform_all_imports(code_bytes, new_function_name=\"import\"):\n    \"\"\"Transform both static and dynamic imports.\"\"\"\n    if isinstance(code_bytes, str):\n        code_bytes = code_bytes.encode('utf-8')\n    \n    # First transform static imports to dynamic imports\n    result = transform_js_source(code_bytes)\n    \n    # Then transform all dynamic imports (including the newly created ones)\n    result = transform_dynamic_imports(result, new_function_name)\n    \n    return result\n\n\ncombined_test_code = '''\nimport x from \"foo\";\nimport {a, b as c} from \"bar\";\nimport * as ns from \"baz\";\nimport \"sidefx\";\n\nconst { default: existing } = await import(\"./existing2.js\");\n\nconsole.log(\"Hello, world!\");\nconst myVar = 42;\n\nasync function doSomething() {\n    const existingDynamic = await import(\"./existing.js\");\n    return x + a + ns.something;\n}\n\nexport { doSomething };\n'''\n\nprint(\"=== COMBINED TRANSFORMATION ===\")\nprint(\"Original:\")\ndisplay(Markdown(f\"```js\\n{combined_test_code}\\n```\"))\nprint(\"\\nAfter transforming to AAAA:\")\nfinal_result = transform_all_imports(combined_test_code, \"AAAA\")\ndisplay(Markdown(f\"```js\\n{final_result}\\n```\"))\n\n=== COMBINED TRANSFORMATION ===\nOriginal:\n\n\n\nimport x from \"foo\";\nimport {a, b as c} from \"bar\";\nimport * as ns from \"baz\";\nimport \"sidefx\";\n\nconst { default: existing } = await import(\"./existing2.js\");\n\nconsole.log(\"Hello, world!\");\nconst myVar = 42;\n\nasync function doSomething() {\n    const existingDynamic = await import(\"./existing.js\");\n    return x + a + ns.something;\n}\n\nexport { doSomething };\n\n\n\nAfter transforming to AAAA:\n\n\n\nconst {default: x} = await AAAA(\"foo\");\nconst {a, b: c} = await AAAA(\"bar\");\nconst ns = await AAAA(\"baz\");\nawait AAAA(\"sidefx\");\n\nconst { default: existing } = await AAAA(\"./existing2.js\");\n\nconsole.log(\"Hello, world!\");\nconst myVar = 42;\n\nasync function doSomething() {\n    const existingDynamic = await AAAA(\"./existing.js\");\n    return x + a + ns.something;\n}\n\nexport { doSomething };\n\n\n\ndef transform_all_imports_with_details(code_bytes, new_function_name=\"import\"):\n    \"Transform both static and dynamic imports with detailed reporting.\"\n    if isinstance(code_bytes, str):\n        code_bytes = code_bytes.encode('utf-8')\n    \n    original_code = code_bytes.decode('utf-8')\n    \n    # Step 1: Transform static imports to dynamic imports\n    static_result = transform_js_source_with_details(code_bytes)\n    \n    # Step 2: Transform all dynamic imports (including newly created ones)\n    after_static = static_result['transformed_code']\n    tree = parser.parse(after_static.encode('utf-8'))\n    dynamic_imports = find_dynamic_imports(tree.root_node, after_static.encode('utf-8'))\n    \n    # Transform dynamic imports\n    final_code = transform_dynamic_imports(after_static, new_function_name)\n    \n    return {\n        'original_code': original_code,\n        'after_static_transform': after_static,\n        'final_code': final_code,\n        'static_transformations': static_result['transformations'],\n        'dynamic_transformations': dynamic_imports,\n        'new_function_name': new_function_name\n    }\n\n\ndetailed_result = transform_all_imports_with_details(combined_test_code, \"AAAA\")\n\nprint(\"=== DETAILED TRANSFORMATION REPORT ===\")\nprint(f\"Target function name: {detailed_result['new_function_name']}\")\nprint(f\"\\nStatic imports found: {len(detailed_result['static_transformations'])}\")\nfor i, t in enumerate(detailed_result['static_transformations']):\n    print(f\"  {i+1}. {t['original']} -&gt; {t['replacement']}\")\n\nprint(f\"\\nDynamic imports found: {len(detailed_result['dynamic_transformations'])}\")\nfor i, t in enumerate(detailed_result['dynamic_transformations']):\n    print(f\"  {i+1}. {t['original_call']}\")\n\nprint(f\"\\n=== FINAL RESULT ===\")\nprint(detailed_result['final_code'])\n\n=== DETAILED TRANSFORMATION REPORT ===\nTarget function name: AAAA\n\nStatic imports found: 4\n  1. import \"sidefx\"; -&gt; await import(\"sidefx\");\n  2. import * as ns from \"baz\"; -&gt; const ns = await import(\"baz\");\n  3. import {a, b as c} from \"bar\"; -&gt; const {a, b: c} = await import(\"bar\");\n  4. import x from \"foo\"; -&gt; const {default: x} = await import(\"foo\");\n\nDynamic imports found: 6\n  1. import(\"foo\")\n  2. import(\"bar\")\n  3. import(\"baz\")\n  4. import(\"sidefx\")\n  5. import(\"./existing2.js\")\n  6. import(\"./existing.js\")\n\n=== FINAL RESULT ===\n\nconst {default: x} = await AAAA(\"foo\");\nconst {a, b: c} = await AAAA(\"bar\");\nconst ns = await AAAA(\"baz\");\nawait AAAA(\"sidefx\");\n\nconst { default: existing } = await AAAA(\"./existing2.js\");\n\nconsole.log(\"Hello, world!\");\nconst myVar = 42;\n\nasync function doSomething() {\n    const existingDynamic = await AAAA(\"./existing.js\");\n    return x + a + ns.something;\n}\n\nexport { doSomething };",
    "crumbs": [
      "Core Components",
      "Javascript import transform"
    ]
  },
  {
    "objectID": "jstransform.html#import",
    "href": "jstransform.html#import",
    "title": "Javascript import transform",
    "section": "",
    "text": "tree = parser.parse(b'''\nimport x from \"foo\";\n'''\n)\n\n\nroot_node = tree.root_node\nassert root_node.type == 'program'\nassert root_node.start_point == (1, 0)\nassert root_node.end_point == (2, 0)\nroot_node\n\n&lt;Node type=program, start_point=(1, 0), end_point=(2, 0)&gt;\n\n\n\nimport_statement = root_node.children[0]\nassert import_statement.type == 'import_statement'\nassert import_statement.start_point == (1, 0)\nassert import_statement.end_point == (1, 20)\nimport_statement\n\n&lt;Node type=import_statement, start_point=(1, 0), end_point=(1, 20)&gt;\n\n\n\nimport_statement.children\n\n[&lt;Node type=\"import\", start_point=(1, 0), end_point=(1, 6)&gt;,\n &lt;Node type=import_clause, start_point=(1, 7), end_point=(1, 8)&gt;,\n &lt;Node type=\"from\", start_point=(1, 9), end_point=(1, 13)&gt;,\n &lt;Node type=string, start_point=(1, 14), end_point=(1, 19)&gt;,\n &lt;Node type=\";\", start_point=(1, 19), end_point=(1, 20)&gt;]\n\n\n\nassert len(import_statement.children) == 5\nassert import_statement.children[0].type == 'import'\nassert import_statement.children[1].type == 'import_clause'\nassert import_statement.children[2].type == 'from'\nassert import_statement.children[3].type == 'string'\nassert import_statement.children[4].type == ';'\n\n\nassert import_statement.children[0].text == b'import'\nassert import_statement.children[1].text == b'x'\nassert import_statement.children[2].text == b'from'\nassert import_statement.children[3].text == b'\"foo\"'\nassert import_statement.children[4].text == b';'\n\n\ncode = b'''\nimport x from \"foo\";\nconst y = await import(\"bar\");\nconsole.log(\"hello\");\n'''\n\ntree = parser.parse(code)\nroot = tree.root_node\n\ndef walk(node, code):\n    if node.type == \"import_statement\":\n        print(\"Static import:\", code[node.start_byte:node.end_byte].decode())\n    elif node.type == \"call_expression\":\n        # detect dynamic import\n        func = node.child_by_field_name(\"function\")\n        if func and func.type == \"import\":\n            print(\"Dynamic import:\", code[node.start_byte:node.end_byte].decode())\n    for child in node.children:\n        walk(child, code)\n\nwalk(root, code)\n\nStatic import: import x from \"foo\";\nDynamic import: import(\"bar\")",
    "crumbs": [
      "Core Components",
      "Javascript import transform"
    ]
  },
  {
    "objectID": "jstransform.html#transform",
    "href": "jstransform.html#transform",
    "title": "Javascript import transform",
    "section": "",
    "text": "Write a Python function that detects static ES6 import declarations and rewrites them into equivalent dynamic import() statements as per the below mapping. Background:\n\nES6 import declarations (static) are converted at parse time and can use default imports, named imports, namespace imports, etc.\nDynamic import() always returns a module namespace object (a Promise), so to access default or named exports, you must destructure or access properties after the promise resolves.\nDefault import: import x from \"mod\"; Translates to: const {default: x} = await import(\"mod\");\nNamed import: import {a, b} from \"mod\"; Translates to: const {a, b} = await import(\"mod\");\nNamespace import: import * as foo from \"mod\"; Translates to: const foo = await import(\"mod\");\nSide-effect only: import \"mod\"; Translates to: await import(\"mod\");\nNote: await can only be used at top level in modules or inside async functions.\n\nReference:\n\nMDN: import() - module namespace object\n\n\n\n\n\n\n\n\n\n\n\nStatic Import\nDynamic Import Equivalent\n\n\n\n\nimport x from \"mod\";\nconst {default: x} = await import(\"mod\");\n\n\nimport {a, b} from \"mod\";\nconst {a, b} = await import(\"mod\");\n\n\nimport * as foo from \"mod\";\nconst foo = await import(\"mod\");\n\n\nimport \"mod\";\nawait import(\"mod\");\n\n\n\nLet’s see what tree-sitter gives us for the above examples.\n\ndef show_tree(tree):\n    def walk(node, depth=0):\n        print('  '*depth + f\"{node.type}\")\n        for child in node.children:\n            walk(child, depth+1)\n    walk(tree.root_node)\n\n\ndef traverse_tree(node: Tree|Node) -&gt; Generator[Node, None, None]:\n    cursor = node.walk()\n    visited_children = False\n    while True:\n        if not visited_children:\n            yield cursor.node  # type: ignore\n            if not cursor.goto_first_child():\n                visited_children = True\n        elif cursor.goto_next_sibling():\n            visited_children = False\n        elif not cursor.goto_parent():\n            break\n\n\nexamples = [\n    b'import x from \"foo\";',\n    b'import {a, b as c} from \"bar\";',\n    b'import * as ns from \"baz\";',\n    b'import x, {a, b as c} from \"mod\";',\n    b'import \"sidefx\";'\n]\n\nfor code in examples:\n    print(f\"code: '{code.decode()}'\")\n    tree = parser.parse(code)\n    show_tree(tree)\n    print('----')\n\ncode: 'import x from \"foo\";'\nprogram\n  import_statement\n    import\n    import_clause\n      identifier\n    from\n    string\n      \"\n      string_fragment\n      \"\n    ;\n----\ncode: 'import {a, b as c} from \"bar\";'\nprogram\n  import_statement\n    import\n    import_clause\n      named_imports\n        {\n        import_specifier\n          identifier\n        ,\n        import_specifier\n          identifier\n          as\n          identifier\n        }\n    from\n    string\n      \"\n      string_fragment\n      \"\n    ;\n----\ncode: 'import * as ns from \"baz\";'\nprogram\n  import_statement\n    import\n    import_clause\n      namespace_import\n        *\n        as\n        identifier\n    from\n    string\n      \"\n      string_fragment\n      \"\n    ;\n----\ncode: 'import x, {a, b as c} from \"mod\";'\nprogram\n  import_statement\n    import\n    import_clause\n      identifier\n      ,\n      named_imports\n        {\n        import_specifier\n          identifier\n        ,\n        import_specifier\n          identifier\n          as\n          identifier\n        }\n    from\n    string\n      \"\n      string_fragment\n      \"\n    ;\n----\ncode: 'import \"sidefx\";'\nprogram\n  import_statement\n    import\n    string\n      \"\n      string_fragment\n      \"\n    ;\n----\n\n\n\n\n\nLet’s first extract all static imports, parse their structure, and print what their dynamic import replacement would be.\n\ndef extract_string_content(string_node):\n    # The string node contains quotes and string_fragment\n    fragments = []\n    for child in string_node.children:\n        if child.type == 'string_fragment':\n            fragments.append(child.text.decode())\n    return ''.join(fragments)\n\ndef extract_import_specifiers(named_imports_node):\n    specifiers = []\n    for child in named_imports_node.children:\n        if child.type == 'import_specifier':\n            # Could be: identifier OR identifier 'as' identifier\n            if len(child.children) == 1:\n                # Simple: {a}\n                name = child.children[0].text.decode()\n                specifiers.append({'imported': name, 'local': name})\n            elif len(child.children) == 3:\n                # Aliased: {a as b}\n                imported = child.children[0].text.decode()\n                local = child.children[2].text.decode()\n                specifiers.append({'imported': imported, 'local': local})\n    return specifiers\n\ndef parse_import_statement(import_node, code):\n    result = {\n        'type': 'import_statement',\n        'source': None,\n        'default_import': None,\n        'named_imports': [],\n        'namespace_import': None,\n        'side_effect_only': False,\n        'has_mixed_default_namespace': False,\n        'original_text': code[import_node.start_byte:import_node.end_byte].decode()\n    }\n    \n    # Find the source (module path)\n    for child in import_node.children:\n        if child.type == 'string':\n            result['source'] = extract_string_content(child)\n            break\n    \n    # Check if it's side-effect only (no import_clause)\n    import_clause = None\n    for child in import_node.children:\n        if child.type == 'import_clause':\n            import_clause = child\n            break\n    \n    if import_clause is None:\n        result['side_effect_only'] = True\n        return result\n    \n    # Parse import_clause - need to handle mixed default + namespace\n    has_default = False\n    has_namespace = False\n    \n    for child in import_clause.children:\n        if child.type == 'identifier':\n            # Default import\n            result['default_import'] = child.text.decode()\n            has_default = True\n        elif child.type == 'named_imports':\n            # Named imports: {a, b as c}\n            result['named_imports'] = extract_import_specifiers(child)\n        elif child.type == 'namespace_import':\n            # Namespace import: * as ns\n            has_namespace = True\n            # Find the identifier after 'as'\n            for ns_child in child.children:\n                if ns_child.type == 'identifier':\n                    result['namespace_import'] = ns_child.text.decode()\n        # Skip commas\n    \n    # Check for mixed default + namespace\n    if has_default and has_namespace:\n        result['has_mixed_default_namespace'] = True\n    \n    return result\n\ndef generate_dynamic_import(import_data, fn='import'):\n    source = import_data['source']\n    \n    if import_data['side_effect_only']:\n        return f'await {fn}(\"{source}\");'\n    \n    # Handle mixed default + namespace case\n    if import_data['has_mixed_default_namespace']:\n        ns_name = import_data['namespace_import']\n        default_name = import_data['default_import']\n        return f'const {ns_name} = await {fn}(\"{source}\");\\nconst {default_name} = {ns_name}.default;'\n    \n    # Handle pure namespace import\n    if import_data['namespace_import'] and not import_data['default_import']:\n        return f'const {import_data[\"namespace_import\"]} = await {fn}(\"{source}\");'\n    \n    # Build destructuring pattern for default and/or named imports\n    destructure_parts = []\n    \n    # Add default import\n    if import_data['default_import']:\n        destructure_parts.append(f'default: {import_data[\"default_import\"]}')\n    \n    # Add named imports\n    for spec in import_data['named_imports']:\n        if spec['imported'] == spec['local']:\n            destructure_parts.append(spec['imported'])\n        else:\n            destructure_parts.append(f'{spec[\"imported\"]}: {spec[\"local\"]}')\n    \n    if destructure_parts:\n        destructure = '{' + ', '.join(destructure_parts) + '}'\n        return f'const {destructure} = await {fn}(\"{source}\");'\n    \n    # Fallback (shouldn't happen)\n    return f'await {fn}(\"{source}\");'\n\ndef transform_imports(code, fn='import'):\n    tree = parser.parse(code)\n    imports = []\n    \n    def walk(node):\n        if node.type == 'import_statement':\n            import_data = parse_import_statement(node, code)\n            dynamic_equivalent = generate_dynamic_import(import_data, fn)\n            imports.append({\n                'original': import_data['original_text'],\n                'transformed': dynamic_equivalent,\n                'data': import_data\n            })\n        \n        for child in node.children:\n            walk(child)\n    \n    walk(tree.root_node)\n    return imports\n\n\nexamples = [\n    b'import x from \"foo\";',  # default import\n    b'import {a, b as c} from \"bar\";',  # named import\n    b'import * as ns from \"baz\";',  # namespace import\n    b'import x, {a, b as c} from \"mod\";',  # mixed default + named import\n    b'import \"sidefx\";',  # side-effect only\n    b'import defaultExport, * as name from \"module-name\";',  # mixed default + namespace import\n]\n\nprint(\"=== IMPORT TRANSFORMATION RESULTS ===\\n\")\n\nfor code in examples:\n    print(f\"Original: {code.decode()}\")\n    transformations = transform_imports(code)\n    for t in transformations:\n        print(f\"Dynamic:  {t['transformed']}\")\n        print(f\"Data:     {t['data']}\")\n    print(\"---\")\n\n=== IMPORT TRANSFORMATION RESULTS ===\n\nOriginal: import x from \"foo\";\nDynamic:  const {default: x} = await import(\"foo\");\nData:     {'type': 'import_statement', 'source': 'foo', 'default_import': 'x', 'named_imports': [], 'namespace_import': None, 'side_effect_only': False, 'has_mixed_default_namespace': False, 'original_text': 'import x from \"foo\";'}\n---\nOriginal: import {a, b as c} from \"bar\";\nDynamic:  const {a, b: c} = await import(\"bar\");\nData:     {'type': 'import_statement', 'source': 'bar', 'default_import': None, 'named_imports': [{'imported': 'a', 'local': 'a'}, {'imported': 'b', 'local': 'c'}], 'namespace_import': None, 'side_effect_only': False, 'has_mixed_default_namespace': False, 'original_text': 'import {a, b as c} from \"bar\";'}\n---\nOriginal: import * as ns from \"baz\";\nDynamic:  const ns = await import(\"baz\");\nData:     {'type': 'import_statement', 'source': 'baz', 'default_import': None, 'named_imports': [], 'namespace_import': 'ns', 'side_effect_only': False, 'has_mixed_default_namespace': False, 'original_text': 'import * as ns from \"baz\";'}\n---\nOriginal: import x, {a, b as c} from \"mod\";\nDynamic:  const {default: x, a, b: c} = await import(\"mod\");\nData:     {'type': 'import_statement', 'source': 'mod', 'default_import': 'x', 'named_imports': [{'imported': 'a', 'local': 'a'}, {'imported': 'b', 'local': 'c'}], 'namespace_import': None, 'side_effect_only': False, 'has_mixed_default_namespace': False, 'original_text': 'import x, {a, b as c} from \"mod\";'}\n---\nOriginal: import \"sidefx\";\nDynamic:  await import(\"sidefx\");\nData:     {'type': 'import_statement', 'source': 'sidefx', 'default_import': None, 'named_imports': [], 'namespace_import': None, 'side_effect_only': True, 'has_mixed_default_namespace': False, 'original_text': 'import \"sidefx\";'}\n---\nOriginal: import defaultExport, * as name from \"module-name\";\nDynamic:  const name = await import(\"module-name\");\nconst defaultExport = name.default;\nData:     {'type': 'import_statement', 'source': 'module-name', 'default_import': 'defaultExport', 'named_imports': [], 'namespace_import': 'name', 'side_effect_only': False, 'has_mixed_default_namespace': True, 'original_text': 'import defaultExport, * as name from \"module-name\";'}\n---\n\n\n\ndef transform_js_source(code_bytes):\n    \"Transform JavaScript source code, replacing import statements with dynamic imports.\"\n    if isinstance(code_bytes, str):\n        code_bytes = code_bytes.encode('utf-8')\n    \n    tree = parser.parse(code_bytes)\n    imports_with_positions = []\n    \n    def find_imports(node):\n        if node.type == 'import_statement':\n            import_data = parse_import_statement(node, code_bytes)\n            dynamic_equivalent = generate_dynamic_import(import_data)\n            \n            imports_with_positions.append({\n                'start_byte': node.start_byte,\n                'end_byte': node.end_byte,\n                'original': import_data['original_text'],\n                'replacement': dynamic_equivalent,\n                'data': import_data\n            })\n        \n        for child in node.children:\n            find_imports(child)\n    \n    find_imports(tree.root_node)\n    \n    # Sort by start_byte in descending order (work backwards)\n    imports_with_positions.sort(key=lambda x: x['start_byte'], reverse=True)\n    \n    # Start with the original code\n    result = code_bytes\n    \n    # Replace each import statement working backwards\n    for import_info in imports_with_positions:\n        start = import_info['start_byte']\n        end = import_info['end_byte']\n        replacement = import_info['replacement'].encode('utf-8')\n        \n        # Replace the import statement\n        result = result[:start] + replacement + result[end:]\n    \n    return result.decode('utf-8')\n\n\njs_code = '''\nimport x from \"foo\";\nimport {a, b as c} from \"bar\";\nimport * as ns from \"baz\";\nimport x, {a, b as c} from \"mod\";\nimport \"sidefx\";\nimport defaultExport, * as name from \"module-name\";\n\nconsole.log(\"Hello, world!\");\nconst myVar = 42;\n\nfunction doSomething() {\n    return x + a + ns.something;\n}\n\nexport { doSomething };\n'''\n\nprint(\"=== ORIGINAL CODE ===\")\ndisplay(Markdown(f\"```js\\n{js_code}\\n```\"))\nprint(\"\\n=== TRANSFORMED CODE ===\")\ntransformed = transform_js_source(js_code)\ndisplay(Markdown(f\"```js\\n{transformed}\\n```\"))\n\n=== ORIGINAL CODE ===\n\n\n\nimport x from \"foo\";\nimport {a, b as c} from \"bar\";\nimport * as ns from \"baz\";\nimport x, {a, b as c} from \"mod\";\nimport \"sidefx\";\nimport defaultExport, * as name from \"module-name\";\n\nconsole.log(\"Hello, world!\");\nconst myVar = 42;\n\nfunction doSomething() {\n    return x + a + ns.something;\n}\n\nexport { doSomething };\n\n\n\n=== TRANSFORMED CODE ===\n\n\n\nconst {default: x} = await import(\"foo\");\nconst {a, b: c} = await import(\"bar\");\nconst ns = await import(\"baz\");\nconst {default: x, a, b: c} = await import(\"mod\");\nawait import(\"sidefx\");\nconst name = await import(\"module-name\");\nconst defaultExport = name.default;\n\nconsole.log(\"Hello, world!\");\nconst myVar = 42;\n\nfunction doSomething() {\n    return x + a + ns.something;\n}\n\nexport { doSomething };\n\n\n\ndef transform_js_source_with_details(code_bytes):\n    \"Transform JavaScript source and return both result and transformation details.\"\n    if isinstance(code_bytes, str):\n        code_bytes = code_bytes.encode('utf-8')\n    \n    tree = parser.parse(code_bytes)\n    imports_with_positions = []\n    \n    def find_imports(node):\n        if node.type == 'import_statement':\n            import_data = parse_import_statement(node, code_bytes)\n            dynamic_equivalent = generate_dynamic_import(import_data)\n            \n            imports_with_positions.append({\n                'start_byte': node.start_byte,\n                'end_byte': node.end_byte,\n                'original': import_data['original_text'],\n                'replacement': dynamic_equivalent,\n                'data': import_data\n            })\n        \n        for child in node.children:\n            find_imports(child)\n    \n    find_imports(tree.root_node)\n    \n    # Sort by start_byte in descending order (work backwards)\n    imports_with_positions.sort(key=lambda x: x['start_byte'], reverse=True)\n    \n    # Start with the original code\n    result = code_bytes\n    \n    # Replace each import statement working backwards\n    for import_info in imports_with_positions:\n        start = import_info['start_byte']\n        end = import_info['end_byte']\n        replacement = import_info['replacement'].encode('utf-8')\n        \n        # Replace the import statement\n        result = result[:start] + replacement + result[end:]\n    \n    return {\n        'transformed_code': result.decode('utf-8'),\n        'transformations': imports_with_positions,\n        'original_code': code_bytes.decode('utf-8')\n    }\n\n\n# Test with details\nresult = transform_js_source_with_details(js_code)\n\nprint(\"=== TRANSFORMATION DETAILS ===\")\nfor i, t in enumerate(result['transformations']):\n    print(f\"Transform {i+1}:\")\n    print(f\"  Original:  {t['original']}\")\n    print(f\"  Becomes:   {t['replacement']}\")\n    print(f\"  Position:  {t['start_byte']}-{t['end_byte']}\")\n    print()\n\nprint(\"=== FINAL RESULT ===\")\ndisplay(Markdown(f\"```js\\n{result['transformed_code']}\\n```\"))\n\n=== TRANSFORMATION DETAILS ===\nTransform 1:\n  Original:  import defaultExport, * as name from \"module-name\";\n  Becomes:   const name = await import(\"module-name\");\nconst defaultExport = name.default;\n  Position:  131-182\n\nTransform 2:\n  Original:  import \"sidefx\";\n  Becomes:   await import(\"sidefx\");\n  Position:  114-130\n\nTransform 3:\n  Original:  import x, {a, b as c} from \"mod\";\n  Becomes:   const {default: x, a, b: c} = await import(\"mod\");\n  Position:  80-113\n\nTransform 4:\n  Original:  import * as ns from \"baz\";\n  Becomes:   const ns = await import(\"baz\");\n  Position:  53-79\n\nTransform 5:\n  Original:  import {a, b as c} from \"bar\";\n  Becomes:   const {a, b: c} = await import(\"bar\");\n  Position:  22-52\n\nTransform 6:\n  Original:  import x from \"foo\";\n  Becomes:   const {default: x} = await import(\"foo\");\n  Position:  1-21\n\n=== FINAL RESULT ===\n\n\n\nconst {default: x} = await import(\"foo\");\nconst {a, b: c} = await import(\"bar\");\nconst ns = await import(\"baz\");\nconst {default: x, a, b: c} = await import(\"mod\");\nawait import(\"sidefx\");\nconst name = await import(\"module-name\");\nconst defaultExport = name.default;\n\nconsole.log(\"Hello, world!\");\nconst myVar = 42;\n\nfunction doSomething() {\n    return x + a + ns.something;\n}\n\nexport { doSomething };\n\n\n\ndef find_dynamic_imports(node, code_bytes):\n    \"Find all dynamic import call expressions in the AST.\"\n    dynamic_imports = []\n    \n    def walk(node):\n        if node.type == \"call_expression\":\n            # Check if this is a dynamic import call\n            func = node.child_by_field_name(\"function\")\n            if func and func.type == \"import\":\n                dynamic_imports.append({\n                    'start_byte': func.start_byte,\n                    'end_byte': func.end_byte,\n                    'full_start_byte': node.start_byte,\n                    'full_end_byte': node.end_byte,\n                    'original_call': code_bytes[node.start_byte:node.end_byte].decode(),\n                    'original_function': func.text.decode()\n                })\n        \n        for child in node.children:\n            walk(child)\n    \n    walk(node)\n    return dynamic_imports\n\ndef transform_dynamic_imports(code_bytes, new_function_name=\"import\"):\n    \"\"\"Transform dynamic import calls to use a different function name.\"\"\"\n    if isinstance(code_bytes, str):\n        code_bytes = code_bytes.encode('utf-8')\n    \n    tree = parser.parse(code_bytes)\n    dynamic_imports = find_dynamic_imports(tree.root_node, code_bytes)\n    \n    # Sort by start_byte in descending order (work backwards)\n    dynamic_imports.sort(key=lambda x: x['start_byte'], reverse=True)\n    \n    # Start with the original code\n    result = code_bytes\n    \n    # Replace each dynamic import function name working backwards\n    for import_info in dynamic_imports:\n        start = import_info['start_byte']\n        end = import_info['end_byte']\n        replacement = new_function_name.encode('utf-8')\n        \n        # Replace just the function name\n        result = result[:start] + replacement + result[end:]\n    \n    return result.decode('utf-8')\n\n\ntest_dynamic_code = '''\n// Static imports (these should be ignored by dynamic transformer)\nimport x from \"foo\";\nimport {a, b} from \"bar\";\n\n// Dynamic imports (these should be transformed)\nawait import(\"/modules/my-module.js\");\nconst { default: myDefault, foo, bar } = await import(\"/modules/my-module.js\");\nconst module = await import(\"./utils.js\");\nimport(\"./lazy-module.js\").then(m =&gt; console.log(m));\n\n// Other code\nconsole.log(\"Hello world\");\n'''\n\nprint(\"=== DYNAMIC IMPORT DETECTION ===\")\ntree = parser.parse(test_dynamic_code.encode('utf-8'))\ndynamic_imports = find_dynamic_imports(tree.root_node, test_dynamic_code.encode('utf-8'))\n\nfor i, di in enumerate(dynamic_imports):\n    print(f\"Dynamic import {i+1}:\")\n    print(f\"  Full call: {di['original_call']}\")\n    print(f\"  Function:  {di['original_function']}\")\n    print(f\"  Position:  {di['start_byte']}-{di['end_byte']}\")\n    print()\n\nprint(\"=== DYNAMIC IMPORT TRANSFORMATION ===\")\nprint(\"Original:\")\ndisplay(Markdown(f\"```js\\n{test_dynamic_code}\\n```\"))\nprint(\"\\nTransformed (import -&gt; AAAA):\")\ntransformed_dynamic = transform_dynamic_imports(test_dynamic_code, \"AAAA\")\ndisplay(Markdown(f\"```js\\n{transformed_dynamic}\\n```\"))\n\n=== DYNAMIC IMPORT DETECTION ===\nDynamic import 1:\n  Full call: import(\"/modules/my-module.js\")\n  Function:  import\n  Position:  171-177\n\nDynamic import 2:\n  Full call: import(\"/modules/my-module.js\")\n  Function:  import\n  Position:  251-257\n\nDynamic import 3:\n  Full call: import(\"./utils.js\")\n  Function:  import\n  Position:  305-311\n\nDynamic import 4:\n  Full call: import(\"./lazy-module.js\")\n  Function:  import\n  Position:  327-333\n\n=== DYNAMIC IMPORT TRANSFORMATION ===\nOriginal:\n\n\n\n// Static imports (these should be ignored by dynamic transformer)\nimport x from \"foo\";\nimport {a, b} from \"bar\";\n\n// Dynamic imports (these should be transformed)\nawait import(\"/modules/my-module.js\");\nconst { default: myDefault, foo, bar } = await import(\"/modules/my-module.js\");\nconst module = await import(\"./utils.js\");\nimport(\"./lazy-module.js\").then(m =&gt; console.log(m));\n\n// Other code\nconsole.log(\"Hello world\");\n\n\n\nTransformed (import -&gt; AAAA):\n\n\n\n// Static imports (these should be ignored by dynamic transformer)\nimport x from \"foo\";\nimport {a, b} from \"bar\";\n\n// Dynamic imports (these should be transformed)\nawait AAAA(\"/modules/my-module.js\");\nconst { default: myDefault, foo, bar } = await AAAA(\"/modules/my-module.js\");\nconst module = await AAAA(\"./utils.js\");\nAAAA(\"./lazy-module.js\").then(m =&gt; console.log(m));\n\n// Other code\nconsole.log(\"Hello world\");\n\n\n\ndef transform_all_imports(code_bytes, new_function_name=\"import\"):\n    \"\"\"Transform both static and dynamic imports.\"\"\"\n    if isinstance(code_bytes, str):\n        code_bytes = code_bytes.encode('utf-8')\n    \n    # First transform static imports to dynamic imports\n    result = transform_js_source(code_bytes)\n    \n    # Then transform all dynamic imports (including the newly created ones)\n    result = transform_dynamic_imports(result, new_function_name)\n    \n    return result\n\n\ncombined_test_code = '''\nimport x from \"foo\";\nimport {a, b as c} from \"bar\";\nimport * as ns from \"baz\";\nimport \"sidefx\";\n\nconst { default: existing } = await import(\"./existing2.js\");\n\nconsole.log(\"Hello, world!\");\nconst myVar = 42;\n\nasync function doSomething() {\n    const existingDynamic = await import(\"./existing.js\");\n    return x + a + ns.something;\n}\n\nexport { doSomething };\n'''\n\nprint(\"=== COMBINED TRANSFORMATION ===\")\nprint(\"Original:\")\ndisplay(Markdown(f\"```js\\n{combined_test_code}\\n```\"))\nprint(\"\\nAfter transforming to AAAA:\")\nfinal_result = transform_all_imports(combined_test_code, \"AAAA\")\ndisplay(Markdown(f\"```js\\n{final_result}\\n```\"))\n\n=== COMBINED TRANSFORMATION ===\nOriginal:\n\n\n\nimport x from \"foo\";\nimport {a, b as c} from \"bar\";\nimport * as ns from \"baz\";\nimport \"sidefx\";\n\nconst { default: existing } = await import(\"./existing2.js\");\n\nconsole.log(\"Hello, world!\");\nconst myVar = 42;\n\nasync function doSomething() {\n    const existingDynamic = await import(\"./existing.js\");\n    return x + a + ns.something;\n}\n\nexport { doSomething };\n\n\n\nAfter transforming to AAAA:\n\n\n\nconst {default: x} = await AAAA(\"foo\");\nconst {a, b: c} = await AAAA(\"bar\");\nconst ns = await AAAA(\"baz\");\nawait AAAA(\"sidefx\");\n\nconst { default: existing } = await AAAA(\"./existing2.js\");\n\nconsole.log(\"Hello, world!\");\nconst myVar = 42;\n\nasync function doSomething() {\n    const existingDynamic = await AAAA(\"./existing.js\");\n    return x + a + ns.something;\n}\n\nexport { doSomething };\n\n\n\ndef transform_all_imports_with_details(code_bytes, new_function_name=\"import\"):\n    \"Transform both static and dynamic imports with detailed reporting.\"\n    if isinstance(code_bytes, str):\n        code_bytes = code_bytes.encode('utf-8')\n    \n    original_code = code_bytes.decode('utf-8')\n    \n    # Step 1: Transform static imports to dynamic imports\n    static_result = transform_js_source_with_details(code_bytes)\n    \n    # Step 2: Transform all dynamic imports (including newly created ones)\n    after_static = static_result['transformed_code']\n    tree = parser.parse(after_static.encode('utf-8'))\n    dynamic_imports = find_dynamic_imports(tree.root_node, after_static.encode('utf-8'))\n    \n    # Transform dynamic imports\n    final_code = transform_dynamic_imports(after_static, new_function_name)\n    \n    return {\n        'original_code': original_code,\n        'after_static_transform': after_static,\n        'final_code': final_code,\n        'static_transformations': static_result['transformations'],\n        'dynamic_transformations': dynamic_imports,\n        'new_function_name': new_function_name\n    }\n\n\ndetailed_result = transform_all_imports_with_details(combined_test_code, \"AAAA\")\n\nprint(\"=== DETAILED TRANSFORMATION REPORT ===\")\nprint(f\"Target function name: {detailed_result['new_function_name']}\")\nprint(f\"\\nStatic imports found: {len(detailed_result['static_transformations'])}\")\nfor i, t in enumerate(detailed_result['static_transformations']):\n    print(f\"  {i+1}. {t['original']} -&gt; {t['replacement']}\")\n\nprint(f\"\\nDynamic imports found: {len(detailed_result['dynamic_transformations'])}\")\nfor i, t in enumerate(detailed_result['dynamic_transformations']):\n    print(f\"  {i+1}. {t['original_call']}\")\n\nprint(f\"\\n=== FINAL RESULT ===\")\nprint(detailed_result['final_code'])\n\n=== DETAILED TRANSFORMATION REPORT ===\nTarget function name: AAAA\n\nStatic imports found: 4\n  1. import \"sidefx\"; -&gt; await import(\"sidefx\");\n  2. import * as ns from \"baz\"; -&gt; const ns = await import(\"baz\");\n  3. import {a, b as c} from \"bar\"; -&gt; const {a, b: c} = await import(\"bar\");\n  4. import x from \"foo\"; -&gt; const {default: x} = await import(\"foo\");\n\nDynamic imports found: 6\n  1. import(\"foo\")\n  2. import(\"bar\")\n  3. import(\"baz\")\n  4. import(\"sidefx\")\n  5. import(\"./existing2.js\")\n  6. import(\"./existing.js\")\n\n=== FINAL RESULT ===\n\nconst {default: x} = await AAAA(\"foo\");\nconst {a, b: c} = await AAAA(\"bar\");\nconst ns = await AAAA(\"baz\");\nawait AAAA(\"sidefx\");\n\nconst { default: existing } = await AAAA(\"./existing2.js\");\n\nconsole.log(\"Hello, world!\");\nconst myVar = 42;\n\nasync function doSomething() {\n    const existingDynamic = await AAAA(\"./existing.js\");\n    return x + a + ns.something;\n}\n\nexport { doSomething };",
    "crumbs": [
      "Core Components",
      "Javascript import transform"
    ]
  },
  {
    "objectID": "nb_state.html",
    "href": "nb_state.html",
    "title": "Notebook state",
    "section": "",
    "text": "bridge_cfg.auto_show = True\nbridge_cfg.auto_id = False\n\n\nbridge = get_bridge(show_logger=True, wait=5)\n\n\n\n\n\nNBStateFeedback\n\nSimple visual feedback of notebook state. We manage the notebook state In the front-end and use this helper to show a little feedback of state changes.\n\nIf yuou’re reading this in VSCode-ish environment, ensure the extension developed in nbinspect-vscode is enabled.\nIf you want to know how the notebook’s state gets here in real-time, take a look at the packages folder.\n\n# NBStateFeedback.show(feedback=False, hide=True,debug=False)\nNBStateFeedback.show()\n\n\n\n\nNote that the state data is still in the front-end (JS-land). This function is just a visual feedback of state changes, but we haven’t transferred yet the state to the kernel (python-land). We need to have something (the bridge) in the front-end that can transfer the state to the kernel. For that, see next sections.\nVSCode weirdness (again): Bridget uses an extension to capture notebook state. In Jupyter environments, the extension is triggered when a notebook is opened, monitors state changes, and sends notifications to the frontend, waiting for a widget to retrieve them. Check the JavaScript console to see the extension’s traces.\nIn VSCode, the extension is also activated when a notebook is opened. However, the front end of the extension—Renderer in VSCode Notebook Extension API parlance—is isolated within a webview, an iframe-like object that the extension can only communicate with via the a very limited messaging API. Renderers are the only means by which extensions can communicate with the JavaScript running in the webview. And renderers can only be triggered by a cell displaying specific MIME types at least once. Therefore, since VSCode only renders its output when a visible cell is executed, the extension’s renderer can only obtain the notebook state relayed by the main extension when the cell is run interactively or is already in the notebook and visible. Fortunately, this only needs to happen once; you can delete the cell or its output, and the extension will continue to work. VSCode’s foibles.\nKeep this in mind when running commands like Execute Above Cells or Execute All Cells or similar. If the above cell is already displaying its output, that’s fine; if not, the extension renderer won’t be triggered until it appears, the state won’t be passed to the front end, and the rest of the notebook won’t work properly.\n\nprint(19)\n\n19\n\n\nAfter executing above cell, you’ve noticed a pink flash. We’re monitoring state changes in real-time.\nClear the output of the above cell. Open the details and look for cell #19 (if you haven’t added any new cells above it). Check that it doesn’t have any outputs.\nRun the cell again and check to see that it now has outputs.\nCreate a new cell below this, source or markdown, and write something. Notice that we’re updating the state of cell inputs not just outputs.\n\nNBStateFeedback.update(feedback=False)\n\nWith feedback disabled, the details disclosure in not shown.\n\nNBStateFeedback.update(feedback=True)\n\n\nNBStateFeedback.update(debug=False)\n\ndebug affects javascript dev console logging.\n\nprint(29)\n\n29\n\n\n\nNBStateFeedback.update(debug=True)\n\n\nNBStateFeedback.show()\n\nUnable to display output for mime type(s): application/x-notebook-state+json\n\n\n\nNBStateFeedback.hide()\n\nThough we’ve hided the feedback output, Bridget is still monitoring and capturing state changes, as you can see in the dev console. In fact, once activated by showing the feedback output, it’s not possible to deactivate it.\n\n\nNBStateFetcher\n\nA bridge plugin to retrieve notebook state from the front-end to bridge.state.\n\nSimple plugin to grab the notebook state from the front-end and return it to Python where we really want and need it. And where it should have always been, imho. How much unnecessary pain has the MVC pattern done!\n\nbundled(nbstate_js)();\n\n\nsource\n\nNBStateFetcher\n\n NBStateFetcher ()\n\nBridge plugin that retrieves notebook state from the front-end\n\nbridge.logger.show(clear=True)\n\n\n\n\n\nbridge.add_plugins(fetcher := NBStateFetcher(), wait=3)\n\nl = 80\ntest_is('fetcher' in bridge.plugins, True)\ntest_is(len(bridge.state.cells) in (0, l), True)\n\nWARNING: the extension debounces state notifications to avoid excesive throughput. When running Execute Above Cells or Execute All Cells or similar commands, the extension will group state notifications and the cell below will probably fail. If that’s the case, simply run the cell again.\n\n# cell 39\ntest_eq(len(bridge.state.cells), l)\nuri = urllib.parse.urlparse(bridge.state.nbData['notebookUri'])\nif in_vscode_notebook(): test_eq(uri.path, __vsc_ipynb_file__)  # type: ignore\nbridge.state[39]\n\n\nNBCell@39\n  \n    \nidx: 39    \n    \ncell_type: markdown    \n    \nsource: WARNING: the extension debounces state notifications to avoid excesive throughput. When running `Execute Above Cells` or `Execute All Cells`…    \n    \nid: X54sZmlsZQ==    \n    \nmetadata: {'brd': {'id': '5d660c84-66e2-41ab-b3c5-c2e67f16fc7d'}}    \n  \n\n\n\nNote after running previous cell, the state has not yet been updated. Check that it has no outputs or the outputs are old. We’ll see how to access the state of the current cell below.\n\n# cell 41\nbridge.state.cells[39]\n\n\nNBCell@39\n  \n    \nidx: 39    \n    \ncell_type: markdown    \n    \nsource: WARNING: the extension debounces state notifications to avoid excesive throughput. When running `Execute Above Cells` or `Execute All Cells`…    \n    \nid: X54sZmlsZQ==    \n    \nmetadata: {'brd': {'id': '5d660c84-66e2-41ab-b3c5-c2e67f16fc7d'}}    \n  \n\n\n\n\nbridge.logger.show()\n\n\n\n\n\nprint('test5')\n\ntest5\n\n\n\ndisplay(HTML('&lt;div&gt;test6&lt;/div&gt;'))\n\ntest6\n\n\n\n\n\nNBState\n\nSimple wrapper around NB + NBStateFetcher & NBHooks bridge plugins\n\n\nsource\n\nNBState\n\n NBState (source:Union[__main__.StateProvider,Mapping,NoneType]=None,\n          *bridge_args, plugins=None, **bridge_kw)\n\nInherit from this to have all attr accesses in self._xtra passed down to self.default\n\nsource\n\n\nStateProvider\n\n StateProvider (*args, **kwargs)\n\n*Base class for protocol classes.\nProtocol classes are defined as::\nclass Proto(Protocol):\n    def meth(self) -&gt; int:\n        ...\nSuch classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing).\nFor example::\nclass C:\n    def meth(self) -&gt; int:\n        return 0\n\ndef func(x: Proto) -&gt; int:\n    return x.meth()\n\nfunc(C())  # Passes static type check\nSee PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as::\nclass GenProto[T](Protocol):\n    def meth(self) -&gt; T:\n        ...*\n\nstate = json.loads(Path('../packages/nbinspect-vscode/test/outputs.json').read_text('utf-8'))\n\nnb = NBState(state)\n\n\ndisplay(nb.mds)\nnb.codes\n\n(#2) [0,23]\n\n\n(#40) [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20...]\n\n\n\nnb = NBState(show_logger=True, wait=5)\ntest_eq(nb.source, get_bridge())\n\n\n\n\n\nif len(nb.cells): display(nb[50])\n\n\nNBCell@50\n  \n    \nidx: 50    \n    \ncell_type: code    \n    \nsource: nb = NBState(show_logger=True, wait=5)\ntest_eq(nb.source, get_bridge())    \n    \nid: Y101sZmlsZQ==    \n    \nmetadata: {'brd': {'id': '14138586-2875-4e27-9c03-200e102a591d'}}    \noutputs\n      \n0\n          \n            \noutput_type: display_data            \ndata\n              \n                \ntext/html: &lt;div id='brd-logger_4-1764771587' class='brd-logger' style='width: 100%; max-height: 200px;'&gt;&lt;/div&gt;                \n                \ntext/plain: &lt;bridget.helpers.HTML object&gt;                \n              \n            \nmetadata: {'transient': {}}            \n          \n      \n    \nexecution_count: 40    \n  \n\n\n\n\nlist(shortens(nb[40:50], 'r', 80))\n\n['{\\'idx\\': 40, \\'cell_type\\': \\'code\\', \\'source\\': \"# cell 39\\\\ntest_eq(len(bridge.state.…',\n '{\\'idx\\': 41, \\'cell_type\\': \\'markdown\\', \\'source\\': \"Note after running previous cell…',\n \"{'idx': 42, 'cell_type': 'code', 'source': '# cell 41\\\\nbridge.state.cells[39]', …\",\n \"{'idx': 43, 'cell_type': 'code', 'source': 'bridge.logger.show()', 'id': 'X61sZm…\",\n '{\\'idx\\': 44, \\'cell_type\\': \\'code\\', \\'source\\': \"print(\\'test5\\')\", \\'id\\': \\'X62sZmlsZQ==…',\n '{\\'idx\\': 45, \\'cell_type\\': \\'code\\', \\'source\\': \"display(HTML(\\'&lt;div&gt;test6&lt;/div&gt;\\'))\", …',\n \"{'idx': 46, 'cell_type': 'markdown', 'source': '# NBState\\\\n&gt; Simple wrapper arou…\",\n '{\\'idx\\': 47, \\'cell_type\\': \\'code\\', \\'source\\': \"#| export\\\\n\\\\n@runtime_checkable\\\\ncla…',\n '{\\'idx\\': 48, \\'cell_type\\': \\'code\\', \\'source\\': \"state = json.loads(Path(\\'../packages…',\n \"{'idx': 49, 'cell_type': 'code', 'source': 'display(nb.mds)\\\\nnb.codes', 'id': 'Y…\"]\n\n\n\nlist(shortens(nb.find('class').attrgot('source'), 'r', 80))\n\n[\"#| export\\n\\nNBSTATE_MIME = 'application/x-notebook-state+json'\\n\\nclass _NBStateFee…\",\n '#| export\\n\\nclass NBStateFetcher(BridgePlugin):\\n    \"Bridge plugin that retrieves…',\n '#| export\\n\\n@runtime_checkable\\nclass StateProvider(Protocol):\\n    @property\\n    d…',\n \"list(shortens(nb.find('class').attrgot('source'), 'r', 80))\"]\n\n\n\n# find_me\n\n\n# this cell2\n# nb.update()\nnb.find('# this cell2').attrgot('source')\n\n(#1) [\"# this cell2\\n# nb.update()\\nnb.find('# this cell2').attrgot('source')\"]\n\n\n\n\n\nCell id\nFor this to work, bridge must be loaded with the NBHooksPlugin (NBState takes care of all that) .\n\n# really hate stupid wiggly reds\n__cellinfo__:AD\n\n\nprint(f\"{__cellinfo__.cell_id!r}\\n{__cellinfo__.source!r}\")\ntest_eq(__cellinfo__.source[:29], 'print(f\"{__cellinfo__.cell_id')\n\n'Y114sZmlsZQ=='\n'print(f\"{__cellinfo__.cell_id!r}\\\\n{__cellinfo__.source!r}\")\\ntest_eq(__cellinfo__.source[:29], \\'print(f\"{__cellinfo__.cell_id\\')'\n\n\n\n# cell x\nidx = nb.find('# cell x')[0].idx  # type: ignore\ntest_eq(__cellinfo__.cell_id, nb[idx].id)\nnb[idx]\n\n\nNBCell@61\n  \n    \nidx: 61    \n    \ncell_type: code    \n    \nsource: # cell x\nidx = nb.find('# cell x')[0].idx  # type: ignore\ntest_eq(__cellinfo__.cell_id, nb[idx].id)\nnb[idx]    \n    \nid: Y115sZmlsZQ==    \n    \nmetadata: {'brd': {'id': 'dbdca1cc-dcde-4bc3-9738-c1e14cd72069'}}    \noutputs\n      \n    \nexecution_count: None    \n  \n\n\n\n\n\nthis\nthis marks the finale of the first part of Bridget.\nWe now have all the pieces to build the bridge. - fasthtml & other helper scripts - loader of arbitrary JS code - notebook state fetcher - nbstate and nb hooks\nNext steps will be to add tools to edit notebook outputs.\n\nsource\n\nthis\n\n this (idx:int|None=None)\n\nCurrent cell if idx is None, or cell at idx from current cell upwards. Raises if not found.\n\nbridge.logger.show(clear=True)\n\n\n\n\n\nc = this(); c\n\n\nNBCell@66\n  \n    \nidx: 66    \n    \ncell_type: code    \n    \nsource: c = this(); c    \n    \nid: Y123sZmlsZQ==    \n    \nmetadata: {'brd': {'id': '73daee75-5371-4c72-9211-52443b4b2bf7'}}    \noutputs\n      \n    \nexecution_count: None    \n  \n\n\n\n\nc\n\n\nNBCell@66\n  \n    \nidx: 66    \n    \ncell_type: code    \n    \nsource: c = this(); c    \n    \nid: Y123sZmlsZQ==    \n    \nmetadata: {'brd': {'id': '73daee75-5371-4c72-9211-52443b4b2bf7'}}    \noutputs\n      \n0\n          \n            \noutput_type: execute_result            \n            \nexecution_count: 54            \ndata\n              \n                \ntext/plain: {'idx': 66,\n 'cell_type': 'code',\n 'source': 'c = this(); c',\n 'id': 'Y123sZmlsZQ==',\n 'metadata': {'brd': {'id': '73daee75-5371-4c72-9211-5…                \n                \ntext/html: &lt;style&gt;details ul { list-style-type:none; list-style-position: outside; padding-inline-start: 22px; margin: 0; } details .string { color: #2…                \n                \ntext/markdown: &gt; code\n\n```json\n{\n  'idx': 66,\n  'cell_type': 'code',\n  'source': 'c = this(); c',\n  'id': 'Y123sZmlsZQ==',\n  'metadata': {'brd': {'id': '73…                \n              \n            \nmetadata: {}            \n          \n      \n    \nexecution_count: 54    \n  \n\n\n\nthis is meant to be used interactively (as most of Bridget is).\nThe main function of this is to get the current cell, or more so, the current cell’s index, and get your bearings in the current notebook structure.\nNote that due to the client-server nature of the Jupyter notebooks, code running in the kernel can’t possibly access the cell currently being executed. The cell state is maintained byt the front-end, not the kernel. The kernel in fact knows nothing of notebooks or their structure. We can aspire at most to get the cell’s index and source. The output is not yet determined, though Bridget will capture it and you can access it after the cell has run, not during the cell execution. You can find the cell with NBState afterwards.\nAlso be aware, as always, that batch commands like “Execute Above Cells” and similar are implemented very differently by Jupyter Notebooks vendors. The cells in the run queue may start running in order (or not, I’ve seen ships on fire off the shoulder of Orion), but not necessarily finish up in that order. Bridget may receive the cells in any order and therefore, the notebook state is not settled until the end. In general, in Jupyter Notebooks, cells that depends on outputs of other cells will surely fail when not running interactively. This is known issue (and a desing flaw imo, that can be resolved simply by the front-end sending the cells in order to the kernel and waiting for each one to fisnish before sending the next one) and one of the reason Marimo and other Jupyter modern alternatives exists.\n\nthis(-1)\n\n\nNBCell@68\n  \n    \nidx: 68    \n    \ncell_type: markdown    \n    \nsource: `this` is meant to be used interactively (as most of Bridget is).\n\nThe main function of `this` is to get the current cell, or more so, the c…    \n    \nid: Y125sZmlsZQ==    \n    \nmetadata: {'brd': {'id': '93341472-e8c3-44ed-8a54-24e71d861fbc'}}    \n  \n\n\n\n\nthis(-3).source\n\n'c'\n\n\n\nthis(FIRST).source\n\n'#| default_exp nb_state'\n\n\n\nthis(LAST).source\n\n\"#| hide\\n#| eval: false\\n\\nif FC.IN_NOTEBOOK:\\n    BUNDLE_PATH = bundle_path(__name__)\\n    for f in ['nbstate']: bundled(BUNDLE_PATH / f'js/{f}.js')()\\n    nb_path = '21_nb_state.ipynb'\\n    nbdev_clean(nb_path)\\n    nbdev.nbdev_export(nb_path)\"\n\n\n\nthis(1).source\n\n'# get_nb'\n\n\n\n\n\nget_nb\n\nsource\n\nget_nb\n\n get_nb (*args, show_feedback:bool=False, logger:NBLogger|None=None,\n         show_logger:bool=False, lnks:dict[str,FT]|None=None,\n         esms:dict[str,str|Path]|None=None,\n         plugins:Sequence[BridgePlugin]|None=None,\n         kwplugins:dict[str,str]|None=None, wait:int=0,\n         summary:bool=False, factory:Callable[...,Any]|None=None,\n         timeout:float=10, sleep:float=0.2, n:int=10,\n         show:Callable[[bool],None]|None=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nargs\nVAR_POSITIONAL\n\n\n\n\nshow_feedback\nbool\nFalse\n\n\n\nlogger\nNBLogger | None\nNone\n\n\n\nshow_logger\nbool\nFalse\n\n\n\nlnks\ndict[str, FT] | None\nNone\n\n\n\nesms\ndict[str, str | Path] | None\nNone\n\n\n\nplugins\nSequence[BridgePlugin] | None\nNone\n\n\n\nkwplugins\ndict[str, str] | None\nNone\n\n\n\nwait\nint\n0\nseconds to wait for plugins/links/modules to load\n\n\nsummary\nbool\nFalse\n\n\n\nfactory\nCallable[…, Any] | None\nNone\n\n\n\ntimeout\nfloat\n10\n\n\n\nsleep\nfloat\n0.2\n\n\n\nn\nint\n10\n\n\n\nshow\nCallable[[bool], None] | None\nNone",
    "crumbs": [
      "Notebook State",
      "Notebook state"
    ]
  },
  {
    "objectID": "output_edit.html",
    "href": "output_edit.html",
    "title": "Editable Outputs",
    "section": "",
    "text": "from pathlib import Path\n\nimport fastcore.all as FC\nfrom fastcore.test import *\nfrom pote.common import shortens\nfrom rich.console import Console\n\n\n# from bridget.bridge_helpers import bootstrap_bridge\nfrom bridget.helpers import bridge_cfg\n\n\n\ncprint = (console := Console(width=120)).print\n\n\n# with bridge_cfg(bootstrap=True): bootstrap_bridge()\n\n\n\nnb = NBState()\n\nUnable to display output for mime type(s): application/x-notebook-state\n\n\nState updated type: state #cells 22 @1737813648692 watch: False feedback: True debug: True\n_on_message: state_update\nRequesting notebook state...\n_on_message: info\nLoading NBState fetcher...\n\n\n\n&lt;style class=\"echo reflect\" contenteditable=\"true\"&gt;\n\n@font-face {\n  font-family: 'FontWithASyntaxHighlighterLightOwl';\n  src:\n    url('static/font/FontWithASyntaxHighlighterLightOwl-Regular.woff2') format('woff2');\n}\n\n@font-face {\n  font-family: 'FontWithASyntaxHighlighter';\n  src:\n    url('static/font/FontWithASyntaxHighlighter-Regular.woff2') format('woff2');\n  font-weight: 400;\n}\n\n/** keep in sync with libertine.css */\n.echo {\n  display: block;\n  font-family: \"FontWithASyntaxHighlighterLightOwl\", monospace;\n  font-feature-settings: \"colr\", \"calt\";\n  white-space: pre;\n  font-size: 0.9rem; /* 0.83rem */\n  line-height: 1.42;\n\n  padding: 1ch;\n  /* cloned by libertine.css */\n  overflow: auto;\n  background-color: transparent; /* #f3f3f3; */\n  border-radius: 4px;\n}\n\n\n.echo.dark {\n  font-family: \"FontWithASyntaxHighlighter\", monospace;\n  background-color: #282828;\n  color: #eee;\n}\n\n\n.echo[contenteditable]:hover {\n  box-shadow: inset 0 0 0 1px #8b99c8;\n}\n\n.echo[contenteditable].dark:hover {\n  box-shadow: inset 0 0 0 3px #8b99c8;\n}\n\n/* */\nscript.reflect::before {\n  content: \"&lt;script id=\\\"\" attr(id) \"\\\" type=\\\"\" attr(type) \"\\\" class=\\\"\" attr(class) \"\\\" contenteditable=\\\"\" attr(contenteditable) \"\\\"&gt;\";\n}\n\nscript.reflect::after {\n  content: \"&lt;\\/script&gt;\";\n}\n\nstyle.reflect::before {\n  content: \"&lt;style id=\\\"\" attr(id) \"\\\" class=\\\"\" attr(class) \"\\\" contenteditable=\\\"\" attr(contenteditable) \"\\\"&gt;\";\n}\n\nstyle.reflect::after {\n  content: \"&lt;\\/style&gt;\";\n}\n/* */\n&lt;/style&gt;\n\n\n\n\n\nDiv(\n    Div('asdf'), \n    Script('asdf\\n', cls='echo', contenteditable='true', type='text/html')\n)\n\n\n  asdf\n\n\n\n\n&lt;style class=\"echo reflect\" contenteditable=\"true\"&gt;\n/* @import url('https://unpkg.com/@observablehq/inspector@5.0.1/src/style.css'); */\n\n@font-face {\n  font-family: 'FontWithASyntaxHighlighterLightOwl';\n  src:\n    url('static/font/FontWithASyntaxHighlighterLightOwl-Regular.woff2') format('woff2');\n}\n\n@font-face {\n  font-family: 'FontWithASyntaxHighlighter';\n  src:\n    url('static/font/FontWithASyntaxHighlighter-Regular.woff2') format('woff2');\n  font-weight: 400;\n}\n\n/** keep in sync with libertine.css */\n.echo {\n  display: block;\n  font-family: \"FontWithASyntaxHighlighterLightOwl\", monospace;\n  font-feature-settings: \"colr\", \"calt\";\n  white-space: pre;\n  font-size: 0.9rem; /* 0.83rem */\n  line-height: 1.42;\n\n  padding: 1ch;\n  /* cloned by libertine.css */\n  overflow: auto;\n  background-color: transparent; /* #f3f3f3; */\n  border-radius: 4px;\n}\n\n\n.echo.dark {\n  font-family: \"FontWithASyntaxHighlighter\", monospace;\n  background-color: #282828;\n  color: #eee;\n}\n\n\n.echo[contenteditable]:hover {\n  box-shadow: inset 0 0 0 1px #8b99c8;\n}\n\n.echo[contenteditable].dark:hover {\n  box-shadow: inset 0 0 0 3px #8b99c8;\n}\nscript.reflect::before {\n  content: \"&lt;script id=\\\"\" attr(id) \"\\\" type=\\\"\" attr(type) \"\\\" class=\\\"\" attr(class) \"\\\" contenteditable=\\\"\" attr(contenteditable) \"\\\"&gt;\";\n}\n\nscript.reflect::after {\n  content: \"&lt;\\/script&gt;\";\n}\n\nstyle.reflect::before {\n  content: \"&lt;style id=\\\"\" attr(id) \"\\\" class=\\\"\" attr(class) \"\\\" contenteditable=\\\"\" attr(contenteditable) \"\\\"&gt;\";\n}\n\nstyle.reflect::after {\n  content: \"&lt;\\/style&gt;\";\n}\n\n.observablehq {\n  display: inline;\n}\n\n@keyframes blink {\n  67% {\n    opacity: 0;\n  }\n}\n.observablehq--running::before {\n  content: 'LOADING';\n  animation: blink 1s step-end infinite;\n}\n&lt;/style&gt;\n\n\n&lt;div id=\"asdf-qwer\"&gt;Hello World&lt;/div&gt;\n\n\n&lt;style class=\"echo reflect\" contenteditable=\"true\"&gt;\n    #asdf-qwer {\n        background-color:rgb(49, 49, 49); /* trasparent */\n        color: ivory;\n    }\n&lt;/style&gt;\n\n\n&lt;script class=\"echo reflect\" contenteditable=\"true\"&gt;\n    console.log('Hello World');\n&lt;/script&gt;\n\n\n&lt;div contenteditable=\"true\"&gt;\n&lt;div&gt;Hello World&lt;/div&gt;\n&lt;/div&gt;\n\n\nnb.state.find('%%HTML')[1]",
    "crumbs": [
      "(very) WIP",
      "Editable Outputs"
    ]
  },
  {
    "objectID": "details_json.html",
    "href": "details_json.html",
    "title": "DetailsJSON",
    "section": "",
    "text": "Derivation\n\napp, brt, rt = get_app()#show_logger=True, summary=True)\n\n\n&lt;style&gt;\n    me ul { list-style-type:none; list-style-position: outside; padding-inline-start: 22px; margin: 0; }\n&lt;/style&gt;\n&lt;details open&gt;\n&lt;summary&gt;Apollo astronauts&lt;/summary&gt;\n&lt;ul&gt;\n  &lt;li&gt;&lt;span&gt;1&lt;/span&gt;: Neil Armstrong&lt;/li&gt;\n  &lt;li&gt;&lt;span&gt;2&lt;/span&gt;: Alan Bean&lt;/li&gt;\n  &lt;li&gt;&lt;details&gt;\n&lt;summary&gt;Apollo 11&lt;/summary&gt;\n&lt;ul&gt;\n  &lt;li&gt;&lt;span&gt;1&lt;/span&gt;: Neil Armstrong&lt;/li&gt;\n  &lt;li&gt;&lt;span&gt;2&lt;/span&gt;: Alan Bean&lt;/li&gt;\n  &lt;li&gt;&lt;div&gt;&lt;span&gt;3&lt;/span&gt;: Buzz Aldrin&lt;/div&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;span&gt;4&lt;/span&gt;: Edgar Mitchell&lt;/li&gt;\n  &lt;li&gt;&lt;span&gt;5&lt;/span&gt;: Alan Shepard&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;span&gt;4&lt;/span&gt;: Edgar Mitchell&lt;/li&gt;\n  &lt;li&gt;&lt;span&gt;5&lt;/span&gt;: Alan Shepard&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;/details&gt;\n\n\n\nApollo astronauts\n\n  1: Neil Armstrong\n  2: Alan Bean\n  \nApollo 11\n\n  1: Neil Armstrong\n  2: Alan Bean\n  3: Buzz Aldrin\n  4: Edgar Mitchell\n  5: Alan Shepard\n\n  4: Edgar Mitchell\n  5: Alan Shepard\n\n\n\n\n\n\ndef Val(v): \n    c = (\n        'null' if v is None else \n        'true' if v is True else \n        'false' if v is False else \n        'string' if isinstance(v, str) else \n        'number' if isinstance(v, (int, float)) else \n        '')\n    return Span(shorten(v, 'r', 140) if v is not None else 'None', cls=f\"v {c}\")\ndef NameVal(k, v): return Span(Span(k, cls='n'), ': ', Val(v))\n\n\nclass DetailsJSON(dict):\n    def __init__(self, *args, summary:str='', open:bool=True, openall:bool=False, skip:Sequence[str]=(), **kwargs):\n        super().__init__(*args, **kwargs)\n        self.summary, self.open, self.openall, self.skip = str(summary), open, openall, skip\n    def __ft__(self, d:Mapping|None=None, summary:str|None=None, lvl:int=0, open:bool=False):\n        if d is None: d = self; summary = self.summary or 'summary'; open=self.open\n        open = self.openall or open\n        return (\n            Style(self._css_) if lvl == 0 else (), \n            Details(open=open)(\n                Summary(summary, _n),\n                Ul()(*(\n                    Li(NameVal(k, v)) if k in self.skip else\n                    self.__ft__(v, k, lvl+1) if isinstance(v, Mapping) else\n                    self.__ft__(dict(list(zip(range(len(v)), v))), k, lvl+1) if is_listy(v) else\n                    Li(NameVal(k, v)) \n                    for k,v in d.items()))))\n    _css_ = (\n        'details ul { list-style-type:none; list-style-position: outside; padding-inline-start: 22px; margin: 0; } '\n        '''details .string { color: #24837b; } details .string::before { content: \"'\"; } details .string::after { content: \"'\"; } '''\n        'details .number { color: #ad8301; } '\n        'details .true { color: blue; } '\n        'details .false { color: red; } '\n        'details .null { color: gray; } '\n        'span.n { color: darkgrey; } '\n    )\n\n\n# class DetailsJSON(dict):\n#     def __init__(self, *args, summary:str='', open:bool=False, lvl:int=0, **kwargs):\n#         super().__init__(*args, **kwargs)\n#         self.summary, self.open, self.lvl = summary, open, lvl\n#     def __ft__(self):\n#         return (\n#             Style(self._css_) if self.lvl == 0 else (), \n#             Details(open=self.open)(\n#                 Summary(self.summary or 'summary', _n),\n#                 Ul()(*(\n#                     Li(NameVal(k, v)) if not isinstance(v, Mapping) else \n#                     DetailsJSON(v, summary=k, lvl=self.lvl+1) \n#                     for k,v in self.items()))))\n#     _css_ = 'me ul { list-style-type:none; list-style-position: outside; padding-inline-start: 22px; margin: 0; } '\n\n\ndtl = DetailsJSON({\n    '1': 'Neil Armstrong',\n    '2': 'Alan Bean',\n    '3': 'Buzz Aldrin',\n    'letters': {\n        'a': 1, \n        'b': 2\n        },\n    '5': 'Edgar Mitchell',\n    '6': 'Alan Shepard'\n}, summary='Apollo astronauts', open=True)\n\ntest_eq(val_at(dtl, '5'), 'Edgar Mitchell')\ntest_eq(val_at(dtl, 'letters.a'), 1)\nprint(to_xml(dtl))\nshow(dtl)\n\n&lt;style&gt;details ul { list-style-type:none; list-style-position: outside; padding-inline-start: 22px; margin: 0; } details .string { color: #24837b; } details .string::before { content: \"'\"; } details .string::after { content: \"'\"; } details .number { color: #ad8301; } details .true { color: blue; } details .false { color: red; } details .null { color: gray; } span.n { color: darkgrey; } &lt;/style&gt;\n&lt;details open&gt;&lt;summary&gt;Apollo astronauts\n&lt;/summary&gt;  &lt;ul&gt;\n    &lt;li&gt;\n&lt;span&gt;&lt;span class=\"n\"&gt;1&lt;/span&gt;: &lt;span class=\"v string\"&gt;Neil Armstrong&lt;/span&gt;&lt;/span&gt;    &lt;/li&gt;\n    &lt;li&gt;\n&lt;span&gt;&lt;span class=\"n\"&gt;2&lt;/span&gt;: &lt;span class=\"v string\"&gt;Alan Bean&lt;/span&gt;&lt;/span&gt;    &lt;/li&gt;\n    &lt;li&gt;\n&lt;span&gt;&lt;span class=\"n\"&gt;3&lt;/span&gt;: &lt;span class=\"v string\"&gt;Buzz Aldrin&lt;/span&gt;&lt;/span&gt;    &lt;/li&gt;\n&lt;details&gt;&lt;summary&gt;letters\n&lt;/summary&gt;      &lt;ul&gt;\n        &lt;li&gt;\n&lt;span&gt;&lt;span class=\"n\"&gt;a&lt;/span&gt;: &lt;span class=\"v number\"&gt;1&lt;/span&gt;&lt;/span&gt;        &lt;/li&gt;\n        &lt;li&gt;\n&lt;span&gt;&lt;span class=\"n\"&gt;b&lt;/span&gt;: &lt;span class=\"v number\"&gt;2&lt;/span&gt;&lt;/span&gt;        &lt;/li&gt;\n      &lt;/ul&gt;\n&lt;/details&gt;    &lt;li&gt;\n&lt;span&gt;&lt;span class=\"n\"&gt;5&lt;/span&gt;: &lt;span class=\"v string\"&gt;Edgar Mitchell&lt;/span&gt;&lt;/span&gt;    &lt;/li&gt;\n    &lt;li&gt;\n&lt;span&gt;&lt;span class=\"n\"&gt;6&lt;/span&gt;: &lt;span class=\"v string\"&gt;Alan Shepard&lt;/span&gt;&lt;/span&gt;    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/details&gt;\n\n\n\nApollo astronauts\n  \n    \n1: Neil Armstrong    \n    \n2: Alan Bean    \n    \n3: Buzz Aldrin    \nletters\n      \n        \na: 1        \n        \nb: 2        \n      \n    \n5: Edgar Mitchell    \n    \n6: Alan Shepard    \n  \n\n\n\n\ndef walk(m:Mapping, p:str=''):\n    for k,v in m.items():\n        if isinstance(v, Mapping): yield from walk(v, f\"{p}.{k}\" if p else k)\n        else: yield f\"{p}.{k}\" if p else k,v \n\nlist(walk(dtl))\n\n[('1', 'Neil Armstrong'),\n ('2', 'Alan Bean'),\n ('3', 'Buzz Aldrin'),\n ('letters.a', 1),\n ('letters.b', 2),\n ('5', 'Edgar Mitchell'),\n ('6', 'Alan Shepard')]\n\n\n\ndef walk(mapping: Mapping, prefix: str=''):\n    stack = [(prefix, list(mapping.items()))]\n    while stack:\n        p, items = stack[-1]\n        if not items: stack.pop(); continue\n        k, v = items.pop(0)\n        if isinstance(v, Mapping): stack.append((f\"{p}.{k}\" if p else k, list(v.items())))\n        else: yield f\"{p}.{k}\" if p else k, v\n\n# Test\nlist(walk(dtl))\n\n[('1', 'Neil Armstrong'),\n ('2', 'Alan Bean'),\n ('3', 'Buzz Aldrin'),\n ('letters.a', 1),\n ('letters.b', 2),\n ('5', 'Edgar Mitchell'),\n ('6', 'Alan Shepard')]\n\n\n\ndef update(d, other:Mapping|None=None, **kwargs):\n    if isinstance(d, dict): d.update(other or {}, **kwargs)\n    else:\n        for k,v in {**(other or {}), **kwargs}.items(): \n            try: setattr(d, k, v)\n            except AttributeError: pass\n    return d\n\n\nd = {'a': 1, 'b':2}\ntest_eq(update(d, c=3), {'a': 1, 'b':2, 'c':3})\ntest_eq(update(d, {'b': 22}), {'a': 1, 'b':22, 'c':3})\n\n\n\nDetailsJSON\n\nsource\n\nDetailsJSON\n\n DetailsJSON (o:Mapping[str,Any], summary:str='',\n              open:Union[bool,Literal['all']]=True)\n\nBase class for objects that provide routes via an APIRouter\n\nsource\n\n\nNameVal\n\n NameVal (k, v)\n\n\nsource\n\n\nVal\n\n Val (v)\n\n\nbrt.app.routes.clear()\nbridge_cfg.auto_show = False\n\ndtl = DetailsJSON({\n    '1': 'Neil Armstrong', '2': 'Alan Bean', '3': 'Buzz Aldrin',\n    'letters': { 'a': 1, 'b': True, 'c': {'d': None} },\n    '5': 'Edgar Mitchell', '6': 'Alan Shepard'\n}, summary='Apollo astronauts')\n\nbrt.mount(dtl, '/details', 'details', show=False)\n\ntest_eq(dtl.ar.name(), 'DetailsJSON:details')\ntest_eq(app.url_path_for('DetailsJSON:details:get', dp=''), '/DetailsJSON/details/')\ntest_eq(app.url_path_for('DetailsJSON:details:get', dp='letters'), '/DetailsJSON/details/letters')\n\ndtl()\n\n&lt;details open hx-swap=\"outerHTML\"&gt;\n  &lt;style&gt;me ul { list-style-type:none; list-style-position: outside; padding-inline-start: 22px; margin: 0; } me .string { color: #24837b; } me .string::before { content: \"'\"; } me .string::after { content: \"'\"; } me .number { color: #ad8301; } me .true { color: blue; } me .false { color: red; } me .null { color: gray; } me .n { color: darkgrey; } &lt;/style&gt;\n&lt;summary&gt;Apollo astronauts&lt;/summary&gt;\n  &lt;ul&gt;\n    &lt;li&gt;\n&lt;span&gt;&lt;span class=\"n\"&gt;1&lt;/span&gt;: &lt;span class=\"v string\"&gt;Neil Armstrong&lt;/span&gt;&lt;/span&gt;    &lt;/li&gt;\n    &lt;li&gt;\n&lt;span&gt;&lt;span class=\"n\"&gt;2&lt;/span&gt;: &lt;span class=\"v string\"&gt;Alan Bean&lt;/span&gt;&lt;/span&gt;    &lt;/li&gt;\n    &lt;li&gt;\n&lt;span&gt;&lt;span class=\"n\"&gt;3&lt;/span&gt;: &lt;span class=\"v string\"&gt;Buzz Aldrin&lt;/span&gt;&lt;/span&gt;    &lt;/li&gt;\n    &lt;li&gt;\n&lt;details hx-get=\"/DetailsJSON/details/letters\"&gt;\n&lt;summary&gt;letters&lt;/summary&gt;\n&lt;/details&gt;    &lt;/li&gt;\n    &lt;li&gt;\n&lt;span&gt;&lt;span class=\"n\"&gt;5&lt;/span&gt;: &lt;span class=\"v string\"&gt;Edgar Mitchell&lt;/span&gt;&lt;/span&gt;    &lt;/li&gt;\n    &lt;li&gt;\n&lt;span&gt;&lt;span class=\"n\"&gt;6&lt;/span&gt;: &lt;span class=\"v string\"&gt;Alan Shepard&lt;/span&gt;&lt;/span&gt;    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/details&gt;\n\n\n\ndtl('letters')\n\n&lt;details open&gt;&lt;summary&gt;letters&lt;/summary&gt;\n  &lt;ul&gt;\n    &lt;li&gt;\n&lt;span&gt;&lt;span class=\"n\"&gt;a&lt;/span&gt;: &lt;span class=\"v number\"&gt;1&lt;/span&gt;&lt;/span&gt;    &lt;/li&gt;\n    &lt;li&gt;\n&lt;span&gt;&lt;span class=\"n\"&gt;b&lt;/span&gt;: &lt;span class=\"v true\"&gt;True&lt;/span&gt;&lt;/span&gt;    &lt;/li&gt;\n    &lt;li&gt;\n&lt;details hx-get=\"/DetailsJSON/details/letters/c\"&gt;\n&lt;summary&gt;c&lt;/summary&gt;\n&lt;/details&gt;    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/details&gt;\n\n\n\ndtl('letters/c')\n\n&lt;details open&gt;&lt;summary&gt;c&lt;/summary&gt;\n  &lt;ul&gt;\n    &lt;li&gt;\n&lt;span&gt;&lt;span class=\"n\"&gt;d&lt;/span&gt;: &lt;span class=\"v null\"&gt;None&lt;/span&gt;&lt;/span&gt;    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/details&gt;\n\n\n\nprint(brt.cli.get('/DetailsJSON/details/letters', headers={'hx-request': '1'}).text)\n\n&lt;details open&gt;&lt;summary&gt;letters&lt;/summary&gt;\n   &lt;ul&gt;\n     &lt;li&gt;\n&lt;span&gt;&lt;span class=\"n\"&gt;a&lt;/span&gt;: &lt;span class=\"v number\"&gt;1&lt;/span&gt;&lt;/span&gt;     &lt;/li&gt;\n     &lt;li&gt;\n&lt;span&gt;&lt;span class=\"n\"&gt;b&lt;/span&gt;: &lt;span class=\"v true\"&gt;True&lt;/span&gt;&lt;/span&gt;     &lt;/li&gt;\n     &lt;li&gt;\n&lt;details hx-get=\"/DetailsJSON/details/letters/c\"&gt;\n&lt;summary&gt;c&lt;/summary&gt;\n&lt;/details&gt;     &lt;/li&gt;\n   &lt;/ul&gt;\n&lt;/details&gt;\n\n\n\nprint(brt.cli.get('/DetailsJSON/details/letters/c', headers={'hx-request': '1'}).text)\n\n&lt;details open&gt;&lt;summary&gt;c&lt;/summary&gt;\n   &lt;ul&gt;\n     &lt;li&gt;\n&lt;span&gt;&lt;span class=\"n\"&gt;d&lt;/span&gt;: &lt;span class=\"v null\"&gt;None&lt;/span&gt;&lt;/span&gt;     &lt;/li&gt;\n   &lt;/ul&gt;\n&lt;/details&gt;\n\n\n\nbridge_cfg.auto_show = True\ndtl()\n\n\nApollo astronauts\n1: Neil Armstrong2: Alan Bean3: Buzz Aldrin\nletters\n5: Edgar Mitchell6: Alan Shepard\n\n\n\nbrt('/DetailsJSON/details/');\n\n\n   \nApollo astronauts\n   \n     \n1: Neil Armstrong     \n     \n2: Alan Bean     \n     \n3: Buzz Aldrin     \n     \n\nletters\n     \n     \n5: Edgar Mitchell     \n     \n6: Alan Shepard     \n   \n\n\n\n\n# bridge_cfg.auto_mount = True\n\napollo_astronauts = json.load(Path('static/apollo_astronauts.json').open())\n\n(astro := DetailsJSON(apollo_astronauts, summary='Apollo astronauts'))\n\n\n  \nApollo astronauts\n  \n    \n\nApollo 7\n    \n    \n\nApollo 8\n    \n    \n\nApollo 9\n    \n    \n\nApollo 10\n    \n    \n\nApollo 11\n    \n    \n\nApollo 12\n    \n    \n\nApollo 13\n    \n    \n\nApollo 14\n    \n    \n\nApollo 15\n    \n    \n\nApollo 16\n    \n    \n\nApollo 17\n    \n  \n\n\n\n\nrequest = {\n    'headers': {\n        'HX-Request': 'true',\n        'HX-Current-URL': 'vscode-webview://1ql27...enderer'\n    },\n    'headerNames': {\n        'hx-request': 'HX-Request',\n        'hx-current-url': 'HX-Current-URL'\n    },\n    'status': 0,\n    'method': 'GET',\n    'url': '/DetailsJSON_5096628128/Apollo 11/Buzz Aldrin',\n    'async': True,\n    'timeout': 0,\n    'withCredentials': False,\n    'body': None,\n    'req_id': '68ffadb0-958d-4346-b314-d9d62ca247d7'\n}\n\nresponse = {\n    'headers': {\n        'content-length': '441',\n        'content-type': 'text/html; charset=utf-8',\n        'last-modified': 'Fri, 15 Nov 2024 16:22:15 GMT',\n        'cache-control': 'no-store, no-cache, must-revalidate'\n    },\n    'status': 200,\n    'statusText': 'OK',\n    'data': '&lt;details open&gt;&lt;summary&gt;Buzz Aldrin&lt;/summary&gt;\\n   &lt;ul&gt;\\n     '\n'&lt;li&gt;Pilot on Gemini 12 and Lunar Module pilot on Apollo 11.&lt;/li&gt;\\n     '\n'&lt;li&gt;Aldrin was the second person to walk on the moon.&lt;/li&gt;\\n     &lt;li&gt;The maiden '\n'name of Aldrin&#x27;s mother was &quot;Moon.&quot;&lt;/li&gt;\\n     &lt;li&gt;While Neil was '\n'the first human to step onto the moon, I&#x27;m the first alien from another '\n'world to enter a spacecraft that was going to Earth.&lt;/li&gt;\\n   '\n'&lt;/ul&gt;\\n&lt;/details&gt;',\n    'xml': None,\n    'finalUrl': 'http://nb/DetailsJSON_5096628128/Apollo%2011/Buzz%20Aldrin',\n    'req_id': '68ffadb0-958d-4346-b314-d9d62ca247d7'\n}\n\n\n(req := DetailsJSON(request, summary='request', open='all'))\n\n\n  \nrequest\n  \n    \nheaders\n        \n          \nHX-Request: true          \n          \nHX-Current-URL: vscode-webview://1ql27...enderer          \n        \n    \n    \nheaderNames\n        \n          \nhx-request: HX-Request          \n          \nhx-current-url: HX-Current-URL          \n        \n    \n    \nstatus: 0    \n    \nmethod: GET    \n    \nurl: /DetailsJSON_5096628128/Apollo 11/Buzz Aldrin    \n    \nasync: True    \n    \ntimeout: 0    \n    \nwithCredentials: False    \n    \nbody: None    \n    \nreq_id: 68ffadb0-958d-4346-b314-d9d62ca247d7    \n  \n\n\n\n\n(resp := DetailsJSON(response, summary='response'))\n\n\n  \nresponse\n  \n    \n\nheaders\n    \n    \nstatus: 200    \n    \nstatusText: OK    \n    \ndata: &lt;details open&gt;&lt;summary&gt;Buzz Aldrin&lt;/summary&gt;\n   &lt;ul&gt;\n     &lt;li&gt;Pilot on Gemini 12 and Lunar Module pilot on Apollo 11.&lt;/li&gt;\n     &lt;li&gt;Aldrin w…    \n    \nxml: None    \n    \nfinalUrl: http://nb/DetailsJSON_5096628128/Apollo%2011/Buzz%20Aldrin    \n    \nreq_id: 68ffadb0-958d-4346-b314-d9d62ca247d7",
    "crumbs": [
      "Components",
      "DetailsJSON"
    ]
  },
  {
    "objectID": "bridge.html#bridgeboot",
    "href": "bridge.html#bridgeboot",
    "title": "Bridge helpers",
    "section": "BridgeBoot",
    "text": "BridgeBoot\n\nSimply setup the bridge and connect logging.\n\n\ncleanupwidgets('brd')\n\nbrd = BridgeBoot.create(show_logger=True, timeout=DEBUG(2, 2), sleep=0.2)\ntest_eq(brd.loaded(), True)\n\n\n\n\nNote create blocks, it waits for the widget to be loaded (or the default timeout, see BlockingMixin).\n\nbrd.error('Erred!')\n\n\nbrd.update_logger_config(color='darkgoldenrod')  # type: ignore\n\n\nbrd.log('my trea~~sssure')\n\nlgr now that the bridge is opened reflects both frontend and kernel log messages and uses the JS bridge logging functionality.\n\nscr = Script('''\nconst { bridge } = await brdimport('./bridge.js');\nbridge.logger.log('Hi from JS land');\n''', type='module')\ndisplay(HTML(scr))\ntime.sleep(0.1)\nclear_output()\n\nLog from JS land.\n\n@FC.delegates(BridgeBoot, keep=True)  # type: ignore\ndef get_bridge(logger:NBLogger|None=None, show_logger:bool=False, **kwargs) -&gt; BridgeBoot:\n    if not __brd__:\n        timeout, sleep = kwargs.pop('timeout', 2), kwargs.pop('sleep', 0.2)\n        brd = BridgeBoot.create(logger=logger, show_logger=show_logger, timeout=timeout, sleep=sleep, **kwargs)\n        return brd\n    assert __brd__ is not None\n    brd:BridgeBoot = __brd__\n    if logger: brd.logger = logger\n    if show_logger: brd.logger.show()\n    return brd\n\n\nbrd = get_bridge(show_logger=True)\ntest_is(get_bridge(), brd)\n\n\n\n\n\nbrd.close()\ntest_is(__brd__ is None, True)\n\nclose() disconnect the widget and remove the widget model from the JS bridge, so it can no longer communicate with the Python side. Besides that, it has no effect on bcanvas, or the modules imported with brdimport. Create a new bridge to reconnect.\nWe need to use AnyWidget to setup the JS bridge, a class. The python side of the bridge should be created once per notebook, no sense to have several bridges around.\nGiven the nearly impossibility of creating class singletons in Python even with metaclasses, in previous refactorizations, I’ve used SingletonConfigurable a-la-getipython. It works very well but it uglify the code.\nAnyway, given we’re-all-adults-here, you should always use get_bridge to access the bridge instance.\n\nbrd = get_bridge(show_logger=True)",
    "crumbs": [
      "Bridge",
      "Bridge helpers"
    ]
  },
  {
    "objectID": "bridge.html#handle_message",
    "href": "bridge.html#handle_message",
    "title": "Bridge helpers",
    "section": "handle_message",
    "text": "handle_message\n\nclass _A:\n    ctx_names={'A'}\n    def __init__(self): self.forward = _B()\n    def on_info(self, *args, **kwargs): \n        print('A', 'info', f\"{args=}\", f\"{kwargs=}\")\n    def _msg_fwrdr(self, *args, ctx:str, kind:str, **kwargs):\n        if ctx == 'B':\n            handle_message(self.forward, *args, ctx=ctx, kind=kind, **kwargs)\n        else:\n            print(f\"{ctx=} Not forwarded\")\n\nclass _B:\n    ctx_names={'B'}\n    def on_info(self, *args, **kwargs):\n        print('B', 'info', f\"{args=}\", f\"{kwargs=}\")\n\na = _A()\ntest_stdout(\n    lambda: handle_message(a, 'hello', ctx='A', kind='info', info='initialized'), \n    \"A info args=('hello',) kwargs={'info': 'initialized'}\\nctx='A' Not forwarded\")\ntest_stdout(\n    lambda: handle_message(a, 'other', ctx='B', kind='info', info='forwarded'), \n    \"B info args=('other',) kwargs={'info': 'forwarded'}\")",
    "crumbs": [
      "Bridge",
      "Bridge helpers"
    ]
  },
  {
    "objectID": "bridge.html#bridgemessenger",
    "href": "bridge.html#bridgemessenger",
    "title": "Bridge helpers",
    "section": "BridgeMessenger",
    "text": "BridgeMessenger\n\nA bridge that can receive messages from JS land.\n\nBridgeBoot just loads the JS bridge and setup logging. Here we set the basis for more powerful messaging to and fro JS.\n\n@FC.delegates(BridgeMessenger, keep=True)  # type: ignore\ndef get_bridge(logger:NBLogger|None=None, show_logger:bool=False, **kwargs):\n    if not __brd__: \n        timeout, sleep = kwargs.pop('timeout', 3), kwargs.pop('sleep', 0.2)\n        brd = BridgeMessenger.create(logger=logger, show_logger=show_logger, timeout=timeout, sleep=sleep, **kwargs)\n        return brd\n    assert __brd__ is not None\n    brd = __brd__\n    if logger: brd.logger = logger\n    if not logger and show_logger: brd.logger.show()\n    return brd\n\n\ncleanupwidgets('brd')\n\nbrd = get_bridge(show_logger=True, timeout=DEBUG(2, 2))\n\n\n\n\n\nbrd.debug_enabled('loader', enabled=True)\n\n\nbrd.send(brd.msg(ctx='brd', cmd='echo', args='test'))\n\n\nmsg = dict(ctx='loader', cmd='load', args={'confetti': 'https://esm.sh/canvas-confetti@1.6'}, timeout=DEBUG(1))\nbrd.send(msg)\n\n\nobserver_loader = anysource('''\nconst { getObserverManager } = await brdimport('./observer.js');\nconsole.log(getObserverManager)\n''')\n\nbrd.send(dict(ctx='loader', cmd='load', args={'get_observer': observer_loader}, reload=True), timeout=DEBUG(1))\n\n({'ctx': 'loader',\n  'kind': 'load',\n  'success': ['get_observer'],\n  'failed': [],\n  'msg_id': 'msg-8'},\n [])\n\n\n\nsrc = '''\nconst res = await brdimport('https://a.com/b/c.js');\nconsole.log(res)\n'''\n\nbrd.send(dict(ctx='loader', cmd='load', args={'willfail': src}, reload=True), timeout=DEBUG(1))\n\n({'ctx': 'loader',\n  'kind': 'load',\n  'success': [],\n  'failed': [{'name': 'willfail',\n    'error': 'Failed to fetch dynamically imported module: https://a.com/b/c.js'}],\n  'msg_id': 'msg-9'},\n [])\n\n\nanysource doesn’t transform its arguments. Use bundled (i.e., Bundle.__call__(..., transform=True), the default), instead.\nYou can disabled JS transform completely with bridge.cfg.bundle_cfg.rewrite_imports.\n\nsrc = bundled('''\nimport confetti from 'https://esm.sh/canvas-confetti@1.6';\nconsole.log(confetti)\n''')(transform=False)\n\nbrd.send(dict(ctx='loader', cmd='load', args={'load_confetti': src}), timeout=DEBUG(1))\n\n({'ctx': 'loader',\n  'kind': 'load',\n  'success': ['load_confetti'],\n  'failed': [],\n  'msg_id': 'msg-10'},\n [])\n\n\nCheck the JS console network tab, we imported the confetti module previously.\n\nsrc = anysource('''\nconst { confetti } = await brdimport('https://esm.sh/canvas-confetti@1.6');\nconsole.log(confetti)\n''')\n\nbrd.send(dict(ctx='loader', cmd='load', args={'load_confetti': src}, reload=True), timeout=DEBUG(1))\n\n({'ctx': 'loader',\n  'kind': 'load',\n  'success': ['load_confetti'],\n  'failed': [],\n  'msg_id': 'msg-11'},\n [])\n\n\nbrdimport doesn’t re-import confetti too.\nNote the reload argument of the send method. bridge caches the modules by name and URL, and we’re reusing load_confetti name.\nUse cache=False if you don’t want bridge caching the module.",
    "crumbs": [
      "Bridge",
      "Bridge helpers"
    ]
  },
  {
    "objectID": "fasthtml_patching.html",
    "href": "fasthtml_patching.html",
    "title": "FastHTML patching",
    "section": "",
    "text": "This functionality patches FastHTML’s IPython display system\nThis implementation:\n\nOverrides all FT IPython MIME methods\nUses bridge_cfg.auto_show for display opt-in\n\n\nThis is a convenience and not core of this proof-of-concept notebooks.\n\nfh_cfg['auto_id'] = False\nbridge_cfg.auto_show = False\n\n\nd = Div(style='color: red;', hx_trigger='click')(Text('Hi!'))\nprint(f\"d: \\n{d}\"); display(Markdown('----'))\nprint(f\"showtags(d): \\n{showtags(d)}\"); display(Markdown('----'))\ndisplay(Markdown(highlight(d)+'\\n----'))\nshow(d)\n\nd: \n&lt;div hx-trigger=\"click\" style=\"color: red;\"&gt;&lt;text&gt;Hi!&lt;/text&gt;&lt;/div&gt;\n\n\n\n\n\nshowtags(d): \n&lt;code&gt;&lt;pre&gt;\n&lt;div hx-trigger=&quot;click&quot; style=&quot;color: red;&quot;&gt;\n&lt;text&gt;Hi!&lt;/text&gt;&lt;/div&gt;\n\n&lt;/code&gt;&lt;/pre&gt;\n\n\n\n\n\n&lt;div hx-trigger=\"click\" style=\"color: red;\"&gt;\n&lt;text&gt;Hi!&lt;/text&gt;&lt;/div&gt;\n\n\n\n\nHi!\n\n\n\nDiv(\"I'm a Div!\")\n\n&lt;div&gt;I&#x27;m a Div!&lt;/div&gt;\n\n\n@FC.patch\ndef _repr_mimebundle_(self: FT, include=None, exclude=None):\n    mb = {'text/plain': repr(self)}\n    if bridge_cfg.auto_show: mb['text/html'] = self.__html__()\n    else: mb['text/markdown'] = self._repr_markdown_()\n    return mb\n\nDiv('me too!')\n\n&lt;div&gt;me too!&lt;/div&gt;\n\n\n\nwith bridge_cfg(auto_show=True):\n    display(Div(\"But I'm prettier!\"))\n\nBut I'm prettier!\n\n\n\nDiv('back to tags!')\n\n&lt;div&gt;back to tags!&lt;/div&gt;\n\n\n\nbridge_cfg.auto_show = True\nft.Details(open=True)(ft.Summary('dddd'), ft.Pre('eeee'))\n\nddddeeee\n\n\n\nwith bridge_cfg(auto_show=False): display(ft.Button('ffff'))\nft.Button('ffff')\n\n&lt;button&gt;ffff&lt;/button&gt;\n\n\nffff\n\n\nRevert to FT usual.\n\ndel FT._repr_mimebundle_  # type: ignore\n\n\nDiv(\"I'm a Div!\")\n\n&lt;div&gt;I&#x27;m a Div!&lt;/div&gt;",
    "crumbs": [
      "Core Components",
      "FastHTML patching"
    ]
  },
  {
    "objectID": "fasthtml_patching.html#patching-fasthtml-jupyter-to-work-in-vscode",
    "href": "fasthtml_patching.html#patching-fasthtml-jupyter-to-work-in-vscode",
    "title": "FastHTML patching",
    "section": "Patching FastHTML jupyter to work in VSCode",
    "text": "Patching FastHTML jupyter to work in VSCode\n\nsource\n\nJupyUviB\n\n JupyUviB (app, log_level='error', host='0.0.0.0', port=8000, start=True,\n           **kwargs)\n\nStart and stop a Jupyter compatible uvicorn server with ASGI app on port with log_level\n\n# type: ignore\n\napp = FastHTML()\nrt = app.route\n\n@app.route\ndef index(): return 'hi'\n\nport = 8000\nserver = JupyUviB(app, port=port)\n\n\n\n\n\n\nget(f'http://localhost:{port}').text\n\n'hi'\n\n\n\nfh_cfg['auto_id']=True\n\n\nshow(Script(src='https://unpkg.com/htmx.org@2.0.4/dist/htmx.js'), fhjsscr, scopesrc, surrsrc)\nclear_output()  # so it doesn't import on notebook load\n\n\ndisplay(Javascript('''\nif (window.htmx) htmx.process(document.body);\n'''))\nclear_output()\n\n\nrender_ft()\n\nAfter importing fasthtml.jupyter and calling render_ft(), FT components render directly in the notebook.\n\n(c := Div('Cogito ergo sum'))\n\n\n  Cogito ergo sum\n\n\n\n\nHandlers are written just like a regular web app:\n\n# type: ignore\n\n@rt\ndef hoho(): return P('loaded!'), Div('hee hee', id=c, hx_swap_oob='true')\n\nAll the usual hx_* attributes can be used:\n\nP('not loaded', hx_get=hoho, hx_trigger='load')  # type: ignore\n\n\n  not loaded\n\n\n\n\nFT components can be used directly both as id values and as hx_target values.\n\n(c := Div(''))\n\n\n  \n\n\n\n\n\n# type: ignore\n\n@rt\ndef foo(): return Div('foo bar')\n\nP('hi', hx_get=foo, hx_trigger='load', hx_target=c)\n\n\n  hi",
    "crumbs": [
      "Core Components",
      "FastHTML patching"
    ]
  },
  {
    "objectID": "fasthtml_patching.html#stop-server",
    "href": "fasthtml_patching.html#stop-server",
    "title": "FastHTML patching",
    "section": "Stop server",
    "text": "Stop server\n\nserver.stop()",
    "crumbs": [
      "Core Components",
      "FastHTML patching"
    ]
  },
  {
    "objectID": "route_provider.html",
    "href": "route_provider.html",
    "title": "Routes provider",
    "section": "",
    "text": "def get_app():\n    return (app := nb_app()), TestClient(app, base_url='http://nb', headers={'hx-request': '1'}), app.route\n\napp, cli, rt = get_app()",
    "crumbs": [
      "Core Components",
      "Routes provider"
    ]
  },
  {
    "objectID": "route_provider.html#apirouterc",
    "href": "route_provider.html#apirouterc",
    "title": "Routes provider",
    "section": "APIRouterC",
    "text": "APIRouterC\nfasthtml.core.nested_name only considers static (possibly nested) functions.\nCurrent APIRouter (v0.12.0) has a minor issue in _wrap_func, it uses __name__ for the name of the route instead of __qualname__. I could patch it, but this subclass will do for now.\nAPIRouterC also has an alternative to rt_funcs, given the method name: - APIRouterC.to(name, …) return the full route path. - APIRouterC.name(name) return the full route name (if name was provided when adding the APIRouter). - can use HTTP methods as method names (though why?)",
    "crumbs": [
      "Core Components",
      "Routes provider"
    ]
  },
  {
    "objectID": "route_provider.html#apirouterd-1",
    "href": "route_provider.html#apirouterd-1",
    "title": "Routes provider",
    "section": "APIRouterD",
    "text": "APIRouterD\n\nsource\n\nAPIRouterD\n\n APIRouterD (*args, **kwargs)\n\nAdd routes to an app\n\nclass A:\n    ar = APIRouterD()\n\n    def __init__(self, value:int=3): self.value = value\n\n    @ar  # path /, name A_index\n    def index(self):\n        # int 0 is not a valid FastHTML return value\n        return self.value if self.value != 0 else HTMLResponse('0')\n\n    @ar  # or @ar.get or @ar.get('/a')\n    def a(self): return f'a {self.value}'\n\n    @ar.post('/a')\n    def a_change(self, x:int): self.value = x; return f'new value {x}'\n\n    @ar('/b')  # name A_b, , method [GET, POST]\n    def b(self): return f'b {self.value}'\n\n    @ar  \n    @staticmethod\n    def c(): return 'c'\n\n    @ar\n    @classmethod\n    def d(cls): return f'd {cls.__name__}'\n\n    @ar\n    @property  # path /e, name A_e, method GET\n    def e(self): return f'e {self.value}'  # type: ignore\n\n    @ar\n    @e.setter  # path /e, name A_e, method [POST, PUT]\n    def e(self, x:int): self.value = x; return x  # type: ignore\n\n    @ar  # path /e, name A_e, method DELETE\n    @e.deleter\n    def e(self): del self.value; return Response(status_code=204)\n\n    @ar('/f')\n    def get(self): return 'get'\n\n\na = A()\ntest_eq(a.b(), 'b 3')\ntest_is('bound' in str(a.a), True)\n\ntest_eq(A.ar.to('d'), '/d')\ntest_eq(A.ar.to('a', x=4), '/a?x=4')\n\n\napp, cli, _ = get_app()\n\na = A()\na.ar.to_app(app)\n\n\napp.routes\n\n[Route(path='/', name='index', methods=['GET', 'HEAD']),\n Route(path='/a', name='a', methods=['GET', 'HEAD']),\n Route(path='/a', name='a_change', methods=['POST']),\n Route(path='/b', name='b', methods=['GET', 'HEAD']),\n Route(path='/c', name='c', methods=['GET', 'HEAD']),\n Route(path='/d', name='d', methods=['GET', 'HEAD']),\n Route(path='/e', name='e', methods=['GET', 'HEAD']),\n Route(path='/e', name='e', methods=['POST', 'PUT']),\n Route(path='/e', name='e', methods=['DELETE']),\n Route(path='/f', name='get', methods=['GET', 'HEAD'])]\n\n\na is a normal instance of A.\nA.ar is an instance of APIRouterD, a subclass of APIRouterC. It has basic route instrospection (.to, .name), but its really a descriptor. Its main function is storing the routes precursors like APIRouter does. Once the instance a is created, it assigns a.ar with a normal APIRouterC. When ar.to_app(app) is called, the final route endpoints are binded to the instance and installed.\nNote that the APIRouter workflow setups the endpoints before calling to_app(app), endpoints are static functions. APIRouterC delays that setup until the very last moment, when to_app(app) is called. This lazy binding allows adding different routes in distinct scopes (see Adding routes to the app, add_routes() and mount()).\n\ntest_eq(cli.get('/').text, '3')\n\ntest_eq(cli.get('/a').text, 'a 3')\n\ntest_eq(cli.post('/a?x=5').text, 'new value 5')\ntest_eq(a.value, 5)\n\ntest_eq(cli.get('/b').text, 'b 5')\ntest_eq(cli.get('/c').text, 'c')\ntest_eq(cli.get('/d').text, 'd A')\n\ntest_eq(cli.get('/e').text, 'e 5')\ntest_eq(cli.post('/e?x=7').text, '7')\ntest_eq(a.value, 7)\ntest_eq(str(cli.delete('/e')), '&lt;Response [204 No Content]&gt;')\n\na.value = 0\ntest_eq(cli.get('/').text, '0')\n\ntest_eq(cli.get('/f').text, 'get')\n\n\ntest_eq(app.url_path_for('a'), '/a')\ntest_eq(app.url_path_for(a.ar.name('a')), '/a')\n\ntest_eq(str(a.ar.a), '/a')\ntest_eq(a.ar.a.to(), '/a')\ntest_eq(a.ar.to('a'), '/a')\ntest_eq(set([*filter(lambda r: r.path == '/a', app.routes)][0].methods), {'GET', 'HEAD'})  # type: ignore\n\nNote that ar can also setup properties as routes. Use as above, or simply once on the last descriptor function.\n\nclass A:\n    ar = APIRouterD()\n\n    def __init__(self, value:int=3): self.value = value\n\n    @property\n    def e(self): return f'e {self.value}'  # type: ignore\n\n    @e.setter\n    def e(self, x:int): self.value = x; return x  # type: ignore\n\n    @ar\n    @e.deleter\n    def e(self): del self.value; return Response(status_code=204)\n\n\napp, cli, _ = get_app()\n\na = A()\na.ar.to_app(app)\n\ntest_eq(cli.post('/e?x=3').text, '3')\ntest_eq(a.value, 3)\ntest_eq(str(cli.delete('/e')), '&lt;Response [204 No Content]&gt;')\n\n\ntest_eq(A.ar.to(), '')\ntest_eq(A.ar.to('e'), '/e')\nwith ExceptionExpected(AttributeError): A.ar.a\nwith ExceptionExpected(AttributeError): A.ar.rt_funcs.a\n\nwith ExceptionExpected(TypeError): A.ar.to_app(app)  # APIRouterD is not a valid APIRouter\n\nNote that the APIRouterD of the class, A.ar in the example above, is not an APIRouter, should be used only for basic route inspection. The one on the instance, a.ar, is the one which actually can register the routes and is, in fact, a normal APIRouter.\nAn APIRouterD routeis very alike FastHTML.route or APIRouter’s. But as its underlying endpoint is a method/property, it has some different behaviors:",
    "crumbs": [
      "Core Components",
      "Routes provider"
    ]
  },
  {
    "objectID": "route_provider.html#route-names",
    "href": "route_provider.html#route-names",
    "title": "Routes provider",
    "section": "route names",
    "text": "route names\n\napp, cli, rt = get_app()\n\n@rt('/a')\ndef a(): return 'a'\n\nprint(f\"{'route from a -&gt;':&gt;20}\", app.routes[-1])\ntest_eq(str(a), '/a')\ntest_eq(a.to(), app.url_path_for('a'))\ntest_eq(a.__routename__, 'a')\n\ndef b():\n    @rt('/a')\n    def c(): return 'c'\n    return c\n\nc = b()\n\nprint(f\"{'route from c -&gt;':&gt;20}\", app.routes[-1])\ntest_eq(str(c), '/a')\ntest_eq(c.to(), app.url_path_for('b_c'))\ntest_eq(c.__routename__, 'b_c')\n\nclass D:\n    ar = APIRouterD('/D')\n    @ar('/a')\n    def d(self): return 'd'\n\nd = D()\nd.ar.to_app(app)\n\nprint(app.routes)\n\nprint(f\"{'route from d.d -&gt;':&gt;20}\", app.routes[-1])\ntest_eq(str(d.ar.d), '/D/a')\ntest_eq(d.ar.d.to(), app.url_path_for('d'))\ntest_eq(d.ar.d.__routename__, 'd')\n\ntest_eq(d.ar.to('d'), d.ar.rt_funcs.d.to())\ntest_eq(d.ar.name('d'), 'd')\n\n     route from a -&gt; Route(path='/a', name='a', methods=['GET', 'HEAD', 'POST'])\n     route from c -&gt; Route(path='/a', name='b_c', methods=['GET', 'HEAD', 'POST'])\n[Route(path='/a', name='a', methods=['GET', 'HEAD', 'POST']), Route(path='/a', name='b_c', methods=['GET', 'HEAD', 'POST']), Route(path='/D/a', name='d', methods=['GET', 'HEAD'])]\n   route from d.d -&gt; Route(path='/D/a', name='d', methods=['GET', 'HEAD'])\n\n\n\nroute name is the method name, D_a in the example above, not d.\ndefault method is ‘get’.\nRoute Introspection: Methods don´t get the .to attribute, like the wrappers used in routes. But those wrappers are, discoverable through .ar (e.g. d.ar.d.to() or d.ar.to('d')).\nunlike @rt/APIRouter, it doesn’t wipe out (see _add_route) the underlying function from the scope (class def) for obvious reasons– base methods would probably be ok, properties not. Python classes can’t have methods with the same name– dicts, you know.\nIf you want to handle different HTTP methods, you must use different func names or set them explcitly with the route arguments and modify the function to handle the distinct requests (args or explicit request arg).\n\n\n\n\n\n\n\nNote\n\n\n\nLast point is a design decission. We could use metaclasses like fastcore transforms to introduce methods overriden by HTTP methods and in theory _mk_locfunc wrappers could function with methods (probably, not tested much). But I think a descriptor is already enough python dark magic for today :)",
    "crumbs": [
      "Core Components",
      "Routes provider"
    ]
  },
  {
    "objectID": "route_provider.html#fasthtml-notebooks-scope-state",
    "href": "route_provider.html#fasthtml-notebooks-scope-state",
    "title": "Routes provider",
    "section": "FastHTML, Notebooks, Scope & State",
    "text": "FastHTML, Notebooks, Scope & State\n\nCurrent APIRouter incarnation has a complicated relationship with scope and state.\n\n\ndef noelmeter(n): return f\"Ho {('ho '*n).strip()}!\"\n\nar = APIRouter()\nstate = {'count': 1}\n\n@ar(\"/ho\")\ndef ho(req):\n    return f\"{noelmeter(state['count'])} {ar.ho.to()} {req.url_for('ho')}\"\n\nNote that ho access globals state and ar.\n\napp,cli,_ = get_app()\nar.to_app(app)\nprint(app.routes)\n\n[Route(path='/ho', name='ho', methods=['GET', 'HEAD', 'POST'])]\n\n\n\ntest_eq(cli.get('/ho').text, 'Ho ho! /ho http://nb/ho')\ntest_eq(app.url_path_for('ho'), '/ho')\n\nNow let´s create another APIRouter with a separate state.\n\nar2 = APIRouter(\"/products\")\nstate2 = {'count': 3}\n\n@ar2(\"/ho\")\ndef ho(req):\n    return f\"{noelmeter(state2['count'])} {ar2.ho.to()} {req.url_for('ho')}\"\n\nar2.to_app(app)\nprint(app.routes)\n\n[Route(path='/ho', name='ho', methods=['GET', 'HEAD', 'POST']), Route(path='/products/ho', name='ho', methods=['GET', 'HEAD', 'POST'])]\n\n\nWe must use prefix to preserve ar routes when adding the new ones.\n\ntest_eq(cli.get('/ho').text, 'Ho ho! /ho http://nb/ho')\ntest_eq(cli.get('/products/ho').text, 'Ho ho ho ho! /products/ho http://nb/ho')  # &lt;-- wrong\n\ntest_eq(app.url_path_for('ho'), '/ho')\n\nRoutes @ /ho and /products/ho got the same name so either app or req can’t use reverse URL lookup to get the correct path of ar2.ho.\nWe may need to add ar2 to another app because both ar and ar2 routes share names, and then install app2 as a submount.\n\napp.routes.clear()\nar.to_app(app)\n\nar2 = APIRouter()  # we can`t use prefix here\n\n@ar2(\"/ho\")\ndef ho(req):\n    return f\"{noelmeter(state2['count'])} {ar2.ho.to()} {req.url_for('ho')}\"\n\napp2,cli2,_ = get_app()\nar2.to_app(app2)\n\napp.routes.append(Mount('/products', app2))\nprint(app.routes)\nprint(app.routes[-1].app.routes)  # type: ignore\n\n[Route(path='/ho', name='ho', methods=['GET', 'HEAD', 'POST']), Mount(path='/products', name='', app=&lt;fasthtml.core.FastHTML object at 0x1482269c0&gt;)]\n[Route(path='/ho', name='ho', methods=['GET', 'HEAD', 'POST'])]\n\n\n\ntest_eq(cli.get('/ho').text, 'Ho ho! /ho http://nb/ho')\ntest_eq(cli.get('/products/ho').text, 'Ho ho ho ho! /ho http://nb/ho')  # &lt;-- wrong\n\ntest_eq(app.url_path_for('ho'), '/ho')\n\nNope. We can´t rely on req.url_for(...) or app.url_path_fpr(...) unless we add another global dependency.\n\napp.routes.clear()\nar.to_app(app)\n\nar2 = APIRouter()\n\n@ar2(\"/ho\")\ndef ho(req):\n    return f\"{noelmeter(state2['count'])} /products{ar2.ho.to()} {req.url_for('products:ho')}\"  # or\n        #  f\"{noelmeter(state2['count'])} {ar2.prefix}{ar2.ho.to()} {req.url_for('products:ho')}\"\n\napp2,cli2,_ = get_app()\nar2.to_app(app2)\napp.routes.append(Mount('/products', app2, name='products'))  # &lt;-- assume `ar2` mounted with the name `products`\n\n\ntest_eq(cli.get('/ho').text, 'Ho ho! /ho http://nb/ho')\ntest_eq(cli.get('/products/ho').text, 'Ho ho ho ho! /products/ho http://nb/products/ho')\n\ntest_eq(app.url_path_for('ho'), '/ho')\ntest_eq(app.url_path_for('products:ho'), '/products/ho')\n\nThe fix above finally works. But now not only ho depends on globals ar2 and state2, also on knowledge of the mount route name.",
    "crumbs": [
      "Core Components",
      "Routes provider"
    ]
  },
  {
    "objectID": "route_provider.html#add_routes",
    "href": "route_provider.html#add_routes",
    "title": "Routes provider",
    "section": "add_routes",
    "text": "add_routes\nBesides support for methods, APIRouterC also has features to ease adding/mounting APIRouters.\n\nsource\n\nmount\n\n mount (app:fasthtml.core.FastHTML,\n        prov:fasthtml.core.APIRouter|__main__.RouteProviderP,\n        path:str|None=None, name:str|None=None)\n\n\nsource\n\n\nadd_routes\n\n add_routes\n             (prov:fasthtml.core.APIRouter|__main__.RouteProviderP|typing.\n             Any, mount:bool=False, path:str|None=None,\n             name:str|None=None, appcls:Callable=&lt;function nb_app&gt;)\n\nRegister provider routes\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nprov\nfasthtml.core.APIRouter | main.RouteProviderP | typing.Any\n\nAPIRouterC or RouteProvider\n\n\nmount\nbool\nFalse\nmount routes under path; if false will add routes under APIRouter prefix\n\n\npath\nstr | None\nNone\nif mount, submount path (or auto-generated based on prov class)\n\n\nname\nstr | None\nNone\nif mount, name for submount (or auto-generated based on path)\n\n\nappcls\nCallable\nnb_app\nuse FastHTML factory for submounts\n\n\nReturns\nAPIRouter\n\n\n\n\n\nadd_routes handles two scenarios: 1. mount is False. This is equivalent to APIRouter.to_app, the routes are available under APIRuter.prefix. 2. mount is True. The routes are mounted under path and are available under path/prefix.\nApp routes can be organized at two levels: 1. root Level: Global routes 2. Provider Level: Scoped routes defined by providers\nThis allows for clean organization of routes and natural encapsulation of component behavior directly in the notebook. This will be handy when we start defining ipywidgets like widgets with FastHTML.\nThough I think it’s convenient, you don’t need to mount routes providers at all, add its routes directly to the root level app.\n\nar = APIRoute\n\n\nclass Counter(RouteProvider):\n    def __init__(self, value:int=0): self._value = value\n    \n    @ar('/value', name='value')\n    def get_value(self): \n        return self._value  # `0` is not a valid FastHTML response\n    \n    @ar('/inc')\n    def increment(self, x:int=1): \n        self._value += x\n        return self.get_value()\n\n\napp, cli, _ = get_app()\n\ncounter = Counter()\nadd_routes(app, counter)\nprint(app.routes)\n\ntest_eq(cli.get('/value').text, '')\ntest_eq(cli.get('/inc').text, '1')\n\n[Route(path='/value', name='value', methods=['GET', 'HEAD']), Route(path='/inc', name='increment', methods=['GET', 'HEAD'])]\n\n\nAdd routes to apps (notebook-level app above). Routes available under {self.ar.prefix}/... or {self.ar.to()}/...\nadd_routes returns the APIRouter used to define the routes.\n\ncounter2 = Counter(7)\nadd_routes(app, counter2)\nprint(app.routes)\n\ntest_eq(cli.get('/value').text, '7')\ntest_eq(cli.get(f\"{counter2.ar.to()}/value\").text, '7')\n\n[Route(path='/value', name='value', methods=['GET', 'HEAD']), Route(path='/inc', name='increment', methods=['GET', 'HEAD'])]\n\n\nNote, however, routes are bound to a given Counter instance. Existing routes will be overwritten if you add routes from another instance.\n\ncounter3 = Counter(17)\n# car3 = add_routes(app, counter3, path='/counter', name='cnt')  # routes under /... and /counter/...\ncar3 = add_routes(app, counter3, path='/counter')  # routes under /... and /counter/...\nprint(app.routes)\nprint(app.routes[-1].app.routes)  # type: ignore\n\ntest_is(counter3.ar, car3)\n\ntest_eq(cli.get('/inc').text, '8')\n\ntest_eq(cli.get(car3.get_value.to()).text, '17')\ntest_eq(cli.get('/counter/inc').text, '18')\ntest_eq(app.url_path_for('value'), '/value')\ntest_eq(app.url_path_for(car3.name('value')), '/counter/value')\n\n[Route(path='/value', name='value', methods=['GET', 'HEAD']), Route(path='/inc', name='increment', methods=['GET', 'HEAD']), Mount(path='/counter', name='counter', app=&lt;fasthtml.core.FastHTML object at 0x148226570&gt;)]\n[Route(path='/value', name='value', methods=['GET', 'HEAD']), Route(path='/inc', name='increment', methods=['GET', 'HEAD'])]\n\n\nYou can add instance routes under different path prefix.\nNote add_routes with path argument will auto generate a name for the route if not provided.\n\ncounter32 = Counter(177)\ncar32= add_routes(app, counter32, path='/counter', name='cnt')  # routes under /... and /counter/...\nprint(app.routes)\nprint(app.routes[-1].app.routes)  # type: ignore\n\ntest_eq(cli.get(car32.get_value.to()).text, '177')\ntest_eq(cli.get('/counter/inc').text, '178')\ntest_eq(app.url_path_for('value'), '/value')\ntest_eq(app.url_path_for(car32.name('value')), '/counter/value')\n\n[Route(path='/value', name='value', methods=['GET', 'HEAD']), Route(path='/inc', name='increment', methods=['GET', 'HEAD']), Mount(path='/counter', name='cnt', app=&lt;fasthtml.core.FastHTML object at 0x148226840&gt;)]\n[Route(path='/value', name='value', methods=['GET', 'HEAD']), Route(path='/inc', name='increment', methods=['GET', 'HEAD'])]\n\n\nUse mount to submount APIRouters under class name (or add_routes(..., mount=True, ...)).\n\ncounter4 = Counter(23)\ncar4 = mount(app, counter4, '/counter', 'counter')  # routes under /..., /counter/..., and /Counter/counter/...\nprint(app.routes)\nprint(app.routes[-1].app.routes)  # type: ignore\nprint(app.routes[-1].app.routes[-1].routes)  # type: ignore\n\ntest_eq(cli.get('/inc').text, '9')\ntest_eq(cli.get('/counter/inc').text, '179')\n\ntest_eq(cli.get('/Counter/counter/value').text, '23')\ntest_eq(cli.get('/Counter/counter/inc').text, '24')\ntest_eq(cli.get(car4.get_value.to()).text, '24')\ntest_eq(cli.get(f\"{car4.to()}/value\").text, '24')\ntest_eq(car4.name('increment'), 'Counter:counter:increment')\n\n[Route(path='/value', name='value', methods=['GET', 'HEAD']), Route(path='/inc', name='increment', methods=['GET', 'HEAD']), Mount(path='/counter', name='cnt', app=&lt;fasthtml.core.FastHTML object at 0x148226840&gt;), Mount(path='/Counter', name='Counter', app=&lt;fasthtml.core.FastHTML object at 0x14823f440&gt;)]\n[Mount(path='/counter', name='counter', app=&lt;fasthtml.core.FastHTML object at 0x14823e510&gt;)]\n[Route(path='/value', name='value', methods=['GET', 'HEAD']), Route(path='/inc', name='increment', methods=['GET', 'HEAD'])]\n\n\nMount with explicit path.\nAn APIRouterC from an instance, discloses its mounted name with self.ar.name().\n\ncounter5 = Counter(-7)\ncar5 = mount(app, counter5)  # routes under /counter/..., and root.\nprint(app.routes)\nprint(app.routes[-1].app.routes)  # type: ignore\nprint(app.routes[-1].app.routes[-1].routes)  # type: ignore\n\ntest_eq(cli.get(f\"{car5.to()}/value\").text, '-7')\ntest_eq(cli.get(f\"{car5.increment.to()}\").text, '-6')\ntest_eq(cli.get(car5.to('increment')).text, '-5')\n\n[Route(path='/value', name='value', methods=['GET', 'HEAD']), Route(path='/inc', name='increment', methods=['GET', 'HEAD']), Mount(path='/counter', name='cnt', app=&lt;fasthtml.core.FastHTML object at 0x148226840&gt;), Mount(path='/Counter', name='Counter', app=&lt;fasthtml.core.FastHTML object at 0x14823f440&gt;)]\n[Mount(path='/counter', name='counter', app=&lt;fasthtml.core.FastHTML object at 0x14823e510&gt;), Mount(path='/Counter_1-1764770681', name='Counter_1-1764770681', app=&lt;fasthtml.core.FastHTML object at 0x1482609b0&gt;)]\n[Route(path='/value', name='value', methods=['GET', 'HEAD']), Route(path='/inc', name='increment', methods=['GET', 'HEAD'])]\n\n\nMount routes with automatic path generation.\n\ncounter6 = Counter(111)\ncar6 = mount(app, counter6, path='/')\nprint(app.routes)\nprint(app.routes[-1].app.routes)  # type: ignore\n\ntest_eq(cli.get(f\"{car6.prefix}/value\").text, '111')\ntest_eq(cli.get(car6.to('increment')).text, '112')\n\n[Route(path='/value', name='value', methods=['GET', 'HEAD']), Route(path='/inc', name='increment', methods=['GET', 'HEAD']), Mount(path='/counter', name='cnt', app=&lt;fasthtml.core.FastHTML object at 0x148226840&gt;), Mount(path='/Counter', name='Counter', app=&lt;fasthtml.core.FastHTML object at 0x14823f440&gt;)]\n[Mount(path='/counter', name='counter', app=&lt;fasthtml.core.FastHTML object at 0x14823e510&gt;), Mount(path='/Counter_1-1764770681', name='Counter_1-1764770681', app=&lt;fasthtml.core.FastHTML object at 0x1482609b0&gt;), Route(path='/value', name='value', methods=['GET', 'HEAD']), Route(path='/inc', name='increment', methods=['GET', 'HEAD'])]\n\n\ncounter_6 routes added at Counter submount as root routes.\nThus add_routes can be used to add routes to an app with instance-based routes: - mount=False, path=None =&gt; root-level routes (e.g. /inc). Equivalent to FastHTML APIRouter.to_app - mount=False, path=…: root-level subroutes (e.g. /counter/inc). Equivalent to FastHTML APIRouter.to_app + prefix - mount=True, path=None =&gt; auto routes scoped under class name (e.g. /Counter/inc ) - mount=True, path=… =&gt; auto routes scoped under class name and path (e.g. /Counter/counter/inc )",
    "crumbs": [
      "Core Components",
      "Routes provider"
    ]
  },
  {
    "objectID": "00_common.html",
    "href": "00_common.html",
    "title": "bridget",
    "section": "",
    "text": "_ks1 = set(globals().keys())\n\n\n[k for k in globals().keys() - _ks1 if not k.startswith('_')]\n\n['HTML',\n 'bridge_cfg',\n 'this',\n 'get_nb',\n 'RouteProvider',\n 'get_app',\n 'DetailsJSON',\n 'ar',\n 'get_bridget',\n 'NB',\n 'NBState',\n 'get_bridge']"
  },
  {
    "objectID": "packages_README.html",
    "href": "packages_README.html",
    "title": "Bridget Extensions",
    "section": "",
    "text": "Companion extensions that enable Bridget to access notebook state in real-time.\n\n\nJupyter/VSCode kernels don’t know about notebook structure (cells, outputs, order). These extensions monitor the notebook in the front-end and make that state available to Bridget.\n\n\n\n\n\nVSCode/Cursor extension. See nbinspect-vscode/README.md.\nInstallation: Install .vsix file from Extensions view\nUsers: VSCode, Cursor notebook users\n\n\n\nJupyterLab/Jupyter Notebook extension. See nbinspect-lab/README.md.\nInstallation: pip install (part of Bridget)\nUsers: JupyterLab, Jupyter Notebook 7+ users\n\n\n\n\nBoth extensions: 1. Monitor notebook events (cell changes, execution) 2. Build/maintain notebook state 3. Expose via window.$Nb API 4. Bridge widgets subscribe to state changes\nNote: These are maintainer-level packages. End users just install them as part of Bridget setup."
  },
  {
    "objectID": "packages_README.html#why-extensions",
    "href": "packages_README.html#why-extensions",
    "title": "Bridget Extensions",
    "section": "",
    "text": "Jupyter/VSCode kernels don’t know about notebook structure (cells, outputs, order). These extensions monitor the notebook in the front-end and make that state available to Bridget."
  },
  {
    "objectID": "packages_README.html#packages",
    "href": "packages_README.html#packages",
    "title": "Bridget Extensions",
    "section": "",
    "text": "VSCode/Cursor extension. See nbinspect-vscode/README.md.\nInstallation: Install .vsix file from Extensions view\nUsers: VSCode, Cursor notebook users\n\n\n\nJupyterLab/Jupyter Notebook extension. See nbinspect-lab/README.md.\nInstallation: pip install (part of Bridget)\nUsers: JupyterLab, Jupyter Notebook 7+ users"
  },
  {
    "objectID": "packages_README.html#common-architecture",
    "href": "packages_README.html#common-architecture",
    "title": "Bridget Extensions",
    "section": "",
    "text": "Both extensions: 1. Monitor notebook events (cell changes, execution) 2. Build/maintain notebook state 3. Expose via window.$Nb API 4. Bridge widgets subscribe to state changes\nNote: These are maintainer-level packages. End users just install them as part of Bridget setup."
  },
  {
    "objectID": "nb_hooks.html",
    "href": "nb_hooks.html",
    "title": "Notebook/IPython hooks",
    "section": "",
    "text": "source",
    "crumbs": [
      "Notebook State",
      "Notebook/IPython hooks"
    ]
  },
  {
    "objectID": "nb_hooks.html#displayid",
    "href": "nb_hooks.html#displayid",
    "title": "Notebook/IPython hooks",
    "section": "DisplayId",
    "text": "DisplayId\nAn attempt to provide a IPython display wrapper that automatically handles the display ID to allow us to target especific cells. Not working, for now it’s essentially just IPython display.\n\nclass DisplayId(DisplayHandle):\n    def __init__(self, display_id=None):\n        super().__init__(display_id or new_id())\n        self._contents = None\n        self._sc = to_xml(autoid(self.display_id)[0]) if bridge_cfg.auto_id else ''\n\n    def display(self, obj='', **kwargs):\n        self._contents = str(obj)\n        IDISPLAY(HTML(self._contents + self._sc), display_id=self.display_id, **kwargs)\n\n    def update(self, obj='', **kwargs):\n        kwargs['update'] = True\n        self.display(obj, **kwargs)\n\n    def contents(self): return self._contents\n\n\ndhdl = DisplayId()\ndhdl.display('dddd')\ntest_eq(dhdl.contents(), 'dddd')\n\n\n\n\n\ndhdl.update('eeee')\ntest_eq(dhdl.contents(), 'eeee')\n\n\ndhdl.update()",
    "crumbs": [
      "Notebook State",
      "Notebook/IPython hooks"
    ]
  },
  {
    "objectID": "nb_hooks.html#set-display_id-with-display-call-metadata",
    "href": "nb_hooks.html#set-display_id-with-display-call-metadata",
    "title": "Notebook/IPython hooks",
    "section": "set display_id with display call metadata",
    "text": "set display_id with display call metadata\n\ni.e., display(..., display_id=True) or display(..., display_id=\"...\")\n\n\ndh = display(HTML(\"&lt;div&gt;I'm marked!... MAAARKED!!&lt;/div&gt;\"), display_id=True)\ncell = __nb__[__cellinfo__.cell_id]\ntest_eq(at(cell, 'outputs.0.metadata.brd_did'), brdd.dh.display_id)  # type: ignore\ncell\n\nI'm doomed!... DOOOOOMED!!\n\n\n\n\nNBCell@5\n  \n    \nidx: 5    \n    \nsource: dh = display(HTML(\"&lt;div&gt;I'm marked!... MAAARKED!!&lt;/div&gt;\"), display_id=True)\ncell = __nb__[__cellinfo__.cell_id]\ntest_eq(at(cell, 'outputs.0.…    \n    \nid: Y132sZmlsZQ==    \n    \ncell_type: code    \noutputs\n      \n0\n          \n            \noutput_type: display_data            \ndata\n              \n                \ntext/plain: &lt;IPython.core.display.HTML object&gt;                \n                \ntext/html: &lt;div&gt;I'm marked!... MAAARKED!!&lt;/div&gt;\n&lt;brd-mark id=\"e2ffaa8dc80ef2623bc8eb433633f96a\"&gt;&lt;/brd-mark&gt;                \n              \n            \nmetadata: {'brd_did': 'e2ffaa8dc80ef2623bc8eb433633f96a'}            \n          \n      \n  \n\n\n\n{\n    ...,\n    'msg_type': 'display_data',\n    'content': {\n        'data': {\n            'text/plain': '&lt;IPython.core.display.HTML object&gt;', \n            'text/html': \"&lt;div&gt;I'm marked!... MAAARKED!!&lt;/div&gt;\"\n        },\n        'metadata': {},\n        'transient': {'display_id': '2307db4acc4fda0ba305ffdda518748a'}\n    },\n    'metadata': {}\n}\n\n{\n    ...,\n    'msg_type': 'display_data',\n.    'content': {\n        'data': {\n            'text/plain': '&lt;IPython.core.display.HTML object&gt;',\n            'text/html': '&lt;div&gt;I\\'m marked!... MAAARKED!!&lt;/div&gt;&lt;brd-mark id=\"2307db4acc4fda0ba305ffdda518748a\"&gt;&lt;/brd-mark&gt;'\n        },\n        'metadata': {'brd_did': '2307db4acc4fda0ba305ffdda518748a'},\n        'transient': {'display_id': '2307db4acc4fda0ba305ffdda518748a'}\n    },\n    'metadata': {}\n}\n\nbrdd.dh.update(HTML(\"&lt;div&gt;I'm doomed!... DOOOOOMED!!&lt;/div&gt;\"))  # type: ignore\ncell\n\n\nNBCell@5\n  \n    \nidx: 5    \n    \nsource: dh = display(HTML(\"&lt;div&gt;I'm marked!... MAAARKED!!&lt;/div&gt;\"), display_id=True)\ncell = __nb__[__cellinfo__.cell_id]\ntest_eq(at(cell, 'outputs.0.…    \n    \nid: Y132sZmlsZQ==    \n    \ncell_type: code    \noutputs\n      \n0\n          \n            \noutput_type: display_data            \ndata\n              \n                \ntext/plain: &lt;IPython.core.display.HTML object&gt;                \n                \ntext/html: &lt;div&gt;I'm doomed!... DOOOOOMED!!&lt;/div&gt;\n&lt;brd-mark id=\"e2ffaa8dc80ef2623bc8eb433633f96a\"&gt;&lt;/brd-mark&gt;                \n              \n            \nmetadata: {'brd_did': 'e2ffaa8dc80ef2623bc8eb433633f96a'}            \n          \n1\n          \n            \noutput_type: execute_result            \n            \nexecution_count: 55            \ndata\n              \n                \ntext/plain: {'idx': 5,\n 'source': 'dh = display(HTML(\"&lt;div&gt;I\\'m marked!... MAAARKED!!&lt;/div&gt;\"), display_id=True)\\ncell = __nb__[__cellinfo__.cell_id]\\nte…                \n                \ntext/html: &lt;style&gt;details ul { list-style-type:none; list-style-position: outside; padding-inline-start: 22px; margin: 0; } details .string { color: #2…                \n                \ntext/markdown: &gt; code\n\n```json\n{\n  'idx': 5,\n  'source': 'dh = display(HTML(\"&lt;div&gt;I\\'m marked!... MAAARKED!!&lt;/div&gt;\"), display_id=True)\\ncell = __nb__[__cel…                \n              \n            \nmetadata: {}            \n          \n      \n    \nexecution_count: 55    \n  \n\n\n\n{\n    ...,\n    'msg_type': 'update_display_data',\n    'content': {\n        'data': {'text/plain': '&lt;IPython.core.display.HTML object&gt;', 'text/html': \"&lt;div&gt;I'm doomed!... DOOOOOMED!!&lt;/div&gt;\"},\n        'metadata': {},\n        'transient': {'display_id': 'c3d21633d341d2463f13ef40730e8c4a'}\n    },\n    'metadata': {}\n}\n\n{\n    ...,\n    'msg_type': 'update_display_data',\n    'content': {\n        'data': {\n            'text/plain': '&lt;IPython.core.display.HTML object&gt;',\n            'text/html': '&lt;div&gt;I\\'m doomed!... DOOOOOMED!!&lt;/div&gt;&lt;brd-mark id=\"c3d21633d341d2463f13ef40730e8c4a\"&gt;&lt;/brd-mark&gt;'\n        },\n        'metadata': {},\n        'transient': {'display_id': 'c3d21633d341d2463f13ef40730e8c4a'}\n    },\n    'metadata': {}\n}\n\ndisplay('aaaa', display_id=new_id());\n\nbbbb\n\n\n\n\nbrdd.dh.update(HTML(\"bbbb\"))  # type: ignore\n\n\ndisplay('cccc', metadata={'bridge': {'brd_did': new_id()}})\n\ndddd\n\n\n\n\nbrdd.dh.update(HTML(\"dddd\"))  # type: ignore\n\n\ndisplay('eeee', metadata={'test/plain': {'brd_did': new_id()}})\ntest_eq(__nb__[__cellinfo__.cell_id].outputs[0].data['text/plain'], \"'eeee'\")\n\nffff\n\n\n\nbrdd.dh.update(Markdown(\"ffff\"))  # type: ignore\ntest_eq(__nb__[__cellinfo__.cell_id].outputs, [])",
    "crumbs": [
      "Notebook State",
      "Notebook/IPython hooks"
    ]
  },
  {
    "objectID": "nb_hooks.html#multi-objects-display",
    "href": "nb_hooks.html#multi-objects-display",
    "title": "Notebook/IPython hooks",
    "section": "Multi objects display",
    "text": "Multi objects display\n\ndh = display(\n    HTML(\"&lt;div&gt;Multi 1&lt;/div&gt;\"), \n    HTML(\"&lt;div&gt;Multi 2&lt;/div&gt;\"), \n    display_id=True)\n\nMulti 1\n\n\n\nMulti 3\n\n\n\n\n(cell := __nb__[__lastcellinfo__.cell_id])\n\n\nNBCell@13\n  \n    \nidx: 13    \n    \nsource: dh = display(\n    HTML(\"&lt;div&gt;Multi 1&lt;/div&gt;\"), \n    HTML(\"&lt;div&gt;Multi 2&lt;/div&gt;\"), \n    display_id=True)    \n    \nid: Y150sZmlsZQ==    \n    \ncell_type: code    \noutputs\n      \n0\n          \n            \noutput_type: display_data            \ndata\n              \n                \ntext/plain: &lt;IPython.core.display.HTML object&gt;                \n                \ntext/html: &lt;div&gt;Multi 1&lt;/div&gt;\n&lt;brd-mark id=\"6ff9be5be58ae578558d4b803e5a6b9e\"&gt;&lt;/brd-mark&gt;                \n              \n            \nmetadata: {'brd_did': '6ff9be5be58ae578558d4b803e5a6b9e'}            \n          \n1\n          \n            \noutput_type: display_data            \ndata\n              \n                \ntext/plain: &lt;IPython.core.display.HTML object&gt;                \n                \ntext/html: &lt;div&gt;Multi 2&lt;/div&gt;\n&lt;brd-mark id=\"6ff9be5be58ae578558d4b803e5a6b9e\"&gt;&lt;/brd-mark&gt;                \n              \n            \nmetadata: {'brd_did': '6ff9be5be58ae578558d4b803e5a6b9e'}            \n          \n      \n    \nexecution_count: 63    \n  \n\n\n\n\nif dh: dh.update(HTML(\"&lt;div&gt;Multi 3&lt;/div&gt;\"))\ncell\n\n\nNBCell@13\n  \n    \nidx: 13    \n    \nsource: dh = display(\n    HTML(\"&lt;div&gt;Multi 1&lt;/div&gt;\"), \n    HTML(\"&lt;div&gt;Multi 2&lt;/div&gt;\"), \n    display_id=True)    \n    \nid: Y150sZmlsZQ==    \n    \ncell_type: code    \noutputs\n      \n0\n          \n            \noutput_type: display_data            \ndata\n              \n                \ntext/plain: &lt;IPython.core.display.HTML object&gt;                \n                \ntext/html: &lt;div&gt;Multi 1&lt;/div&gt;\n&lt;brd-mark id=\"6ff9be5be58ae578558d4b803e5a6b9e\"&gt;&lt;/brd-mark&gt;                \n              \n            \nmetadata: {'brd_did': '6ff9be5be58ae578558d4b803e5a6b9e'}            \n          \n1\n          \n            \noutput_type: display_data            \ndata\n              \n                \ntext/plain: &lt;IPython.core.display.HTML object&gt;                \n                \ntext/html: &lt;div&gt;Multi 3&lt;/div&gt;\n&lt;brd-mark id=\"6ff9be5be58ae578558d4b803e5a6b9e\"&gt;&lt;/brd-mark&gt;                \n              \n            \nmetadata: {'brd_did': '6ff9be5be58ae578558d4b803e5a6b9e'}            \n          \n      \n    \nexecution_count: 63    \n  \n\n\n\nWhen using transient display messages with the display function, multi objects display is ill-defined.\nIPython display assign the same display_id to each object. The front-end however will handle it differently.\nVSCode displays all objects but only consider transient the last one.\nLab/Notebook repeats the last object as many times as the number of objects sent.\n\ndisplay(\n    HTML(\"&lt;div&gt;Multi 1&lt;/div&gt;\", metadata={'brd_did': (did1 := new_id())}), \n    HTML(\"&lt;div&gt;Multi 2&lt;/div&gt;\", metadata={'brd_did': (did2 := new_id())})\n)\n\nMulti 1\n\n\n\nMulti 4\n\n\n\n\ncell = __nb__[__lastcellinfo__.cell_id]\ntest_eq(cell.dids, [did1, did2])\n\n\ndh1, dh2 = brdd.dhs[-2], brdd.dhs[-1]\ntest_eq(dh1.display_id, did1)\ntest_eq(dh2.display_id, did2)\ndh1.update(HTML(\"&lt;div&gt;Multi 3&lt;/div&gt;\"))\ntime.sleep(0.01)\ndh2.update(HTML(\"&lt;div&gt;Multi 4&lt;/div&gt;\"))\n\nWe can sidestep the issue by using specific Bridge metadata.",
    "crumbs": [
      "Notebook State",
      "Notebook/IPython hooks"
    ]
  },
  {
    "objectID": "nb_hooks.html#skip",
    "href": "nb_hooks.html#skip",
    "title": "Notebook/IPython hooks",
    "section": "skip",
    "text": "skip\n\ndisplay(Markdown(\"Skipped\"), metadata={'bridge': {'skip': True}})\ndisplay(\"Me too\", JSON({\"And me\": True}), metadata=skip())\n\nSkipped\n\n\n'Me too'\n\n\n&lt;IPython.core.display.JSON object&gt;\n\n\n\n__nb__[__lastcellinfo__.cell_id]\n\n\nNBCell@19\n  \n    \nidx: 19    \n    \nsource: display(Markdown(\"Skipped\"), metadata={'bridge': {'skip': True}})\ndisplay(\"Me too\", JSON({\"And me\": True}), metadata=skip())    \n    \nid: Y162sZmlsZQ==    \n    \ncell_type: code    \noutputs\n      \n0\n          \n            \noutput_type: display_data            \ndata\n              \n                \ntext/plain: &lt;IPython.core.display.Markdown object&gt;                \n                \ntext/markdown: Skipped                \n              \n            \nmetadata: {'bridge': {'skip': True}}            \n          \n1\n          \n            \noutput_type: display_data            \ndata\n              \n                \ntext/plain: 'Me too'                \n              \n            \nmetadata: {'bridge': {'skip': True}}            \n          \n2\n          \n            \noutput_type: display_data            \ndata\n              \n                \ntext/plain: &lt;IPython.core.display.JSON object&gt;                \n                \napplication/json: {'And me': True}                \n              \n            \nmetadata: {'application/json': {'expanded': False, 'root': 'root'}, 'bridge': {'skip': True}}            \n          \n      \n    \nexecution_count: 69    \n  \n\n\n\nSkip tagging all display objects.\n\ndisplay(\n    HTML(\"Skipped\", metadata={'skip':True, 'brd_did':(did1 := new_id())}),\n    HTML(\"Not me\", metadata={'brd_did':(did2 := new_id())}),\n)\n\nSkipped\n\n\nNot me\n\n\n\n\ncell = __nb__[__lastcellinfo__.cell_id]\ntest_eq(cell.dids, [did2])\ncell\n\n\nNBCell@21\n  \n    \nidx: 21    \n    \nsource: display(\n    HTML(\"Skipped\", metadata={'skip':True, 'brd_did':(did1 := new_id())}),\n    HTML(\"Not me\", metadata={'brd_did':(did2 := new_id()…    \n    \nid: Y165sZmlsZQ==    \n    \ncell_type: code    \noutputs\n      \n0\n          \n            \noutput_type: display_data            \ndata\n              \n                \ntext/plain: &lt;IPython.core.display.HTML object&gt;                \n                \ntext/html: Skipped                \n              \n            \nmetadata: {'text/html': {'skip': True, 'brd_did': 'b19bbdaeb-1ae6ed40-ce525c18-23d81243'}}            \n          \n1\n          \n            \noutput_type: display_data            \ndata\n              \n                \ntext/plain: &lt;IPython.core.display.HTML object&gt;                \n                \ntext/html: Not me\n&lt;brd-mark id=\"b55581abb-bb1b69e3-6f11a7e8-f4d20014\"&gt;&lt;/brd-mark&gt;                \n              \n            \nmetadata: {'brd_did': 'b55581abb-bb1b69e3-6f11a7e8-f4d20014'}            \n          \n      \n    \nexecution_count: 71    \n  \n\n\n\nSkip specific display object.",
    "crumbs": [
      "Notebook State",
      "Notebook/IPython hooks"
    ]
  },
  {
    "objectID": "nb_hooks.html#bridge_cfg.auto_id",
    "href": "nb_hooks.html#bridge_cfg.auto_id",
    "title": "Notebook/IPython hooks",
    "section": "bridge_cfg.auto_id",
    "text": "bridge_cfg.auto_id\nif bridge_cfg.auto_id is True, there’s no need to use bridge metadata. Every supported displayed object (see _BRDD_MIMES) will receive an auto-generated display id.\nCaveat: be aware that VSCode limits the number of transient display ids (1000 last time I checked); not Jupyter, I believe.\n\nbridge_cfg.auto_id = True\n\ndisplay(HTML(\"&lt;div&gt;I'm auto-id'd--&lt;/div&gt;\"))\n\n--as shown above.\n\n\n\n\nbrdd.dhs[-1].update(HTML(\"&lt;div&gt;--as shown above.&lt;/div&gt;\"))\n\n\ndisplay(Markdown(f\"## did\\n???\"))\n\n&lt;IPython.core.display.JSON object&gt;\n\n\n\ndh = brdd.dhs[-1]\ndh.update(HTML(f\"&lt;b&gt;did&lt;/b&gt;: {dh.display_id}\"))\n\n\ndh.update(JSON({'did': dh.display_id}))\n\n\ndhs = []\nfor i in range(5): \n    display(f'{i=}')\n    dhs.append(brdd.dhs[-1])\n\n'i+1=1'\n\n\n'i+1=2'\n\n\n'i+1=3'\n\n\n'i+1=4'\n\n\n'i+1=5'\n\n\n\nfor i in range(5): \n    dhs[i].update(f'{i+1=}')\n\n\nbrdd.dhs.clear()\nbrdd.stop()\ncsi.stop()\nbridge_cfg.auto_id = False\n\n\n\ndef show_msgs(brdd: Bridged):\n    for msg in brdd.msgs.copy():\n        d = msg.copy()\n        # d['parent_header'] = {'...': '...'}\n        # d['header'] = {'...': '...'}\n        del d['parent_header'], d['header'], d['tracker'], d['msg_id']\n        if not d['metadata']: del d['metadata']\n        try: del d['content']['data']['text/plain']\n        except: pass\n        if h := d['content']['data'].get('text/html'): d['content']['data']['text/html'] = shorten(h, 'r', 120)\n        cprint(d)\n\nif DEBUG(): show_msgs(brdd)\n\n\nfor c in __nb__.cells: display(c)",
    "crumbs": [
      "Notebook State",
      "Notebook/IPython hooks"
    ]
  },
  {
    "objectID": "javascript_extensions.html",
    "href": "javascript_extensions.html",
    "title": "JavaScript & Extensions",
    "section": "",
    "text": "Bridget includes browser-side JavaScript modules that handle:\n\nCommunication: Bridge protocol between Python and browser\nImport transformation: Converting ES6 imports to dynamic imports\n\nHTMX integration: Python-callable wrappers for HTMX API\nState management: Notebook state tracking and synchronization\nLogging: Unified logging across JS and Python\n\nThese modules are automatically bundled and loaded by the Bridge system.\nFor maintainers: See nbs/js/README.md for detailed module documentation.\nFor users: These work automatically - no direct interaction needed.",
    "crumbs": [
      "JavaScript & Extensions",
      "JavaScript & Extensions"
    ]
  },
  {
    "objectID": "javascript_extensions.html#javascript-modules",
    "href": "javascript_extensions.html#javascript-modules",
    "title": "JavaScript & Extensions",
    "section": "",
    "text": "Bridget includes browser-side JavaScript modules that handle:\n\nCommunication: Bridge protocol between Python and browser\nImport transformation: Converting ES6 imports to dynamic imports\n\nHTMX integration: Python-callable wrappers for HTMX API\nState management: Notebook state tracking and synchronization\nLogging: Unified logging across JS and Python\n\nThese modules are automatically bundled and loaded by the Bridge system.\nFor maintainers: See nbs/js/README.md for detailed module documentation.\nFor users: These work automatically - no direct interaction needed.",
    "crumbs": [
      "JavaScript & Extensions",
      "JavaScript & Extensions"
    ]
  },
  {
    "objectID": "javascript_extensions.html#notebook-extensions",
    "href": "javascript_extensions.html#notebook-extensions",
    "title": "JavaScript & Extensions",
    "section": "Notebook Extensions",
    "text": "Notebook Extensions\nBridget requires companion extensions to access notebook state (cells, outputs, execution order). The kernel alone doesn’t have this information.\n\nVSCode/Cursor Extension\nPackage: nbinspect-vscode\nInstallation: Install .vsix file via Extensions view\nDocumentation: packages/nbinspect-vscode/README.md\nMonitors notebook events in VSCode/Cursor and exposes state via window.$Nb API.\n\n\nJupyterLab Extension\nPackage: nbinspect-lab\nInstallation: Installed automatically with Bridget\nDocumentation: packages/nbinspect-lab/README.md\nWorks with JupyterLab 4+ and Jupyter Notebook 7+.\n\n\nExtension Overview\nFor maintainers: See packages/README.md for architecture details.\nFor users: Extensions work automatically once installed.",
    "crumbs": [
      "JavaScript & Extensions",
      "JavaScript & Extensions"
    ]
  },
  {
    "objectID": "javascript_extensions.html#architecture",
    "href": "javascript_extensions.html#architecture",
    "title": "JavaScript & Extensions",
    "section": "Architecture",
    "text": "Architecture\n┌─────────────────────┐\n│  Notebook UI        │\n│  (VSCode/Lab)       │\n└──────────┬──────────┘\n           │ monitors\n           ↓\n┌─────────────────────┐\n│  Extension          │\n│  (nbinspect-*)      │\n└──────────┬──────────┘\n           │ exposes window.$Nb\n           ↓\n┌─────────────────────┐\n│  JavaScript Modules │\n│  (bridge.js, etc)   │\n└──────────┬──────────┘\n           │ Comm protocol\n           ↓\n┌─────────────────────┐\n│  Python Kernel      │\n│  (Bridget)          │\n└─────────────────────┘\nThis architecture enables: - Real-time notebook state access from Python - Unified logging across JS and Python\n- HTMX operations from Python code - Dynamic cell output updates",
    "crumbs": [
      "JavaScript & Extensions",
      "JavaScript & Extensions"
    ]
  },
  {
    "objectID": "javascript_extensions.html#related-notebooks",
    "href": "javascript_extensions.html#related-notebooks",
    "title": "JavaScript & Extensions",
    "section": "Related Notebooks",
    "text": "Related Notebooks\n\n02_JStransform.ipynb - Import transformation implementation\n10_bridge_widget.ipynb - Bridge widget & JS bundling\n14_bridge.ipynb - Bridge communication system\n21_nb_state.ipynb - Notebook state management",
    "crumbs": [
      "JavaScript & Extensions",
      "JavaScript & Extensions"
    ]
  },
  {
    "objectID": "examples/quickstart.html",
    "href": "examples/quickstart.html",
    "title": "bridget",
    "section": "",
    "text": "from bridget.common import *\nfrom fasthtml.components import Button\n\n\n\nbridge_cfg.auto_show = True\n\n\n# app, brt, rt = get_app(show_logger=True, summary=True)\napp, brt, rt = get_app()  # Initialize Bridget environment\n\n\ndef counter(n=0):\n    @rt('/inc')\n    def increment(n:int):\n        return Button(f\"Count: {n+1}\", value=f\"{n+1}\", name='n', \n            hx_post='/inc', hx_swap='outerHTML', \n            style=f\"font-weight: bold\")\n    return increment(n-1)\n\ncounter()\n\nCount: 0",
    "crumbs": [
      "Examples",
      "quickstart.html"
    ]
  },
  {
    "objectID": "examples/htmx_examples.html",
    "href": "examples/htmx_examples.html",
    "title": "HTMX Examples",
    "section": "",
    "text": "import fastcore.all as FC\nfrom bridget.common import *\n\nfrom bridget.helpers import _n\nfrom fasthtml.xtend import Script, Style\n\n# needed for vfile:\n\n\napp, brt, rt = get_app(show_logger=True, summary=True, cfg={'auto_show':True})\n\n\n\n\nLoaded scriptsloader\nhtmx\nfasthtmljs\nobserver\nbrd_mark\n\n\n\nExample from css-scope-inline\n\nfrom fasthtml.components import Button, Span, Div, H2\n\nclass Buttons:\n    def __ft__(self):\n        return (\n            Button(garlic=True, hx_get='test', hx_select='button[vampire]', hx_swap='afterend')(_n,\n                Style(self._css_.format('hsl(264 80% 47%)', 'hsl(264 80% 60%)')),\n                'garlic ', Span('🧄', cls='icon'),\n            _n), _n,\n            Button(vampire=True, hx_get='test', hx_select='button[garlic]', hx_swap='afterend')(_n,\n                Style(self._css_.format('hsl(150 80% 47%)', 'hsl(150 80% 60%)')), \n                'vampire ', Span('🧛', cls='icon'),\n            _n), _n,\n        )\n    _css_ = '''\n    me {{ margin: 4px; padding: 10px 30px; min-width: 80px; background: {0}; border-bottom: 0.5rem solid hsl(264 80% 20%); }}\n    me {{ color: antiquewhite; font-size: 14pt; font-variant: all-small-caps; font-weight: bold; }}\n    me:hover {{ background: {1}; }}\n    me span.icon {{ font-size:16pt; }}\n'''\n\n@rt(\"/test\")\ndef get(): return Buttons()\n\n\nDiv()(\n    H2('HTMX Test'),\n    Div('Buffy: eat garlic! Angel: more mes!'),\n    Buttons(),\n)\n\nHTMX TestBuffy: eat garlic! Angel: more mes!\ngarlic 🧄\n\n\nvampire 🧛\n\n\n\n\n\n\nDelete Row\n\nfrom fasthtml.components import Table, Thead, Tbody, Tr, Th, Td\n\n\ncontacts = [\n    {'name': \"Joe Smith\",       'email': \"joe@smith.org\",       'status': \"Active\"},\n    {'name': \"Angie MacDowell\", 'email': \"angie@macdowell.org\", 'status': \"Active\"},\n    {'name': \"Fuqua Tarkenton\", 'email': \"fuqua@tarkenton.org\", 'status': \"Active\"},\n    {'name': \"Kim Yee\",         'email': \"kim@yee.org\",         'status': \"Inactive\"},\n]\n\n\ndef row(contact, i):\n    return Tr()(\n        Td(contact[\"name\"]), Td(contact[\"email\"]), Td(contact[\"status\"]),\n        Td()(Button(cls=\"btn danger\", hx_delete=f\"/contact/{i}\")('Delete'))\n    )\n\n\ntbl = Table(cls=\"table delete-row-example\")(\n    Style('''\nme tr.htmx-swapping td {\n    opacity: 0;\n    transition: opacity 1s ease-out;\n}\n'''),\n    Thead()(Tr()(Th('Name'), Th('Email'), Th('Status'), Th())),\n    # Tbody(hx_confirm=\"Are you sure?\", hx_target=\"closest tr\", hx_swap=\"outerHTML swap:1s\")(\n    Tbody(hx_target=\"closest tr\", hx_swap=\"outerHTML swap:1s\")(\n        *(row(contact, i) for i, contact in enumerate(contacts))\n    )\n)\n\n@rt('/demo')\ndef get(): return tbl\n\n@rt('/contact/{i}')\ndef delete(i:int): return ''\n\ntbl\n\nNameEmailStatusJoe Smithjoe@smith.orgActiveDeleteAngie MacDowellangie@macdowell.orgActiveDeleteFuqua Tarkentonfuqua@tarkenton.orgActiveDeleteKim Yeekim@yee.orgInactiveDelete\n\n\n\nbrt('/demo');\n\n\n   \n   \n     \n       Name\n       Email\n       Status\n       \n     \n   \n   \n     \n       Joe Smith\n       joe@smith.org\n       Active\n       \nDelete       \n     \n     \n       Angie MacDowell\n       angie@macdowell.org\n       Active\n       \nDelete       \n     \n     \n       Fuqua Tarkenton\n       fuqua@tarkenton.org\n       Active\n       \nDelete       \n     \n     \n       Kim Yee\n       kim@yee.org\n       Inactive\n       \nDelete       \n     \n   \n \n\n\n&lt;DisplayHandle display_id=6f13b7206dcded6793be1da5cc9700de&gt;\n\n\n\n\nEdit Row\n\ndebugger\n\nvar _$alert = (btn) =&gt; {\n    debugger;\n    let editing = document.querySelector('.editing')\n    if (editing) {\n        if (window.confirm('Hey! You are already editing a row! Do you want to cancel that edit and continue?')) {\n            htmx.trigger(editing, 'cancel');\n            htmx.trigger(btn, 'edit');\n        }\n    } else {\n        htmx.trigger(btn, 'edit')\n    }\n}\n\n\n# alertscr = Script('vfile:alertscr', type=\"module\")\n\nScript('vfile:alertscr')\n\n\n\n\n\nfrom fasthtml.components import Input\n\ncontacts = [\n    {'id': 0, 'name': \"Joe Smith\",       'email': \"joe@smith.org\",       'status': \"Active\"},\n    {'id': 1, 'name': \"Angie MacDowell\", 'email': \"angie@macdowell.org\", 'status': \"Active\"},\n    {'id': 2, 'name': \"Fuqua Tarkenton\", 'email': \"fuqua@tarkenton.org\", 'status': \"Active\"},\n    {'id': 3, 'name': \"Kim Yee\",         'email': \"kim@yee.org\",         'status': \"Inactive\"},\n]\n\n\ndef editrow(contact):\n    return Tr(hx_trigger='cancel', cls='editing', hx_get=f\"/eg2/contact/{contact['id']}\")(\n        Td(Input(name='name', value=contact['name'])),\n        Td(Input(name='email', value=contact['email'])),\n        Td()(Button(cls=\"btn danger\", hx_get=f\"/eg2/contact/{contact['id']}\")('Cancel'),\n            Button(cls=\"btn danger\", hx_put=f\"/eg2/contact/{contact['id']}\", hx_include='closest tr')('Save'))\n    )\n\ndef row(contact):\n    return Tr()(\n        Td(contact[\"name\"]), Td(contact[\"email\"]),\n        Td()(Button('Edit', cls=\"btn danger\", \n            hx_get=f\"/eg2/contact/{contact['id']}/edit\", hx_trigger=\"edit\", \n            onClick=\"_$alert(this)\")\n        )\n    )\n\ntbl = Div()(\n    Table(cls=\"table edit-row-example\")(\n        Thead()(Tr()(Th('Name'), Th('Email'), Th())),\n        # Tbody(hx_confirm=\"Are you sure?\", hx_target=\"closest tr\", hx_swap=\"outerHTML swap:1s\")(\n        Tbody(hx_target=\"closest tr\", hx_swap=\"outerHTML\")(\n            *(row(contact) for contact in contacts)\n        )\n    ),\n    # alertscr\n)\n\n\n@rt('/eg2/contact/{i}{edit:path}')\ndef get(i:int, edit:str=''):\n    # import debugpy; debugpy.debug_this_thread() # vscode needs this to honor breakpoints\n    contact = contacts[i]\n    if edit: return editrow(contact)\n    else: return row(contact)\n\n\n@rt('/eg2/contact/{i}')\ndef put(i:int, name:str, email:str):\n    # import debugpy; debugpy.debug_this_thread() # vscode needs this to honor breakpoints\n    contact = contacts[i]\n    contact['name'] = name\n    contact['email'] = email\n    return row(contact)\n\n\ntbl\n\n\n\n\n\n\n\n\n\n\nName\nEmail\n\n\n\n\n\nJoe Smith\njoe@smith.org\n\nEdit\n\n\n\nAngie MacDowell\nangie@macdowell.org\n\nEdit\n\n\n\nFuqua Tarkenton\nfuqua@tarkenton.org\n\nEdit\n\n\n\nKim Yee\nkim@yee.org\n\nEdit",
    "crumbs": [
      "Examples",
      "HTMX Examples"
    ]
  },
  {
    "objectID": "nb.html",
    "href": "nb.html",
    "title": "Notebook objects",
    "section": "",
    "text": "bridge_cfg.auto_show = True",
    "crumbs": [
      "Notebook State",
      "Notebook objects"
    ]
  },
  {
    "objectID": "nb.html#did",
    "href": "nb.html#did",
    "title": "Notebook objects",
    "section": "did",
    "text": "did\n\nnested_idx(cell, 'outputs', 0, 'metadata', 'transient', 'display_id')\n\n'2ffe60c5c571592fc61fe81faab39e34'\n\n\n\ntest_eq(nested_idx(NBCell(state['cells'][0]), 'outputs', 0, 'metadata', 'transient', 'display_id'), None)\n\n\nnested_idx(getattr(NBCell(state['cells'][3]), 'outputs'), 0, 'metadata', 'transient', 'display_id')\n\n'9d0548d3b88c66b7def8b47bbe5a12dd'\n\n\n\ncell = NBCell(state['cells'][8])\ndisplay(cell.outputs[0])\nnested_idx(cell, 'outputs', 0, 'metadata', 'transient', 'display_id'), val_atpath(cell, 'outputs', 0, 'metadata', 'transient', 'display_id', default=None)\n\n{ 'data': { 'text/html': '&lt;h3&gt;cell 8&lt;/h3&gt;\\n',\n            'text/plain': '&lt;IPython.core.display.HTML object&gt;'},\n  'metadata': {'transient': {}},\n  'output_type': 'display_data'}\n\n\n({}, None)\n\n\ncan’t use nexsted_idx.\n\nsource\n\ndid\n\n did (o:__main__.NBOutput)\n\n\n# type: ignore\n\ncell = NBCell(state['cells'][4])\ndisplay(cell.outputs[0])\n\ntest_eq(did(cell.outputs[0]), cell.outputs[0]['metadata']['transient']['display_id'])\ntest_eq(cell.outputs[0].did, cell.outputs[0]['metadata']['transient']['display_id'])\n\n{ 'data': { 'text/html': 'cell 4',\n            'text/plain': '&lt;IPython.core.display.HTML object&gt;'},\n  'metadata': { 'bridge': {'cell': 4},\n                'transient': { 'display_id': '2ffe60c5c571592fc61fe81faab39e34'}},\n  'output_type': 'display_data'}\n\n\n\ncell = NBCell(state['cells'][2])\ndisplay(cell.outputs[0])\ntest_eq(did(cell.outputs[0]), None)\n\n{'name': 'stdout', 'output_type': 'stream', 'text': '1\\n'}\n\n\n\ncell = NBCell(state['cells'][8])\ndisplay(cell.outputs[0])\n\n{ 'data': { 'text/html': '&lt;h3&gt;cell 8&lt;/h3&gt;\\n',\n            'text/plain': '&lt;IPython.core.display.HTML object&gt;'},\n  'metadata': {'transient': {}},\n  'output_type': 'display_data'}\n\n\n\ncell = NBCell(state['cells'][8])\ndisplay(cell.outputs[0])\ntest_eq(did(cell.outputs[0]), None)\n\n{ 'data': { 'text/html': '&lt;h3&gt;cell 8&lt;/h3&gt;\\n',\n            'text/plain': '&lt;IPython.core.display.HTML object&gt;'},\n  'metadata': {'transient': {}},\n  'output_type': 'display_data'}",
    "crumbs": [
      "Notebook State",
      "Notebook objects"
    ]
  },
  {
    "objectID": "nb.html#dids",
    "href": "nb.html#dids",
    "title": "Notebook objects",
    "section": "dids",
    "text": "dids\n\nsource\n\ndids\n\ncell = NBCell(state['cells'][5])\ndisplay(cell.outputs)\ntest_eq(cell.dids, [cell.outputs[0].did])\n\n[{'output_type': 'display_data',\n  'data': {'application/javascript': 'console.log(\"cell 5\")',\n   'text/plain': '&lt;IPython.core.display.Javascript object&gt;'},\n  'metadata': {'transient': {'display_id': 'b970be042e0ebd1e5af19aadcfbf213e'},\n   'bridge': {'cell': 5}}}]\n\n\n\ntest_eq(NBCell(state['cells'][1]).dids, [])\n\n\ndisplay(state['cells'][2])\ntest_eq(NBCell(state['cells'][1]).dids, [])\n\n{'idx': 2,\n 'cell_type': 'code',\n 'source': '# cell 2\\nprint(1)',\n 'id': 'W2sZmlsZQ==',\n 'metadata': {'brd': {'id': '92f3e304-fd32-4de2-badf-11577f9e7a4a'}},\n 'outputs': [{'output_type': 'stream', 'name': 'stdout', 'text': '1\\n'}],\n 'execution_count': 2}\n\n\n\ndisplay(cell := NBCell(state['cells'][7]))\ncell.dids\n\n\nNBCell@7\n  \n    \nidx: 7    \n    \ncell_type: code    \n    \nsource: # cell 7\ndisplaydh(HTML('cell 7.1'), metadata={'bridge': {'cell': 7.1}})\ndisplaydh(HTML('cell 7.2'), metadata={'bridge': {'cell': 7.2}});    \n    \nid: X10sZmlsZQ==    \n    \nmetadata: {'brd': {'id': '7512abfe-f7d2-4047-a6b1-56aefbf9457e'}}    \noutputs\n      \n0\n          \n            \noutput_type: display_data            \ndata\n              \n                \ntext/html: cell 7.1                \n                \ntext/plain: &lt;IPython.core.display.HTML object&gt;                \n              \n            \nmetadata: {'transient': {'display_id': '331d2582eb05fdc75afaa4c616fc8b6c'}, 'bridge': {'cell': 7.1}}            \n          \n1\n          \n            \noutput_type: display_data            \ndata\n              \n                \ntext/html: cell 7.2                \n                \ntext/plain: &lt;IPython.core.display.HTML object&gt;                \n              \n            \nmetadata: {'transient': {'display_id': 'bbb4397c26ce0c3fb2f1acddc6ce91b1'}, 'bridge': {'cell': 7.2}}            \n          \n      \n    \nexecution_count: 7    \n  \n\n\n\n(#2) ['331d2582eb05fdc75afaa4c616fc8b6c','bbb4397c26ce0c3fb2f1acddc6ce91b1']\n\n\n\ncells = L(state['cells']).map(NBCell)\n\n\ncells.map(lambda c: NBCell(c).dids)\n\n(#42) [[],[],[],['9d0548d3b88c66b7def8b47bbe5a12dd'],['2ffe60c5c571592fc61fe81faab39e34'],['b970be042e0ebd1e5af19aadcfbf213e'],[],['331d2582eb05fdc75afaa4c616fc8b6c', 'bbb4397c26ce0c3fb2f1acddc6ce91b1'],[],[],[],[],[],[],[],[],['a6b5cc5f13bf64ce8dd73d0b79b0bef2'],['b0c4b491988399c7d88a82779528132d'],[],['e81dd25b299e4881aff6aec417c5bed9']...]\n\n\n\ntest_eq(cells[2]['outputs'][0]['name'], 'stdout')  # type: ignore\n\n\ntest_eq(len(codes := cells.argwhere(lambda c: c['cell_type'] == 'code')), 40)\ndisplay(codes)\ncells[codes[2]]\n\n(#40) [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20...]\n\n\n\nNBCell@3\n  \n    \nidx: 3    \n    \ncell_type: code    \n    \nsource: # cell 3\ndisplaydh('cell 3', metadata={'bridge': {'cell': 3}});    \n    \nid: W3sZmlsZQ==    \n    \nmetadata: {'brd': {'id': 'f2c19c18-a3f7-4acb-88e4-c7239178c401'}}    \noutputs\n      \n0\n          \n            \noutput_type: display_data            \ndata\n              \n                \ntext/plain: 'cell 3'                \n              \n            \nmetadata: {'transient': {'display_id': '9d0548d3b88c66b7def8b47bbe5a12dd'}, 'bridge': {'cell': 3}}            \n          \n      \n    \nexecution_count: 3",
    "crumbs": [
      "Notebook State",
      "Notebook objects"
    ]
  },
  {
    "objectID": "nb.html#by_type",
    "href": "nb.html#by_type",
    "title": "Notebook objects",
    "section": "by_type",
    "text": "by_type\n\nsource\n\nby_type\n\n by_type (cells:Union[Sequence[__main__.NBCell],fastcore.foundation.L],\n          cell_type:Literal['code','markdown'])\n\nReturn ‘L’ of indices of cells of type cell_type\n\nby_type(cells, 'code')\n\n(#40) [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20...]\n\n\n\nby_type(cells, 'code')\n\n(#40) [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20...]",
    "crumbs": [
      "Notebook State",
      "Notebook objects"
    ]
  },
  {
    "objectID": "nb.html#idx2cell",
    "href": "nb.html#idx2cell",
    "title": "Notebook objects",
    "section": "idx2cell",
    "text": "idx2cell\n\nidxs = by_type(cells, 'code')\nidxs\n\n(#40) [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20...]\n\n\n\ncells[idxs][:5]\n\n\nsource\n\nidx2cell\n\n idx2cell (cells:Union[Sequence[__main__.NBCell],fastcore.foundation.L],\n           cell_type:Optional[Literal['code','markdown']]=None)\n\nReturn mapping of indices to cells of type cell_type\n\ntest_eq(all(isinstance(c, NBCellCode) for c in idx2cell(cells, 'code').values()), True)\nidx2cell(cells, 'code').keys()\n\ndict_keys([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41])\n\n\n\nidx2cell(cells, 'code')[1]\n\n\nNBCell@1\n  \n    \nidx: 1    \n    \ncell_type: code    \n    \nsource: # cell 1\nimport time\nfrom itertools import count\n\nimport ipywidgets as W\nimport matplotlib.pyplot as plt\nfrom bridget.helpers import display…    \n    \nid: W1sZmlsZQ==    \n    \nmetadata: {'brd': {'id': '717322f8-95fa-425c-839d-8b9e7d4ef921'}}    \noutputs\n      \n    \nexecution_count: 1",
    "crumbs": [
      "Notebook State",
      "Notebook objects"
    ]
  },
  {
    "objectID": "nb.html#withoutputs",
    "href": "nb.html#withoutputs",
    "title": "Notebook objects",
    "section": "withOutputs",
    "text": "withOutputs\n\noutputs_idx = cells.argwhere(lambda c: 'outputs' in c)\ndisplay(outputs_idx)\n\nprint(outputs_idx.zipwith(cells[outputs_idx])[0])\n\ndict(outputs_idx.zipwith(cells[outputs_idx]))[3]\n\n(#40) [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20...]\n\n\n(1, {'idx': 1, 'cell_type': 'code', 'source': '# cell 1\\nimport time\\nfrom itertools import count\\n\\nimport ipywidgets as W\\nimport matplotlib.pyplot as plt\\nfrom bridget.helpers import displaydh\\nfrom IPython.display import HTML, Image, Javascript, JSON, DisplayHandle, clear_output\\ncounter = count()', 'id': 'W1sZmlsZQ==', 'metadata': {'brd': {'id': '717322f8-95fa-425c-839d-8b9e7d4ef921'}}, 'outputs': [], 'execution_count': 1})\n\n\n\nNBCell@3\n  \n    \nidx: 3    \n    \ncell_type: code    \n    \nsource: # cell 3\ndisplaydh('cell 3', metadata={'bridge': {'cell': 3}});    \n    \nid: W3sZmlsZQ==    \n    \nmetadata: {'brd': {'id': 'f2c19c18-a3f7-4acb-88e4-c7239178c401'}}    \noutputs\n      \n0\n          \n            \noutput_type: display_data            \ndata\n              \n                \ntext/plain: 'cell 3'                \n              \n            \nmetadata: {'transient': {'display_id': '9d0548d3b88c66b7def8b47bbe5a12dd'}, 'bridge': {'cell': 3}}            \n          \n      \n    \nexecution_count: 3    \n  \n\n\n\n\nsource\n\nwithOutputs\n\n withOutputs\n              (cells:Union[Sequence[__main__.NBCell],fastcore.foundation.L\n              ])\n\nReturn indices of cells with outputs\n\nwithOutputs(cells[:5])\n\n(#4) [1,2,3,4]",
    "crumbs": [
      "Notebook State",
      "Notebook objects"
    ]
  },
  {
    "objectID": "nb.html#idx2outputs",
    "href": "nb.html#idx2outputs",
    "title": "Notebook objects",
    "section": "idx2outputs",
    "text": "idx2outputs\n\nsource\n\nidx2outputs\n\n idx2outputs\n              (cells:Union[Sequence[__main__.NBCell],fastcore.foundation.L\n              ])\n\nReturn dict of indices to cells with outputs\n\nidx2outputs(cells)[2]\n\n\nNBCell@2\n  \n    \nidx: 2    \n    \ncell_type: code    \n    \nsource: # cell 2\nprint(1)    \n    \nid: W2sZmlsZQ==    \n    \nmetadata: {'brd': {'id': '92f3e304-fd32-4de2-badf-11577f9e7a4a'}}    \noutputs\n      \n0\n          \n            \noutput_type: stream            \n            \nname: stdout            \n            \ntext: 1\n            \n          \n      \n    \nexecution_count: 2    \n  \n\n\n\n\nidx2outputs(cells)[7]\n\n\nNBCell@7\n  \n    \nidx: 7    \n    \ncell_type: code    \n    \nsource: # cell 7\ndisplaydh(HTML('cell 7.1'), metadata={'bridge': {'cell': 7.1}})\ndisplaydh(HTML('cell 7.2'), metadata={'bridge': {'cell': 7.2}});    \n    \nid: X10sZmlsZQ==    \n    \nmetadata: {'brd': {'id': '7512abfe-f7d2-4047-a6b1-56aefbf9457e'}}    \noutputs\n      \n0\n          \n            \noutput_type: display_data            \ndata\n              \n                \ntext/html: cell 7.1                \n                \ntext/plain: &lt;IPython.core.display.HTML object&gt;                \n              \n            \nmetadata: {'transient': {'display_id': '331d2582eb05fdc75afaa4c616fc8b6c'}, 'bridge': {'cell': 7.1}}            \n          \n1\n          \n            \noutput_type: display_data            \ndata\n              \n                \ntext/html: cell 7.2                \n                \ntext/plain: &lt;IPython.core.display.HTML object&gt;                \n              \n            \nmetadata: {'transient': {'display_id': 'bbb4397c26ce0c3fb2f1acddc6ce91b1'}, 'bridge': {'cell': 7.2}}            \n          \n      \n    \nexecution_count: 7    \n  \n\n\n\n\nidx2outputs(cells)[12]\n\n\nNBCell@12\n  \n    \nidx: 12    \n    \ncell_type: code    \n    \nsource: # cell 12\nW.IntSlider(12, description='cell')    \n    \nid: X15sZmlsZQ==    \n    \nmetadata: {'brd': {'id': 'e7e6d557-3aa7-41a7-9e77-805295112aec'}}    \noutputs\n      \n0\n          \n            \noutput_type: execute_result            \ndata\n              \napplication/vnd.jupyter.widget-view+json\n                  \n                    \nversion_major: 2                    \n                    \nversion_minor: 0                    \n                    \nmodel_id: 6191b18d61a44fbd89eb132d22a28eab                    \n                  \n                \ntext/plain: IntSlider(value=12, description='cell')                \n              \n            \nexecution_count: 12            \n            \nmetadata: {}            \n          \n      \n    \nexecution_count: 12",
    "crumbs": [
      "Notebook State",
      "Notebook objects"
    ]
  },
  {
    "objectID": "nb.html#idx2dids",
    "href": "nb.html#idx2dids",
    "title": "Notebook objects",
    "section": "idx2dids",
    "text": "idx2dids\n\noutputs_idx = withOutputs(cells := L(cells))\noutputs_idx\n\n(#40) [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20...]\n\n\n\noutputs_idx.zipwith(cells[outputs_idx]).filter(lambda c: c[1].dids)[:2]\n\n(#2) [(3, {'idx': 3, 'cell_type': 'code', 'source': \"# cell 3\\ndisplaydh('cell 3', metadata={'bridge': {'cell': 3}});\", 'id': 'W3sZmlsZQ==', 'metadata': {'brd': {'id': 'f2c19c18-a3f7-4acb-88e4-c7239178c401'}}, 'outputs': [{'output_type': 'display_data', 'data': {'text/plain': \"'cell 3'\"}, 'metadata': {'transient': {'display_id': '9d0548d3b88c66b7def8b47bbe5a12dd'}, 'bridge': {'cell': 3}}}], 'execution_count': 3}),(4, {'idx': 4, 'cell_type': 'code', 'source': \"# cell 4\\nimport time\\ntime.sleep(2)\\ndisplaydh(HTML('cell 4'), metadata={'bridge': {'cell': 4}});\", 'id': 'W4sZmlsZQ==', 'metadata': {'brd': {'id': '798f7f83-9b31-4e21-a36b-5520c6f72a2d'}}, 'outputs': [{'output_type': 'display_data', 'data': {'text/html': 'cell 4', 'text/plain': '&lt;IPython.core.display.HTML object&gt;'}, 'metadata': {'transient': {'display_id': '2ffe60c5c571592fc61fe81faab39e34'}, 'bridge': {'cell': 4}}}], 'execution_count': 4})]\n\n\n\nsource\n\nidx2dids\n\n idx2dids (cells:Union[Sequence[__main__.NBCell],fastcore.foundation.L])\n\nReturn dict of indices to cells with transient outputs\n\nidx2dids(cells).keys(), idx2dids(cells)[7]\n\n(dict_keys([3, 4, 5, 7, 16, 17, 19, 24, 26, 35]),\n (#2) ['331d2582eb05fdc75afaa4c616fc8b6c','bbb4397c26ce0c3fb2f1acddc6ce91b1'])",
    "crumbs": [
      "Notebook State",
      "Notebook objects"
    ]
  },
  {
    "objectID": "nb.html#directives",
    "href": "nb.html#directives",
    "title": "Notebook objects",
    "section": "directives",
    "text": "directives\n\nNBCells register nbdev directives/quarto Cell options/python cell magics in directives_.\n\n\ns = '''\n\n#| hide\n\nprint(1)\n'''\ncell1 = NBCell(AD(cell_type='code', source=s))\ntest_is(cell1.has_directive('hide'), True)\ncell1.directives_\n\n{'python': [], 'hide': []}\n\n\n\ns = '''\n#| label: fig-polar\n#| echo: false\n\n# comment\nprint(1)\n'''\ncell2 = NBCell(dict(cell_type='code', source=s))\ncell2.directives_\n\n{'label:': ['fig-polar'], 'echo:': ['false']}\n\n\n\ns = '''\n\n    #| code-fold\n\nprint(1)\n'''\ncell3 = NBCell({'cell_type':'code', 'source':s})\ncell3.directives_\n\n{'code-fold': []}\n\n\n\nsource\n\nby_directive\n\n by_directive\n               (cells:Union[Sequence[__main__.NBCell],fastcore.foundation.\n               L], directive:str, *args)\n\n\ntest_eq(by_directive([cell1, cell2, cell3], 'hide'), [0])",
    "crumbs": [
      "Notebook State",
      "Notebook objects"
    ]
  },
  {
    "objectID": "nb.html#find-1",
    "href": "nb.html#find-1",
    "title": "Notebook objects",
    "section": "find",
    "text": "find\n\nL(vals_at(nb, '*.outputs.*.data.application/json')).argwhere(lambda x: x is not empty)\n\n(#1) [19]\n\n\n\nL(vals_at(nb, '*.outputs.*.name')).argwhere(lambda x: x is not empty)\n\n(#2) [2,6]\n\n\n\ntest_eq(_there('outputs.*.data', 'stdout', op.contains, nb.cells[7]), False)\n\n\nfor idx in L(vals_at(nb, '*.outputs.*.name')).argwhere(lambda x: x is not empty):\n    test_eq(_there('outputs.0.name', 'stdout', op.contains, nb[idx]), True)\n\n\nfor idx in L(vals_at(nb, '*.metadata.brd.renderer')).argwhere(lambda x: x is not empty):\n    test_eq(_there('metadata.brd.renderer', True, op.is_, nb[idx]), True)\n\n\ntest_eq(any(_there('source', '# find_me', op.contains, c) for c in nb), True)\n\n\nsource\n\nshow_doc\n\n show_doc (sym, renderer=None, name:str|None=None, title_level:int=3)\n\nShow signature and docstring for sym\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsym\n\n\nSymbol to document\n\n\nrenderer\nNoneType\nNone\nOptional renderer (defaults to markdown)\n\n\nname\nstr | None\nNone\nOptionally override displayed name of sym\n\n\ntitle_level\nint\n3\nHeading level to use for symbol name\n\n\n\n\nnbp = nb.process(slc=slice(31, None))\n# nbp.find('# find_me').attrgot('source').map(shorten, mode='r')\nvals_at(nbp.find('# find_me'), '*.source')\n\n('# cell 41\\n# find_me',)\n\n\n\nnb.find(True, 'metadata.brd.renderer', op.is_).attrgot('metadata')\n\n(#2) [{'brd': {'id': 'e4bbb456-27fa-47d1-b95b-637b61e0e8f5', 'renderer': True}},{'brd': {'id': 'e7eb193d-f9fe-41b6-b817-1328963ff734', 'renderer': True}}]\n\n\n\nnb.find('stdout', 'outputs.0.name').attrgot('source')\n\n(#2) ['# cell 2\\nprint(1)','# cell 6\\nprint(6.1)\\nprint(6.2)']\n\n\n\nnb.find('stdout', 'outputs.*.name').attrgot('source')\n\n(#2) ['# cell 2\\nprint(1)','# cell 6\\nprint(6.1)\\nprint(6.2)']",
    "crumbs": [
      "Notebook State",
      "Notebook objects"
    ]
  },
  {
    "objectID": "nb.html#found",
    "href": "nb.html#found",
    "title": "Notebook objects",
    "section": "found",
    "text": "found\n\n@FC.patch\ndef found(self: NB, what:str|Callable[[NBCell], bool], where:WhereT='source', cbs:Callback|Sequence[Callback]=()) -&gt; NB:\n    return self.process(cbs or FindCB(what, where))\n\nnb.found('# find_me').cells  # type: ignore\n\n(#1) [{'idx': 41, 'cell_type': 'code', 'source': '# cell 41\\n# find_me', 'id': 'X56sZmlsZQ==', 'metadata': {'brd': {'id': '340489bf-419a-4da3-9b06-eb1b5cd6daba'}}, 'outputs': [], 'execution_count': 7}]\n\n\n\nsource\n\nshow_doc\n\n show_doc (sym, renderer=None, name:str|None=None, title_level:int=3)\n\nShow signature and docstring for sym\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsym\n\n\nSymbol to document\n\n\nrenderer\nNoneType\nNone\nOptional renderer (defaults to markdown)\n\n\nname\nstr | None\nNone\nOptionally override displayed name of sym\n\n\ntitle_level\nint\n3\nHeading level to use for symbol name\n\n\n\n\nnb.found('# find_me').cells.attrgot('source')\n\n(#1) ['# cell 41\\n# find_me']\n\n\n\nnb.found('#| hide').cells\n\n(#1) [{'idx': 13, 'cell_type': 'code', 'source': \"#| hide\\n# cell 13\\nw = W.Output()\\ndisplay(w)\\nwith w:\\n    print('cell 13.1')\\n    display('cell 13.2')\\n    display(HTML('cell 13.3'))\", 'id': 'X16sZmlsZQ==', 'metadata': {'brd': {'id': '8af15850-3d11-4498-a037-ce8b1ac2a161'}}, 'outputs': [{'output_type': 'display_data', 'data': {'application/vnd.jupyter.widget-view+json': {'version_major': 2, 'version_minor': 0, 'model_id': 'a9408d195fb84649b38948893390ef10'}, 'text/plain': 'Output()'}, 'metadata': {}}], 'execution_count': 13}]\n\n\n\nclass StripDirectives(Callback):\n    @property\n    def nb(self): return self._nb\n    def before_iter(self, istat): self._nb = NB.from_NB(istat.context, [])\n    def on_iter(self, _, cell):\n        self._nb.cells.append(c := cell.copy())\n        extract_directives(c)\n\ndisplay([*shortens(nb.found('#| hide').source, 'r')])\ndisplay([*shortens(nb.found('#| hide', cbs=StripDirectives()).source, 'r')])\n\n['#| hide\\n# cell 13\\nw = W.Output()\\ndisplay…']\n\n\n['# cell 13\\nw = W.Output()\\ndisplay(w)\\nwith…']\n\n\n\ndef strip_nbdev_dirs_(nb:NB):\n    f = FC.compose(copycell, TZ.curried.do(extract_directives))\n    return NB.from_NB(nb, nb.cells.map(f))\n\nlist(shortens(nb.found('#| hide').pipe((strip_nbdev_dirs_,)).source, 'r'))\n\n['# cell 13\\nw = W.Output()\\ndisplay(w)\\nwith…']",
    "crumbs": [
      "Notebook State",
      "Notebook objects"
    ]
  },
  {
    "objectID": "js_modules_README.html",
    "href": "js_modules_README.html",
    "title": "Bridget JavaScript Modules",
    "section": "",
    "text": "Browser-side JavaScript components that enable Bridget’s functionality. These modules are bundled and loaded automatically by the Bridge system.\n\n\n\n\nDynamic ES module import transformer. Converts static import statements to dynamic await import() for runtime module loading. See 02_JStransform.ipynb for implementation details.\n\n\n\nCore Bridge communication layer. Handles message passing between browser and Python kernel via Comm protocol.\n\n\n\nMain Bridget client. Coordinates Bridge, HTMX, and widget functionality.\n\n\n\nDOM mutation observer for tracking dynamic content changes.\n\n\n\nPython-callable wrapper for HTMX JavaScript API. Enables Python code to trigger HTMX swaps and operations.\n\n\n\nCustom HTML element (&lt;brd-mark&gt;) for marking and identifying cell outputs.\n\n\n\n\nbcanvas.js - Browser canvas for log display\nfcanvas.js - HTML-integrated canvas\nnbstate.js - Notebook state management\n\n\n\n\n\nThese files are the source in nbs/js/ and bundled output in bridget/js/.\nEdit: nbs/js/*.js\nBundle: Run nbdev_prepare (handled automatically)\nLoad: Bridget loads these automatically via BridgeWidget\n\n\n\nPython (Kernel)\n    ↕ Comm protocol\nBridge (bridge.js)\n    ↕ Message passing\nHTMX / Bridget (bridget.js)\n    ↕ DOM operations\nNotebook Output Cells\nSee notebooks for detailed documentation: - 10_bridge_widget.ipynb - Bridge widget & bundling - 14_bridge.ipynb - Bridge system - 16_bridge_plugins.ipynb - Plugin examples ```"
  },
  {
    "objectID": "js_modules_README.html#core-modules",
    "href": "js_modules_README.html#core-modules",
    "title": "Bridget JavaScript Modules",
    "section": "",
    "text": "Dynamic ES module import transformer. Converts static import statements to dynamic await import() for runtime module loading. See 02_JStransform.ipynb for implementation details.\n\n\n\nCore Bridge communication layer. Handles message passing between browser and Python kernel via Comm protocol.\n\n\n\nMain Bridget client. Coordinates Bridge, HTMX, and widget functionality.\n\n\n\nDOM mutation observer for tracking dynamic content changes.\n\n\n\nPython-callable wrapper for HTMX JavaScript API. Enables Python code to trigger HTMX swaps and operations.\n\n\n\nCustom HTML element (&lt;brd-mark&gt;) for marking and identifying cell outputs.\n\n\n\n\nbcanvas.js - Browser canvas for log display\nfcanvas.js - HTML-integrated canvas\nnbstate.js - Notebook state management"
  },
  {
    "objectID": "js_modules_README.html#development",
    "href": "js_modules_README.html#development",
    "title": "Bridget JavaScript Modules",
    "section": "",
    "text": "These files are the source in nbs/js/ and bundled output in bridget/js/.\nEdit: nbs/js/*.js\nBundle: Run nbdev_prepare (handled automatically)\nLoad: Bridget loads these automatically via BridgeWidget"
  },
  {
    "objectID": "js_modules_README.html#architecture",
    "href": "js_modules_README.html#architecture",
    "title": "Bridget JavaScript Modules",
    "section": "",
    "text": "Python (Kernel)\n    ↕ Comm protocol\nBridge (bridge.js)\n    ↕ Message passing\nHTMX / Bridget (bridget.js)\n    ↕ DOM operations\nNotebook Output Cells\nSee notebooks for detailed documentation: - 10_bridge_widget.ipynb - Bridge widget & bundling - 14_bridge.ipynb - Bridge system - 16_bridge_plugins.ipynb - Plugin examples ```"
  },
  {
    "objectID": "lab_extension_README.html",
    "href": "lab_extension_README.html",
    "title": "nbinspect-lab: JupyterLab State Inspector for Bridget",
    "section": "",
    "text": "nbinspect-lab is the companion JupyterLab and Jupyter Notebook extension for the Bridget project. It runs in the browser, monitoring the notebook’s structure, cell content, and outputs in real-time. This live state information is then sent to the Bridget Python kernel, enabling its powerful introspection and dynamic capabilities.\n\n\nThe extension actively monitors the notebook and provides a front-end API for its findings. Key features include tracking changes to the notebook’s cell structure and content, monitoring cell execution status, and providing visual feedback through a custom MIME renderer. All state changes are broadcast via a global window.$Nb API that front-end components can subscribe to.\n\n\n\n\nJupyterLab &gt;= 4.0.0 or Notebook &gt;= 7.0\nThe bridget Python package (for standard usage).\n\n\n\n\nThis extension is designed to be installed as part of the main bridget repository. Please follow the installation instructions in the main project’s README file.\nAlternatively, you can install this extension standalone from its directory:\n# From packages/nbinspect-lab:\npip install -e .\nNote on Standalone Usage: While nbinspect-lab is part of Bridget, it has no direct dependency on the Python package and can be used in isolation. If you choose this path, you are responsible for creating your own front-end widget to subscribe to the state change events provided by the extension’s window.$Nb API.\n\n\n\nTo remove the extension:\npip uninstall nbinspect_lab\nYou can verify removal with:\npip list | grep nbinspect\njupyter labextension list\n\n\n\nnbinspect-lab is a package within the bridget pnpm monorepo. To contribute, you will need NodeJS and the pnpm package manager.\n\n\n\nInstall Dependencies: From the repository root:\npnpm install\nInstall Extension in Editable Mode: From this directory:\npip install -e .\nEnable Live Reloading (Optional): For automatic rebuilds during development:\njupyter labextension develop . --overwrite\n\n\n\n\n# In one terminal (from packages/nbinspect-lab):\npnpm watch\n\n# In another terminal:\njupyter lab\nAfter making changes, refresh your browser to see updates.\n\n\n\nInstructions for creating a release are in RELEASE.md.\n\n\n\n\nThe extension uses a session-aware architecture to handle JupyterLab’s shared window context:\n\n\n\nSessionManager: Global state manager mapping file paths to session state\nNotebookMonitor: Document-focused monitor that queries SessionManager\nSession Lifecycle: State persists across panel close/reopen, cleans up on kernel restart\n\n\n\n\n\nNotebook opens → Monitor created → Queries SessionManager for existing state\nNotebook closes → Monitor disposed → State remains in SessionManager\n\nNotebook reopens → New monitor → Retrieves existing state from SessionManager\nKernel restarts → SessionManager cleans up session state"
  },
  {
    "objectID": "lab_extension_README.html#features",
    "href": "lab_extension_README.html#features",
    "title": "nbinspect-lab: JupyterLab State Inspector for Bridget",
    "section": "",
    "text": "The extension actively monitors the notebook and provides a front-end API for its findings. Key features include tracking changes to the notebook’s cell structure and content, monitoring cell execution status, and providing visual feedback through a custom MIME renderer. All state changes are broadcast via a global window.$Nb API that front-end components can subscribe to."
  },
  {
    "objectID": "lab_extension_README.html#requirements",
    "href": "lab_extension_README.html#requirements",
    "title": "nbinspect-lab: JupyterLab State Inspector for Bridget",
    "section": "",
    "text": "JupyterLab &gt;= 4.0.0 or Notebook &gt;= 7.0\nThe bridget Python package (for standard usage)."
  },
  {
    "objectID": "lab_extension_README.html#installation",
    "href": "lab_extension_README.html#installation",
    "title": "nbinspect-lab: JupyterLab State Inspector for Bridget",
    "section": "",
    "text": "This extension is designed to be installed as part of the main bridget repository. Please follow the installation instructions in the main project’s README file.\nAlternatively, you can install this extension standalone from its directory:\n# From packages/nbinspect-lab:\npip install -e .\nNote on Standalone Usage: While nbinspect-lab is part of Bridget, it has no direct dependency on the Python package and can be used in isolation. If you choose this path, you are responsible for creating your own front-end widget to subscribe to the state change events provided by the extension’s window.$Nb API."
  },
  {
    "objectID": "lab_extension_README.html#uninstalling",
    "href": "lab_extension_README.html#uninstalling",
    "title": "nbinspect-lab: JupyterLab State Inspector for Bridget",
    "section": "",
    "text": "To remove the extension:\npip uninstall nbinspect_lab\nYou can verify removal with:\npip list | grep nbinspect\njupyter labextension list"
  },
  {
    "objectID": "lab_extension_README.html#development",
    "href": "lab_extension_README.html#development",
    "title": "nbinspect-lab: JupyterLab State Inspector for Bridget",
    "section": "",
    "text": "nbinspect-lab is a package within the bridget pnpm monorepo. To contribute, you will need NodeJS and the pnpm package manager.\n\n\n\nInstall Dependencies: From the repository root:\npnpm install\nInstall Extension in Editable Mode: From this directory:\npip install -e .\nEnable Live Reloading (Optional): For automatic rebuilds during development:\njupyter labextension develop . --overwrite\n\n\n\n\n# In one terminal (from packages/nbinspect-lab):\npnpm watch\n\n# In another terminal:\njupyter lab\nAfter making changes, refresh your browser to see updates.\n\n\n\nInstructions for creating a release are in RELEASE.md."
  },
  {
    "objectID": "lab_extension_README.html#architecture-session-management",
    "href": "lab_extension_README.html#architecture-session-management",
    "title": "nbinspect-lab: JupyterLab State Inspector for Bridget",
    "section": "",
    "text": "The extension uses a session-aware architecture to handle JupyterLab’s shared window context:\n\n\n\nSessionManager: Global state manager mapping file paths to session state\nNotebookMonitor: Document-focused monitor that queries SessionManager\nSession Lifecycle: State persists across panel close/reopen, cleans up on kernel restart\n\n\n\n\n\nNotebook opens → Monitor created → Queries SessionManager for existing state\nNotebook closes → Monitor disposed → State remains in SessionManager\n\nNotebook reopens → New monitor → Retrieves existing state from SessionManager\nKernel restarts → SessionManager cleans up session state"
  },
  {
    "objectID": "bridge_widget.html",
    "href": "bridge_widget.html",
    "title": "Bridge widget helpers",
    "section": "",
    "text": "This module provides low-level infrastructure for Bridget: - JS Bundling: Concatenate and transform JavaScript sources - Blocking Operations: Block Python execution while allowing UI interaction - AnyWidget Base: BridgeWidget class for bidirectional messaging",
    "crumbs": [
      "Bridge",
      "Bridge widget helpers"
    ]
  },
  {
    "objectID": "bridge_widget.html#vfile-components",
    "href": "bridge_widget.html#vfile-components",
    "title": "Bridge widget helpers",
    "section": "vfile: Components",
    "text": "vfile: Components\n\nFastHTML xtend Script and Style with vfile: support.\n\n\nsource\n\nStyleV\n\n StyleV (*c, id=None, cls=None, title=None, style=None, attrmap=None,\n         valmap=None, ft_cls=None, **kwargs)\n\nA Style w/ code or vfile: contents that doesn’t escape its code\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc\nVAR_POSITIONAL\n\n\n\n\nid\nNoneType\nNone\n\n\n\ncls\nNoneType\nNone\n\n\n\ntitle\nNoneType\nNone\n\n\n\nstyle\nNoneType\nNone\n\n\n\nattrmap\nNoneType\nNone\n\n\n\nvalmap\nNoneType\nNone\n\n\n\nft_cls\nNoneType\nNone\n\n\n\nkwargs\nVAR_KEYWORD\n\n\n\n\nReturns\nFT\n\ntype: ignore\n\n\n\n\nsource\n\n\nScriptV\n\n ScriptV (code:str='', id=None, cls=None, title=None, style=None,\n          attrmap=None, valmap=None, ft_cls=None, **kwargs)\n\nA Script w/ code or vfile: contents that doesn’t escape its code\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncode\nstr\n\n\n\n\nid\nNoneType\nNone\n\n\n\ncls\nNoneType\nNone\n\n\n\ntitle\nNoneType\nNone\n\n\n\nstyle\nNoneType\nNone\n\n\n\nattrmap\nNoneType\nNone\n\n\n\nvalmap\nNoneType\nNone\n\n\n\nft_cls\nNoneType\nNone\n\n\n\nkwargs\nVAR_KEYWORD\n\n\n\n\nReturns\nFT\n\ntype: ignore",
    "crumbs": [
      "Bridge",
      "Bridge widget helpers"
    ]
  },
  {
    "objectID": "bridge_widget.html#anysource",
    "href": "bridge_widget.html#anysource",
    "title": "Bridge widget helpers",
    "section": "anysource",
    "text": "anysource\n\nsource\n\nanysource\n\n anysource (*args:str|pathlib.Path|__main__.SourceProvider)\n\nRead and join text from files, vfiles or strings\n\nsource\n\n\nSourceProvider\n\n SourceProvider (*args, **kwargs)\n\nObject with a .source attribute (string or callable returning string)\n\nclass Src:\n    source = 'c'\ntest_eq(anysource('a', '', 'b', Src()), 'a\\nb\\nc')",
    "crumbs": [
      "Bridge",
      "Bridge widget helpers"
    ]
  },
  {
    "objectID": "bridge_widget.html#js---python",
    "href": "bridge_widget.html#js---python",
    "title": "Bridge widget helpers",
    "section": "JS -> Python",
    "text": "JS -&gt; Python\n\nclass Cons(anywidget.AnyWidget):\n    _esm = '''\nexport default {\n  async initialize({ model, experimental }) {\n    model.on(\"msg:custom\", async (cmd) =&gt; {\n      const { kind, msg, timeout } = cmd;\n      if (kind === 'brd-command') {\n        let [res, buffers] = await experimental.invoke(\"_upper\", msg, {signal: AbortSignal.timeout(timeout)});\n        console.log(res);\n      } else console.log(cmd);\n    }); \n  },\n};\n'''\n    @anywidget.experimental.command  # type: ignore\n    def _upper(self, msg, buffers):\n        # print(f'{msg=} {buffers=}')\n        return msg.upper(), buffers\n    \n    def to_console(self, msg):\n        self.send({'kind': 'brd-command', 'msg': msg, 'timeout': 5e3})\n\n\nfrom bridget.helpers import find_active_widgets, get_kernel_widgets_comms, get_active_widgets_comms\n\n\nww = find_active_widgets()\nww\n\n[]\n\n\n\nw = Cons()\n\n\nw.to_console('Hello, worlds!')\n\nThe (still) experimental invoke feature of AnyWidget allows for blocking operations frontend-backend.\nWe’ll also need the other way around, but that’s is surprisingly more involved.",
    "crumbs": [
      "Bridge",
      "Bridge widget helpers"
    ]
  },
  {
    "objectID": "bridge_widget.html#python---js",
    "href": "bridge_widget.html#python---js",
    "title": "Bridge widget helpers",
    "section": "Python -> JS",
    "text": "Python -&gt; JS\n\nfrom matplotlib import pyplot as plt\nimport numpy as np\n\n\nbase = 1.5\nfig = plt.figure()#figsize=(4, 2.67))\nplt.plot(base + base**np.arange(10));\n\n\n\n\n\n\n\n\n\nsource\n\nexp_backoff\n\n exp_backoff (base:float=1.552, max_value:float=10.0)\n\nExponential backoff generator of values until cumulative value is max_value, then yields 0 and stops.\n\nlist(itertools.takewhile(lambda t: t, exp_backoff()))\n\n[1.552, 2.408704, 3.7383086080000005, 2.3009873919999997]\n\n\n\nlist(itertools.takewhile(lambda t: t, exp_backoff(max_value=60)))\n\n[1.552,\n 2.408704,\n 3.7383086080000005,\n 5.8018549596160005,\n 9.004478897324033,\n 13.9749512486469,\n 21.68912433789999,\n 1.8305779485130742]\n\n\n\nlist(itertools.takewhile(lambda t:t, exp_backoff(0.4, 3)))\n\n[0.4, 0.8, 1.2000000000000002, 0.5999999999999996]\n\n\n\nlist(itertools.takewhile(lambda t:t, exp_backoff(1*0.0776, 1)))\n\n[0.0776, 0.1552, 0.2328, 0.3104, 0.22399999999999998]\n\n\n\nboff = iter(exp_backoff())\nt, sum = 1, 0\nwhile t:\n    sum += (t := next(boff))\n    print(f\"t: {t:0.4f} sum: {sum:0.4f}\")\n\nt: 1.5520 sum: 1.5520\nt: 2.4087 sum: 3.9607\nt: 3.7383 sum: 7.6990\nt: 2.3010 sum: 10.0000\nt: 0.0000 sum: 10.0000\n\n\n\ntm = 5.0\nboff = iter(exp_backoff(tm*0.1, tm))\nt, sum = 1, 0\nwhile t:\n    sum += (t := next(boff))\n    print(f\"t: {t:0.4f} sum: {sum:0.4f}\")\n\nt: 0.5000 sum: 0.5000\nt: 1.0000 sum: 1.5000\nt: 1.5000 sum: 3.0000\nt: 2.0000 sum: 5.0000\nt: 0.0000 sum: 5.0000\n\n\n\nclass BlockingMixin(W.Widget):\n    \"A mixin for widgets that supports blocking custom messages with the front-end.\"\n    _cbs: CallbackDispatcher\n\n    def on_msg(self, cb, remove=False):\n        if not hasattr(self, '_cbs'): self._cbs = CallbackDispatcher()\n        self._cbs.register_callback(cb, remove=remove)\n        super().on_msg(cb, remove=remove)\n\n    def send(self, msg, timeout: float|None=None, buffers=None, \n            sleep: float = 1/15, n: int = 10, show: Callable[[bool], None]|None = None\n    ) -&gt; tuple[Any|Empty, Any|Empty]|None:\n        \"Send `msg` to the front-end. If `timeout` seconds is not None, calling blocks.\"\n        if timeout is None: \n            for cb in self._cbs.callbacks: super().on_msg(cb)\n            return super().send(msg, buffers)\n        for cb in self._cbs.callbacks: super().on_msg(cb, remove=True)\n        res = self._send_msg(msg, buffers,timeout, sleep, n, show)\n        # NOTE: restoring normal callbacks now implies that front-end can yet send back a result\n        # even if python timeout was triggered.\n        for cb in self._cbs.callbacks: super().on_msg(cb)\n        return res\n    \n    async def asend(self, msg, timeout: float=5.0, buffers=None, \n            sleep: float = 1/15, n: int = 10, show: Callable[[bool], None]|None = None\n    ) -&gt; tuple[Any|Empty, Any|Empty]|None:\n        \"Send `msg` to the front-end. Call will end after `timeout` seconds if `timeout` is not None.\"\n        for cb in self._cbs.callbacks: super().on_msg(cb, remove=True)\n        res = await self._asend_msg(msg, buffers, timeout, sleep, n, show)\n        for cb in self._cbs.callbacks: super().on_msg(cb)\n        return res\n\n    def _send_msg(self, msg, buffers=None, timeout: float = 5.0, \n            sleep: float = 1/15, n: int = 10, show: Callable[[bool], None]|None = None\n    ) -&gt; tuple[Any|Empty, Any|Empty]:\n        \"Send blocking `msg` to the front-end. Return response tuple (content, buffers), or (empty, empty) if `timeout`.\"\n        boff = iter(exp_backoff(timeout*0.776, timeout))\n        timeout, start_time = next(boff), time.time()\n        result = None\n        def _on_msg(_, msg, buffers):\n            nonlocal result\n            if result is None: result = (msg, buffers)\n        super().on_msg(_on_msg)  # register transient callback\n        try:\n            super().send(msg, buffers)\n            with ui_events() as ui_poll:\n                while True:\n                    if sleep: time.sleep(sleep)\n                    ui_poll(n)\n                    if (time.time() - start_time) &gt; timeout:\n                        timeout, start_time = next(boff), time.time()\n                        if not timeout: result = (empty, empty)\n                    if result is not None:\n                        content, buffers = result\n                        if content is empty: return (empty, empty)\n                        self._cbs(self, content, buffers)\n                        return content, buffers\n                    if show: show(False)\n        except Exception as e:\n            if isinstance(e, RuntimeError): raise\n            raise RuntimeError(f\"Error during message processing: {str(e)}\") from e\n        finally:\n            super().on_msg(_on_msg, True)  # unregister callback\n            if show: show(True)\n\n    async def _asend_msg(self, msg, buffers=None, timeout: float = 5.0, \n            sleep: float = 1/15, n: int = 10, show: Callable[[bool], None]|None = None\n    ) -&gt; tuple[Any|Empty, Any|Empty]:\n        \"Send async `msg` to the front-end. Return response tuple (content, buffers), or (empty, empty) if `timeout`.\"\n        boff = iter(exp_backoff(timeout*0.776, timeout))\n        timeout, start_time = next(boff), time.time()\n        result = None\n        def _on_msg(w, msg, buffers):\n            nonlocal result\n            if result is None: result = (msg, buffers)\n        super().on_msg(_on_msg)\n        try:\n            super().send(msg, buffers)\n            async with ui_events() as ui_poll:\n                while True:\n                    await ui_poll(10)\n                    if (time.time() - start_time) &gt; timeout:\n                        timeout, start_time = next(boff), time.time()\n                        if not timeout: result = (empty, empty)\n                    if result is not None:\n                        content, buffers = result\n                        if content is empty: return (empty, empty)\n                        self._cbs(self, content, buffers)\n                        return (content, buffers)\n                    if sleep: await anyio.sleep(sleep)\n                    if show: show(False)\n        except Exception as e:\n            if isinstance(e, RuntimeError): raise\n            raise RuntimeError(f\"Error during message processing: {str(e)}\") from e\n        finally:\n            super().on_msg(_on_msg, True)\n            if show: show(True)\n\n\n\nblocks\n\nfunctions to block until a condition is met without blocking front-end interaction.\n\n\nsource\n\n\nblocking\n\n blocking (timeout:float=1, sleep:float=0.2, n:int=10,\n           show:Optional[Callable[[bool],NoneType]]=None)\n\n\nsource\n\n\nablocks\n\n ablocks (pred:Callable[...,bool], timeout:float=1, sleep:float=0.2,\n          n:int=10, show:Optional[Callable[[bool],NoneType]]=None)\n\nReturn True when pred returns True, or False when at least timeout seconds have passed.\n\nsource\n\n\nblocks\n\n blocks (pred:Callable[...,bool], timeout:float=1, sleep:float=0.2,\n         n:int=10, show:Optional[Callable[[bool],NoneType]]=None)\n\nBlock until pred is True, or at least timeout seconds have passed. Return False if timeout.\n\nclass Cnt:\n    def __init__(self, n=10, sleep=0.0): self.n, self.sleep, self.cnt = n, sleep, 0\n    def __call__(self):\n        self.cnt += 1\n        time.sleep(self.sleep)\n        return self.cnt &gt; self.n-1\n\nblocks(cntr := Cnt(10), n=20, sleep=0.1, show=_show)\ntest_eq(cntr.cnt, 10)\n\n._.\n\n\n\ndone = await ablocks(cntr := Cnt(10, 0.2), show=_show)\nif done: test_eq(cntr.cnt, 10)\nelse: print('timeout')\n\n._.\ntimeout\n\n\n\nwith blocking(n=20, sleep=0.0, show=_show) as pred:\n    cntr = Cnt(10)\n    test_is(pred(cntr), True)\n    test_eq(cntr.cnt, 10)\n\n._.\n\n\n\nwith blocking(show=_show) as pred:\n    cntr = Cnt(10, 0.2)\n    done = pred(cntr)\n    if done: test_eq(cntr.cnt, 10)\n    else: print('timeout')\n\n._.\ntimeout\n\n\n\nsource\n\n\nBlockingMixin\n\n BlockingMixin (**kwargs)\n\nMixin for widgets that supports blocking custom messages with the front-end.\n\nclass BlockingWidget(anywidget.AnyWidget, BlockingMixin):\n    _esm = anysource('// debugger;', '''\n    export default { \n        async initialize({ model }) {\n            function on_msg(msg) {\n                console.log(`Received message:`, msg);\n                if (!msg?.timeout) return model.send({ msg_id: msg.msg_id, response: 'no timeout' });\n                (function loop(n) {\n                    setTimeout(() =&gt; {\n                        n += 100\n                        if (n &gt; msg.timeout*1000) {\n                            console.log(`Sending response for msg_id:`, msg.msg_id);\n                            model.send({ msg_id: msg.msg_id, response: 'done waiting', error: null });\n                            return;\n                        }\n                        // console.log('.');\n                        loop(n);\n                    }, 100);\n                })(0);\n            }\n            model.on(\"msg:custom\", on_msg);\n            setTimeout(() =&gt; {\n                console.log(`Initialized.`);\n                model.set('_loaded', true); model.save_changes();\n            }, 1000);\n        }\n    };\n    ''')\n\n    def test_send(self, msg, buffers=None, *, timeout: float|None=None, \n            sleep: float = 1/15, n: int = 10, show: Callable[[bool], None]|None = None):\n        self._start_time = time.time()\n        print(f'Sending message {msg}...')\n        res = self.send(msg, buffers, timeout=timeout, sleep=sleep, n=n, show=show)\n        return None if res == (empty, empty) else res\n    \n    async def test_asend(self, msg, buffers=None, *, timeout: float=5.0, \n        sleep: float = 1/15, n: int = 10, show: Callable[[bool], None]|None = None\n    ):\n        self._start_time = time.time()\n        print(f'Sending message {msg}...')\n        res = await self.asend(msg, buffers, timeout=timeout, sleep=sleep, n=n, show=show)\n        return None if res == (empty, empty) else res\n\n    def __init__(self, *args, **kwargs):\n        # self.setup_init_on_msg(self._handle_message)\n        self.on_msg(self._handle_message)\n        super().__init__(*args, **kwargs)\n        print('Initializing...')\n\n    def _handle_message(self, _, msg, buffers):\n        e = time.time()\n        self._last_message = e, msg\n        print(f'\\nelapsed: {e-self._start_time:.3f}s Received message: {msg}, buffers: {buffers}')\n\n\ncleanupwidgets('w')\n\nw = BlockingWidget()\ntest_eq(w.loaded(), False)\n\nInitializing...\n\n\n\nidx = kounter('blocking')\nprint(idx)\nw.test_send({'msg_id': idx})\n\n1\nSending message {'msg_id': 1}...\n\n\n\ncleanupwidgets('w')\n\nw = BlockingWidget.create(show=_show, sleep=0.1)\nprint(f'loaded={w.loaded()}')\ntest_eq(w.loaded(), True)\n\nInitializing...\n._.\nloaded=True\n\n\n\nidx = kounter('blocking')\na = w.test_send({'msg_id': idx, 'timeout': 2}, timeout=1, show=_show)\nprint(f\"{idx=} -&gt;\", f\"Timeout {time.time()-w._start_time:3f}\" if not a else f\"{a=}\")\ntest_is(a, None)\n\nSending message {'msg_id': 2, 'timeout': 2}...\n._.\nidx=2 -&gt; Timeout 1.162399\n\n\n\nidx = kounter('blocking')\na = w.test_send({'msg_id': idx, 'timeout': 2}, timeout=3, show=_show)\nprint(f\"{idx=} -&gt;\", f\"Timeout {time.time()-w._start_time:3f}\" if not a else f\"{a=}\")\ntest_eq(a[0]['msg_id'], idx)  # type: ignore\n\nSending message {'msg_id': 3, 'timeout': 2}...\n._.\nidx=3 -&gt; a=({'msg_id': 3, 'response': 'done waiting', 'error': None}, [])\n\n\n\n# cell 95\nidx = kounter('blocking')\n# a = await w.test_asend({'msg_id': idx, 'timeout': 2}, timeout=1, show=_show)  # async send not working fine in Lab\na = w.test_send({'msg_id': idx, 'timeout': 2}, timeout=1, show=_show)\n\nSending message {'msg_id': 4, 'timeout': 2}...\n._.\n\n\n\nprint(f\"{idx=} -&gt;\", f\"Timeout {time.time()-w._start_time:3f}\" if not a else f\"{a=}\")\ntest_is(a, None)\n\nidx=4 -&gt; Timeout 2.071541\n\n\n\n# cell 97\n\nidx = kounter('blocking')\n# a = await w.test_asend({'msg_id': idx, 'timeout': 2}, timeout=3, show=_show)  # async send not working fine in Lab\na = w.test_send({'msg_id': idx, 'timeout': 2}, timeout=3, show=_show)\n\nSending message {'msg_id': 5, 'timeout': 2}...\n._.\n\n\n\nprint(f\"{idx=} -&gt;\", f\"Timeout {time.time()-w._start_time:3f}\" if not a else f\"{a=}\")\ntest_eq(a[0]['msg_id'], idx)  # type: ignore\n\nidx=5 -&gt; a=({'msg_id': 5, 'response': 'done waiting', 'error': None}, [])\n\n\n\ncleanupwidgets('w')\n\n\nfrom bridget.helpers import find_active_widgets, get_kernel_widgets_comms, get_active_widgets_comms\n\n\nww = find_active_widgets()\nww\n\n[{'type': 'BlockingWidget',\n  'model_id': 'f6e695c02332468c8fb9eebaa82b209b',\n  'comm': False},\n {'type': 'Layout',\n  'model_id': '73f02d3c1cf141d2a4729292217c4a32',\n  'comm': False},\n {'type': 'BlockingWidget',\n  'model_id': 'a7455c7f4ad04efa850f3a8cb964e6d6',\n  'comm': False},\n {'type': 'Layout',\n  'model_id': '4686dc666c0b464c8ef9047c0a97ea2d',\n  'comm': False},\n {'type': 'Cons',\n  'model_id': 'd024a861a43e4e6da226d96e6234c25d',\n  'comm': False},\n {'type': 'Layout',\n  'model_id': '925cf3052d664de8b9f9e2a8a70268de',\n  'comm': False}]\n\n\n\nimport ipywidgets.widgets.widget\n\n\nipywidgets.widgets.widget._instances\n\n{}\n\n\n\n[_.comm_id for _ in get_active_widgets_comms()]\n\n[]",
    "crumbs": [
      "Bridge",
      "Bridge widget helpers"
    ]
  },
  {
    "objectID": "anydoc.html",
    "href": "anydoc.html",
    "title": "AnyDoc",
    "section": "",
    "text": "from pathlib import Path\n\nimport fastcore.all as FC\nfrom fastcore.test import *\nfrom pote.common import shortens\nfrom rich.console import Console\n\n\n\ncprint = (console := Console(width=120)).print\n\n\n\n&lt;div id=\"editorjs\" style=\"height: 300px; overflow: auto; border: 1px solid #ccc;\"&gt;&lt;/div&gt;\n\n\n&lt;script type=\"module\"&gt;\ndebugger;\nimport EditorJS from 'https://cdn.jsdelivr.net/npm/@editorjs/editorjs@latest/dist/editorjs.mjs'\n\nconst editor = new EditorJS({ \n  holder: 'editorjs', \n})&lt;/script&gt;",
    "crumbs": [
      "(very) WIP",
      "AnyDoc"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bridget",
    "section": "",
    "text": "Serverless HTMX + FastHTML: full FastHTML + HTMX functionality in Jupyter environments, with no HTTP server required.\nExtended FastHTML routing system: integrates seamlessly with Python methods.\nWidget system (WIP): build UI components with minimal JavaScript.\nReal-time notebook introspection: capture the full notebook structure dynamically, without .ipynb files.\nEnvironment-agnostic: supports VSCode, JupyterLab, and other interfaces.\n\nBridget relies on companion extensions for JupyterLab/Notebook and VSCode/Cursor. These capture the live notebook state and feed it directly to Bridget’s Python kernel.",
    "crumbs": [
      "Bridget"
    ]
  },
  {
    "objectID": "index.html#key-features",
    "href": "index.html#key-features",
    "title": "Bridget",
    "section": "",
    "text": "Serverless HTMX + FastHTML: full FastHTML + HTMX functionality in Jupyter environments, with no HTTP server required.\nExtended FastHTML routing system: integrates seamlessly with Python methods.\nWidget system (WIP): build UI components with minimal JavaScript.\nReal-time notebook introspection: capture the full notebook structure dynamically, without .ipynb files.\nEnvironment-agnostic: supports VSCode, JupyterLab, and other interfaces.\n\nBridget relies on companion extensions for JupyterLab/Notebook and VSCode/Cursor. These capture the live notebook state and feed it directly to Bridget’s Python kernel.",
    "crumbs": [
      "Bridget"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Bridget",
    "section": "Installation",
    "text": "Installation\nAs Bridget is in early development, it is not yet on PyPI. A development installation requires NodeJS and the pnpm package manager.\nClone the repository, install JS dependencies with pnpm, then perform an editable Python install. This builds the JS components and installs the nbinspect-lab Jupyter extension automatically.\n# 1. Clone the repository\ngit clone https://github.com/civvic/bridget.git\ncd bridget\n\n# 2. Install JavaScript dependencies (JupyterLab extension)\npnpm install\n\n# 3. Install Python package with all dependencies\npip install -e .[dev]\n\nNote: step 2 is only necessary if you are going to use Jupyter Lab/Notebook. For VSCode, simply install the extension. See below.",
    "crumbs": [
      "Bridget"
    ]
  },
  {
    "objectID": "index.html#vscode-extension-installation",
    "href": "index.html#vscode-extension-installation",
    "title": "Bridget",
    "section": "VSCode Extension Installation",
    "text": "VSCode Extension Installation\nFor VSCode and Cursor, install the nbinspect-vscode extension manually. The .vsix file is inside packages/nbinspect-vscode.\nTo install: - Run the command Extensions: Install from VSIX… - Or open the Extensions view, click the “…” menu, and select Install from VSIX….",
    "crumbs": [
      "Bridget"
    ]
  },
  {
    "objectID": "index.html#quick-start",
    "href": "index.html#quick-start",
    "title": "Bridget",
    "section": "Quick Start",
    "text": "Quick Start\nA minimal stateful counter component:\nfrom bridget.common import get_app\nfrom fasthtml.components import Button\n\napp, bridget, rt = get_app()  # Initialize Bridget and app\n\ndef counter(n=0):\n    @rt('/inc')\n    def increment(n:int):\n        return Button(f\"Count: {n+1}\", value=f\"{n+1}\", name='n', hx_post='/inc', hx_swap='outerHTML')\n    return increment(n-1)\n\ncounter()\nFor more detailed examples, review the notebooks in the nbs/examples/ directory.",
    "crumbs": [
      "Bridget"
    ]
  },
  {
    "objectID": "index.html#core-concepts",
    "href": "index.html#core-concepts",
    "title": "Bridget",
    "section": "Core Concepts",
    "text": "Core Concepts\n\nThe Bridge\nThe Bridge class (14_bridge.ipynb) provides the low-level communication layer between Python and JavaScript, replacing the HTTP transport layer typically used by HTMX.\n\n\nBridget and get_app()\nThe Bridget class (32_bridget.ipynb) and get_app() function provide the high-level API for creating interactive components. This is your main entry point.\n\n\nRouting System\nBridget extends FastHTML’s routing system (04_route_provider.ipynb) to work with Python methods and class instances, enabling stateful components.\n\n\nPlugin System\nBridget’s functionality can be extended through plugins (16_bridge_plugins.ipynb), enabling modular feature development.\n\n\nNotebook State\nAccess live notebook structure and content (21_nb_state.ipynb) without saving files, enabling powerful introspection capabilities.",
    "crumbs": [
      "Bridget"
    ]
  },
  {
    "objectID": "index.html#documentation-structure",
    "href": "index.html#documentation-structure",
    "title": "Bridget",
    "section": "Documentation Structure",
    "text": "Documentation Structure\n\nCore Components\n\n00_common.ipynb - Common imports and utilities\n01_helpers.ipynb - Helper functions and utilities\n10_bridge_widget.ipynb - BridgeWidget infrastructure\n14_bridge.ipynb - Bridge class (low-level messaging)\n32_bridget.ipynb - Bridget class and get_app() entry point\n\n\n\nFastHTML Integration\n\n03_fasthtml_patching.ipynb - FastHTML modifications for serverless operation\n04_route_provider.ipynb - Extended routing system\n\n\n\nNotebook State\n\n07_nb.ipynb - High-level notebook API\n15_nb_hooks.ipynb - Notebook event hooks\n21_nb_state.ipynb - Notebook state introspection\n\n\n\nComponents and Widgets\n\n40_details_json.ipynb - Lazy-loading JSON viewer\n50_widget.ipynb - Widget development guide\n\n\n\nExamples\n\nexamples/quickstart.ipynb - Quick start guide\nexamples/htmx_examples.ipynb - HTMX patterns",
    "crumbs": [
      "Bridget"
    ]
  },
  {
    "objectID": "index.html#compatibility-and-development",
    "href": "index.html#compatibility-and-development",
    "title": "Bridget",
    "section": "Compatibility and Development",
    "text": "Compatibility and Development\nBridget is developed with nbdev and requires Python 3.12+. Core dependencies like fasthtml and anywidget are installed automatically. It is regularly tested on macOS with VSCode, Jupyter Notebook, and Jupyter Lab, and is expected to function in any environment where anywidget/ipywidgets is supported.",
    "crumbs": [
      "Bridget"
    ]
  },
  {
    "objectID": "index.html#project-status",
    "href": "index.html#project-status",
    "title": "Bridget",
    "section": "Project Status",
    "text": "Project Status\nBridget is experimental and integrates Jupyter, FastHTML, and HTMX.\nIts primary goal, inspired by Donald Knuth’s concept of Literate Programming, is to create truly dynamic documents where any content (including cell outputs) can be directly edited and interacted with in place.\nCurrent status: - ✅ Core architecture for serverless HTMX and notebook introspection is functional. - ✅ Key HTMX patterns are supported and demonstrated in the nbs/examples/ notebooks. - ⚠️ The API is unstable and subject to significant change. - ⛔ Not recommended for use in production environments. - 📝 Documentation and more complex examples are in active development.",
    "crumbs": [
      "Bridget"
    ]
  },
  {
    "objectID": "widget.html#link",
    "href": "widget.html#link",
    "title": "Widget (very WIP)",
    "section": "Link",
    "text": "Link\n\nReplicate traitlets.link\n\n\ndef link(pair1, pair2, transform=None):\n    \"\"\"\n    Bidirectionally link two fields, possibly on the same object, using optional transform (forward, reverse).\n    pair1, pair2: tuples of (object, attr_name)\n    transform: (func1→2, func2→1), or None.\n    \"\"\"\n    a_obj, a_field = pair1\n    b_obj, b_field = pair2\n    tf_ab = transform[0] if transform and transform[0] else (lambda v: v)\n    tf_ba = transform[1] if transform and transform[1] else (lambda v: v)\n\n    def on_a(val):\n        new = tf_ab(val)\n        if getattr(b_obj, b_field) != new:\n            with getattr(a_obj.events, a_field).blocked():\n                setattr(b_obj, b_field, new)\n\n    def on_b(val):\n        new = tf_ba(val)\n        if getattr(a_obj, a_field) != new:\n            with getattr(b_obj.events, b_field).blocked():\n                setattr(a_obj, a_field, new)\n\n    getattr(a_obj.events, a_field).connect(on_a)\n    getattr(b_obj.events, b_field).connect(on_b)\n\n\n@psygnal.evented\n@dataclass\nclass Item:\n    x: float = 0.0\n    y: float = 0.0\n\n\nitem = Item(x=32.0, y=0.0)\n\n# x is Fahrenheit, y is Celsius\nf_to_c = lambda f: (f - 32) * 5/9\nc_to_f = lambda c: c * 9/5 + 32\n\nlink((item, \"x\"), (item, \"y\"), (f_to_c, c_to_f))\n\nitem.x = 212.0\ntest_eq(item.y, 100)\n\nitem.y = 0.0\ntest_eq(item.x, 32)",
    "crumbs": [
      "(very) WIP",
      "Widget (very WIP)"
    ]
  },
  {
    "objectID": "widget.html#debug_req",
    "href": "widget.html#debug_req",
    "title": "Widget (very WIP)",
    "section": "_debug_req",
    "text": "_debug_req\n\ndef _debug_req(name, url, method, body):\n    return {\n        'headers': {\n            'HX-Request': 'true',\n            'HX-Trigger-Name': name,\n            'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        'headerNames': {'hx-request': 'HX-Request', 'hx-current-url': 'HX-Current-URL', \n                        'hx-trigger-name': 'HX-Trigger-Name', 'hx-trigger-value': 'HX-Trigger-Value',\n                        'content-type':'Content-Type'},\n        'status': 0,\n        'method': method,\n        'url': url,\n        'async': True,\n        'timeout': 0,\n        'withCredentials': False,\n        'body': body,\n    }\n\n\n@dataclass\nclass Person:\n    name: str\n    age: int = 0\n\n    events: ClassVar[psygnal.SignalGroupDescriptor] = psygnal.SignalGroupDescriptor()\n\n@dataclass\nclass Citizen(Person):\n    country: str = 'USA'\n    _city: str = 'New York'\n\n@dataclass\nclass Employee(Citizen):\n    company: str = 'Central Perk'\n\ne = Employee(name='John', age=30)\npsygnal.is_evented(Employee), psygnal.is_evented(e)\n\n(True, True)\n\n\n\ne.events.signals\n\nmappingproxy({'_city': &lt;_DataclassFieldSignalInstance '_city' on &lt;SignalGroup 'EmployeeSignalGroup' with 5 signals&gt;&gt;,\n              'age': &lt;_DataclassFieldSignalInstance 'age' on &lt;SignalGroup 'EmployeeSignalGroup' with 5 signals&gt;&gt;,\n              'company': &lt;_DataclassFieldSignalInstance 'company' on &lt;SignalGroup 'EmployeeSignalGroup' with 5 signals&gt;&gt;,\n              'country': &lt;_DataclassFieldSignalInstance 'country' on &lt;SignalGroup 'EmployeeSignalGroup' with 5 signals&gt;&gt;,\n              'name': &lt;_DataclassFieldSignalInstance 'name' on &lt;SignalGroup 'EmployeeSignalGroup' with 5 signals&gt;&gt;})",
    "crumbs": [
      "(very) WIP",
      "Widget (very WIP)"
    ]
  },
  {
    "objectID": "widget.html#label",
    "href": "widget.html#label",
    "title": "Widget (very WIP)",
    "section": "Label",
    "text": "Label\n\n# W.Label('Hello, World!')\n\n&lt;div class=\"lm-Widget jupyter-widgets widget-inline-hbox widget-label\"&gt;Hello, World!&lt;/div&gt;\n\n@dataclass\nclass Label(Control):\n    value: str = ''\n    def controls(self): return (self.value, )\n\n\nv = Label('Hello, world!')\nwith bridge_cfg(auto_show=False):\n    display(v.__ft__())\nv\n\n&lt;div class=\"control label\"&gt;Hello, world!&lt;/div&gt;\n\n\nHello, world!\n\n\n\n\n\nv.value\n\n'Hello, world!'",
    "crumbs": [
      "(very) WIP",
      "Widget (very WIP)"
    ]
  },
  {
    "objectID": "widget.html#text",
    "href": "widget.html#text",
    "title": "Widget (very WIP)",
    "section": "Text",
    "text": "Text\n\n# W.Text('Hello, World!')\n\n&lt;div class=\"lm-Widget jupyter-widgets widget-inline-hbox widget-text\"&gt;\n    &lt;label class=\"widget-label\" for=\"8ffde047-0ce3-4324-97a8-8f9bb6bb5a22\" style=\"display: none;\"&gt;&lt;/label&gt;\n    &lt;input type=\"text\" id=\"8ffde047-0ce3-4324-97a8-8f9bb6bb5a22\" class=\"widget-input\" placeholder=\"​\"&gt;\n&lt;/div&gt;\n\n@dataclass\nclass Text(Value):\n    value: str = ''\n    @ar('/value', methods=['POST'], name='value')\n    def changed(self, value:str):\n        with self._updating(): self.value = value\n    def value_control(self):\n        return H.Input(name='value', value=self.value,\n                hx_post=self.ar.value, hx_trigger='input changed', hx_swap='none')\n\n\nv = Text('Hello, world!')\nwith bridge_cfg(auto_show=False):\n    display(v.__ft__())\nv\n\n&lt;div id=\"Text_Text_1-1764705844\" class=\"control value text\"&gt;\n  &lt;input name=\"value\" value=\"Hello, world!\" hx-post=\"/Text/Text_1-1764705844/value\" hx-trigger=\"input changed\" hx-swap=\"none\"&gt;\n&lt;/div&gt;\n\n\n\n  \n\n\n\n\n\n\nv.value\n\n'Hello, world!'\n\n\n\nv.value = 'Good-Bye to All That'\n\n\nshow_routes(app)\n\n[\n    Mount(path='/Value', name='Value', app=&lt;fasthtml.core.FastHTML object at 0x14b3ed1f0&gt;),\n    Mount(path='/Text', name='Text', app=&lt;fasthtml.core.FastHTML object at 0x14b41db80&gt;)\n]\n\n\n\n[Mount(path='/Text_1-1764705844', name='Text_1-1764705844', app=&lt;fasthtml.core.FastHTML object at 0x14b41e1e0&gt;)]\n\n\n\n[Route(path='/value', name='value', methods=['POST'])]",
    "crumbs": [
      "(very) WIP",
      "Widget (very WIP)"
    ]
  },
  {
    "objectID": "widget.html#textarea",
    "href": "widget.html#textarea",
    "title": "Widget (very WIP)",
    "section": "TextArea",
    "text": "TextArea\n\n# W.Textarea('Hello, World!')\n\n&lt;div class=\"lm-Widget jupyter-widgets widget-inline-hbox widget-textarea\"&gt;\n    &lt;label class=\"widget-label\" for=\"ea87d53a-15a1-474f-a14d-2f84302a10d5\" style=\"display: none;\"&gt;&lt;/label&gt;\n    &lt;textarea rows=\"\" id=\"ea87d53a-15a1-474f-a14d-2f84302a10d5\" class=\"widget-input\" placeholder=\"​\"&gt;&lt;/textarea&gt;\n&lt;/div&gt;\n\n@dataclass\nclass TextArea(Value):\n    value: str = ''\n    @ar('/value', methods=['POST'], name='value')\n    def changed(self, value:str):\n        with self._updating(): self.value = value\n    def value_control(self):\n        return H.Textarea(name='value', \n                hx_post=self.ar.value, hx_trigger='keyup changed throttle:100ms', hx_swap='none')(self.value)\n\n\napp.routes.clear()\n\n\nv = TextArea('Hello, world!')\nwith bridge_cfg(auto_show=False):\n    display(v.__ft__())\nv\n\n&lt;div id=\"TextArea_TextArea_1-1764705844\" class=\"control value textarea\"&gt;\n&lt;textarea name=\"value\" hx-post=\"/TextArea/TextArea_1-1764705844/value\" hx-trigger=\"keyup changed throttle:100ms\" hx-swap=\"none\"&gt;Hello, world!&lt;/textarea&gt;&lt;/div&gt;\n\n\n\nHello, world!\n\n\n\n\n\nv.value\n\n'Hello, world!'\n\n\n\nv.value = 'Adieu!'\n\n\nshow_routes(app)\n\n[Mount(path='/TextArea', name='TextArea', app=&lt;fasthtml.core.FastHTML object at 0x12f21e5d0&gt;)]\n\n\n\n[Mount(path='/TextArea_1-1764705844', name='TextArea_1-1764705844', app=&lt;fasthtml.core.FastHTML object at 0x14b41eae0&gt;)]\n\n\n\n[Route(path='/value', name='value', methods=['POST'])]",
    "crumbs": [
      "(very) WIP",
      "Widget (very WIP)"
    ]
  },
  {
    "objectID": "widget.html#combobox",
    "href": "widget.html#combobox",
    "title": "Widget (very WIP)",
    "section": "Combobox",
    "text": "Combobox\n&lt;div class=\"lm-Widget jupyter-widgets widget-inline-hbox widget-text\"&gt;\n    &lt;label class=\"widget-label\" for=\"81e63e64-d351-4dd4-860a-6982c4d65bee\" style=\"\"&gt;Combobox:&lt;/label&gt;\n    &lt;input type=\"text\" id=\"81e63e64-d351-4dd4-860a-6982c4d65bee\" class=\"widget-input\" placeholder=\"Choose Someone\" list=\"62fd0f57-8eef-4b16-97d8-2648d373e452\"&gt;\n    &lt;datalist id=\"62fd0f57-8eef-4b16-97d8-2648d373e452\"&gt;\n        &lt;option value=\"Paul\"&gt;&lt;/option&gt;\n        &lt;option value=\"John\"&gt;&lt;/option&gt;\n        &lt;option value=\"George\"&gt;&lt;/option&gt;\n        &lt;option value=\"Ringo\"&gt;&lt;/option&gt;\n    &lt;/datalist&gt;\n&lt;/div&gt;\n\n@dataclass\nclass Combobox(Value):\n    value: str = ''\n    options: list[str] = field(default_factory=list)\n    def value_control(self):\n        return (\n            H.Input(type='text', name='value', list='abc-456', placeholder='Choose Someone', \n                hx_post=self.ar.value, hx_swap='none',\n            ),\n            H.Datalist(id='abc-456')(*map(lambda x:H.Option(value=x), self.options)),\n        )\n\n\nv = Combobox('Ringo', ['Paul', 'John', 'George', 'Ringo'])\nwith bridge_cfg(auto_show=False):\n    display(v.__ft__())\nv\n\n&lt;div id=\"Combobox_Combobox_1-1764705844\" class=\"control value combobox\"&gt;\n  &lt;input type=\"text\" name=\"value\" list=\"abc-456\" placeholder=\"Choose Someone\" hx-post=\"/Combobox/Combobox_1-1764705844/value\" hx-swap=\"none\"&gt;\n&lt;datalist id=\"abc-456\"&gt;&lt;option value=\"Paul\"&gt;&lt;/option&gt;&lt;option value=\"John\"&gt;&lt;/option&gt;&lt;option value=\"George\"&gt;&lt;/option&gt;&lt;option value=\"Ringo\"&gt;&lt;/option&gt;&lt;/datalist&gt;&lt;/div&gt;\n\n\n\n  \n\n\n\n\n\n\nv.value\n\n'Ringo'\n\n\n\nv.value = 'George'\n\n\nshow_routes(app)\n\n[\n    Mount(path='/TextArea', name='TextArea', app=&lt;fasthtml.core.FastHTML object at 0x12f21e5d0&gt;),\n    Mount(path='/Combobox', name='Combobox', app=&lt;fasthtml.core.FastHTML object at 0x14b54cb00&gt;)\n]\n\n\n\n[Mount(path='/Combobox_1-1764705844', name='Combobox_1-1764705844', app=&lt;fasthtml.core.FastHTML object at 0x14b54cb30&gt;)]\n\n\n\n[Route(path='/value', name='value', methods=['POST'])]",
    "crumbs": [
      "(very) WIP",
      "Widget (very WIP)"
    ]
  },
  {
    "objectID": "widget.html#inttext",
    "href": "widget.html#inttext",
    "title": "Widget (very WIP)",
    "section": "IntText",
    "text": "IntText\n\n@dataclass\nclass IntText(Value):\n    value: int = 0\n    @ar('/value', methods=['POST'], name='value')\n    def changed(self, value:int):\n        with self._updating(): self.value = value\n        # return the update to allow feedback\n        return self.value or str(self.value)  # fasthtml inconditionally handles 0s from route handlers as falsy, not bona fide values\n    def value_control(self):\n        return H.Input(name='value', value=str(self.value), type='number', \n                # hx_post=f\"{self.ar.to('changed')}\", hx_trigger='input changed throttle:50ms', hx_swap='none')\n                hx_post=self.ar.value, hx_trigger='input changed', hx_swap='none')\n\n\napp.routes.clear()\n\n\nv = IntText(5)\nwith bridge_cfg(auto_show=False):\n    display(v.__ft__())\nv\n\n&lt;div id=\"IntText_IntText_1-1764705844\" class=\"control value inttext\"&gt;\n  &lt;input name=\"value\" value=\"5\" type=\"number\" hx-post=\"/IntText/IntText_1-1764705844/value\" hx-trigger=\"input changed\" hx-swap=\"none\"&gt;\n&lt;/div&gt;\n\n\n\n  \n\n\n\n\n\n\nv.value\n\n5\n\n\n\nv.value = 10\n\n\nshow_routes(app)\n\n[Mount(path='/IntText', name='IntText', app=&lt;fasthtml.core.FastHTML object at 0x12f21e5d0&gt;)]\n\n\n\n[Mount(path='/IntText_1-1764705844', name='IntText_1-1764705844', app=&lt;fasthtml.core.FastHTML object at 0x14b7357f0&gt;)]\n\n\n\n[Route(path='/value', name='value', methods=['POST'])]",
    "crumbs": [
      "(very) WIP",
      "Widget (very WIP)"
    ]
  },
  {
    "objectID": "widget.html#boundedint",
    "href": "widget.html#boundedint",
    "title": "Widget (very WIP)",
    "section": "BoundedInt",
    "text": "BoundedInt\n\n@dataclass\nclass BoundedInt(IntText):\n    min: int = 0\n    max: int = 100\n    step: int = 1\n\n    def setup_values(self):\n        if (val := self.value) &lt; self.min: self.value = self.min\n        elif val &gt; self.max: self.value = self.max\n\n    def value_control(self):\n        return super().value_control()(min=str(self.min), max=str(self.max), step=str(self.step))\n\n\nv = BoundedInt(10, 5, 15)\nwith bridge_cfg(auto_show=False):\n    display(v.__ft__())\nv\n\n&lt;div id=\"BoundedInt_BoundedInt_1-1764705844\" class=\"control value inttext boundedint\"&gt;\n  &lt;input name=\"value\" value=\"10\" type=\"number\" hx-post=\"/BoundedInt/BoundedInt_1-1764705844/value\" hx-trigger=\"input changed\" hx-swap=\"none\" min=\"5\" max=\"15\" step=\"1\"&gt;\n&lt;/div&gt;\n\n\n\n  \n\n\n\n\n\n\nv.value\n\n10\n\n\n\nv.max = 10\ntest_eq(v.value, 10)",
    "crumbs": [
      "(very) WIP",
      "Widget (very WIP)"
    ]
  },
  {
    "objectID": "widget.html#intslider",
    "href": "widget.html#intslider",
    "title": "Widget (very WIP)",
    "section": "IntSlider",
    "text": "IntSlider\n\n@dataclass\nclass IntSlider(BoundedInt):\n    readout: bool = True\n    readout_format: str = 'd'\n    \n    _wrapper_class = 'slider'\n    def value_control(self):\n        return super().value_control()(type='range', hx_target='next text', hx_swap='textContent')\n    def controls(self):\n        return (H.Label(_for='value')('Scale'), _n,\n                self.value_control(),\n                H.Text(id='spanscale', style='inline')(self.value), _n)\n\n\n# brt.bridge.logger.show(clear=True)\n\n\niv = IntSlider()\nwith bridge_cfg(auto_show=False):\n    display(iv.__ft__())\niv\n\n&lt;div id=\"IntSlider_IntSlider_1-1764705844\" class=\"control value inttext boundedint slider\"&gt;\n&lt;label for=\"value\"&gt;Scale&lt;/label&gt;\n  &lt;input name=\"value\" value=\"0\" type=\"range\" hx-post=\"/IntSlider/IntSlider_1-1764705844/value\" hx-trigger=\"input changed\" hx-swap=\"textContent\" min=\"0\" max=\"100\" step=\"1\" hx-target=\"next text\"&gt;\n&lt;text id=\"spanscale\" style=\"inline\"&gt;0&lt;/text&gt;\n&lt;/div&gt;\n\n\n\nScale\n  \n0\n\n\n\n\n\n\n# response = brt(_debug_req('value', iv.ar.value.to(), 'POST', 'value=50'))\n\n\niv.value\n\n0\n\n\n\niv.value = 89\n\n\niv.min = 20\ntest_eq(iv.value, 89)\n\n\niv.max = 80\ntest_eq(iv.value, 80)\n\n\niv2 = IntSlider(33, step=2)\niv2\n\n\nScale\n  \n33\n\n\n\n\n\n\niv3 = IntSlider()\niv4 = IntSlider()\nlink((iv3, 'value'), (iv4, 'value'))\n\nbox = Div(style='display: flex; gap: 1em;')(iv3, iv4)\nbox\n\nScale\n0\nScale\n0\n\n\n\n\niv3.value = 22\ntest_eq((iv3.value, iv4.value), (22, 22))\n\n\niv5 = IntSlider(57)\niv6 = IntSlider()\nlink((iv5, 'value'), (iv6, 'value'))\n\nbox = HBox([iv5, iv6])\nbox\n\n\n  \nScale\n    \n57\n  \n  \nScale\n    \n0",
    "crumbs": [
      "(very) WIP",
      "Widget (very WIP)"
    ]
  },
  {
    "objectID": "widget.html#dropdown",
    "href": "widget.html#dropdown",
    "title": "Widget (very WIP)",
    "section": "Dropdown",
    "text": "Dropdown\n&lt;div class=\"lm-Widget jupyter-widgets widget-inline-hbox widget-dropdown\"&gt;\n    &lt;label class=\"widget-label\" for=\"3f6a6063-c1fa-4f3d-966b-185eb49eb67f\" style=\"\"&gt;Number:&lt;/label&gt;\n    &lt;select id=\"3f6a6063-c1fa-4f3d-966b-185eb49eb67f\"&gt;\n        &lt;option data-value=\"1\" value=\"1\"&gt;1&lt;/option&gt;\n        &lt;option data-value=\"2\" value=\"2\"&gt;2&lt;/option&gt;\n        &lt;option data-value=\"3\" value=\"3\"&gt;3&lt;/option&gt;\n    &lt;/select&gt;\n&lt;/div&gt;\n\n@dataclass\nclass _Select(Value):\n    options: list[tuple[str, Any]|Any] = field(default_factory=list)\n\n    def __post_init__(self):\n        self.options = [t if isinstance(t, tuple) else (str(t), t) for t in self.options]\n        super().__post_init__()\n\n    @cached_property\n    def values(self) -&gt; list[Any]: return [v for _,v in self.options]\n    @property\n    def index(self) -&gt; int|None: return self.values.index(self.value) if self.value in self.values else None\n    @index.setter\n    def index(self, i:int): self.value = self.values[i] if i&gt;=0 and i&lt;len(self.options) else None\n    \n    def on_options(self, nw: Any):\n        try: del self.values\n        except Exception: pass\n        if self.value not in self.values: self.value = None\n\n    @ar('/value', methods=['POST'], name='value')\n    def changed(self, value:str, index:int):\n        with self._updating():\n            # self.index = index\n            self.value = self.options[index][1]\n            self.setup_values()\n\n\n@dataclass\nclass Dropdown(_Select):\n    def value_control(self):\n        return H.Div(cls='inline-hbox')(\n            H.Label(self.description)(\n                H.Select(name='value', \n                    hx_post=self.ar.value, \n                    hx_vals=\"js:{'index':event.target.selectedIndex}\", hx_swap='none')(\n                    *[Option(value=opt[1], selected=i==self.index)(opt[0]) for i,opt in enumerate(self.options)]\n                )\n            )\n        )\n\n\nv = Dropdown(\n    value=2,\n    options=[('One', 1), ('Two', 2), ('Three', 3)]\n)\nwith bridge_cfg(auto_show=False):\n    display(v.__ft__())\nv\n\n&lt;div id=\"Dropdown_Dropdown_1-1764705844\" class=\"control value dropdown\"&gt;\n  &lt;div class=\"inline-hbox\"&gt;\n&lt;label&gt;&lt;select name=\"value\" hx-post=\"/Dropdown/Dropdown_1-1764705844/value\" hx-swap=\"none\" hx-vals=\"js:{'index':event.target.selectedIndex}\"&gt;&lt;option value=\"1\"&gt;One&lt;/option&gt;&lt;option value=\"2\" selected&gt;Two&lt;/option&gt;&lt;option value=\"3\"&gt;Three&lt;/option&gt;&lt;/select&gt;&lt;/label&gt;  &lt;/div&gt;\n&lt;/div&gt;\n\n\n\n  \nOneTwoThree  \n\n\n\n\n\n\nv.value, v.index\n\n(2, 1)\n\n\n\nv.value = 1",
    "crumbs": [
      "(very) WIP",
      "Widget (very WIP)"
    ]
  },
  {
    "objectID": "widget.html#select",
    "href": "widget.html#select",
    "title": "Widget (very WIP)",
    "section": "Select",
    "text": "Select\n&lt;div class=\"lm-Widget jupyter-widgets widget-inline-hbox widget-select\"&gt;\n    &lt;label class=\"widget-label\" for=\"a3c9d534-7c03-4948-9cf2-87dc8f353e1f\" style=\"\"&gt;OS:&lt;/label&gt;\n    &lt;select id=\"a3c9d534-7c03-4948-9cf2-87dc8f353e1f\" size=\"5\"&gt;\n        &lt;option data-value=\"Linux\" value=\"Linux\"&gt;Linux&lt;/option&gt;\n        &lt;option data-value=\"Windows\" value=\"Windows\"&gt;Windows&lt;/option&gt;\n        &lt;option data-value=\"macOS\" value=\"macOS\"&gt;macOS&lt;/option&gt;\n    &lt;/select&gt;\n&lt;/div&gt;\n\n@dataclass\nclass SelectArea(_Select):\n    rows: int = 5\n\n    def value_control(self):\n        return H.Div(cls='inline-hbox')(\n            H.Label(self.description)(\n                H.Select(name='value', size=self.rows,\n                    hx_post=self.ar.value, \n                    hx_vals=\"js:{'index':event.target.selectedIndex}\", hx_swap='none')(\n                    *[H.Option(value=opt[1], selected=i==self.index)(opt[0]) for i,opt in enumerate(self.options)]\n                )\n            )\n        )\n\n\nv = SelectArea(\n    options=['Linux', 'Windows', 'macOS'],\n    value='macOS',\n    # rows=10,\n    description='OS:',\n)\nwith bridge_cfg(auto_show=False):\n    display(v.__ft__())\nv\n\n&lt;div id=\"SelectArea_SelectArea_1-1764705844\" class=\"control value selectarea\"&gt;\n  &lt;div class=\"inline-hbox\"&gt;\n&lt;label&gt;OS:&lt;select name=\"value\" size=\"5\" hx-post=\"/SelectArea/SelectArea_1-1764705844/value\" hx-swap=\"none\" hx-vals=\"js:{'index':event.target.selectedIndex}\"&gt;&lt;option value=\"Linux\"&gt;Linux&lt;/option&gt;&lt;option value=\"Windows\"&gt;Windows&lt;/option&gt;&lt;option value=\"macOS\" selected&gt;macOS&lt;/option&gt;&lt;/select&gt;&lt;/label&gt;  &lt;/div&gt;\n&lt;/div&gt;\n\n\n\n  \nOS:LinuxWindowsmacOS  \n\n\n\n\n\n\nv.value, v.index\n\n('macOS', 2)\n\n\n\nv.value = 'Windows'",
    "crumbs": [
      "(very) WIP",
      "Widget (very WIP)"
    ]
  },
  {
    "objectID": "widget.html#selectmultiple",
    "href": "widget.html#selectmultiple",
    "title": "Widget (very WIP)",
    "section": "SelectMultiple",
    "text": "SelectMultiple\n&lt;div class=\"lm-Widget jupyter-widgets widget-inline-hbox widget-select widget-select-multiple\"&gt;\n    &lt;label class=\"widget-label\" for=\"c3af7603-7856-431f-ad6a-15ede273e09f\" style=\"\"&gt;Fruits&lt;/label&gt;\n    &lt;select multiple=\"\" id=\"c3af7603-7856-431f-ad6a-15ede273e09f\" size=\"5\"&gt;\n        &lt;option data-value=\"Apples\" value=\"Apples\"&gt;Apples&lt;/option&gt;\n        &lt;option data-value=\"Oranges\" value=\"Oranges\"&gt;Oranges&lt;/option&gt;\n        &lt;option data-value=\"Pears\" value=\"Pears\"&gt;Pears&lt;/option&gt;\n    &lt;/select&gt;\n&lt;/div&gt;\n\n@dataclass\nclass SelectMultiple(_Select):\n    value: list[Any] = field(default_factory=list)\n    # index: list[int] = field(default_factory=list)\n    rows: int = 5\n\n    @property\n    def index(self) -&gt; list[int]: return [self.values.index(_) for _ in self.value]\n    @index.setter\n    def index(self, ii:list[int]): self.value = [self.values[_] for _ in ii if _ in range(len(self.options))]\n\n    @ar('/value', methods=['POST'], name='value')\n    def changed(self, value:list[str]=[], index:list[int]=[]):\n        with self._updating():\n            # self.index = index\n            self.value = [self.values[_] for _ in index if _ in range(len(self.options))]\n            self.setup_values()\n\n    def value_control(self):\n        return H.Div(cls='inline-hbox')(\n            H.Label(self.description)(\n                H.Select(name='value', size=self.rows, multiple=True, \n                    hx_post=self.ar.value, \n                    hx_vals=\"js:{'index':[...event.target.selectedOptions].map(i=&gt;i.index)}\", hx_swap='none')(\n                    *[H.Option(value=opt[1], selected=i in self.index)(opt[0]) for i,opt in enumerate(self.options)]\n                )\n            )\n        )\n\n\nv = SelectMultiple(\n    options=['Apples', 'Oranges', 'Pears'],\n    value=['Pears'],\n    description='Fruits',\n)\nwith bridge_cfg(auto_show=False):\n    display(v.__ft__())\nv\n\n&lt;div id=\"SelectMultiple_SelectMultiple_1-1764705844\" class=\"control value selectmultiple\"&gt;\n  &lt;div class=\"inline-hbox\"&gt;\n&lt;label&gt;Fruits&lt;select name=\"value\" size=\"5\" multiple hx-post=\"/SelectMultiple/SelectMultiple_1-1764705844/value\" hx-swap=\"none\" hx-vals=\"js:{'index':[...event.target.selectedOptions].map(i=&gt;i.index)}\"&gt;&lt;option value=\"Apples\"&gt;Apples&lt;/option&gt;&lt;option value=\"Oranges\"&gt;Oranges&lt;/option&gt;&lt;option value=\"Pears\" selected&gt;Pears&lt;/option&gt;&lt;/select&gt;&lt;/label&gt;  &lt;/div&gt;\n&lt;/div&gt;\n\n\n\n  \nFruitsApplesOrangesPears  \n\n\n\n\n\n\nv.value, v.index\n\n(['Pears'], [2])",
    "crumbs": [
      "(very) WIP",
      "Widget (very WIP)"
    ]
  },
  {
    "objectID": "widget.html#radiobuttons",
    "href": "widget.html#radiobuttons",
    "title": "Widget (very WIP)",
    "section": "RadioButtons",
    "text": "RadioButtons\n&lt;div class=\"lm-Widget widget-radio\"&gt;\n    &lt;label class=\"widget-label\" title=\"null\" style=\"\"&gt;Pizza topping:&lt;/label&gt;\n    &lt;div class=\"widget-radio-box widget-radio-box-vertical\" style=\"margin-bottom: 2px;\"&gt;\n        &lt;label&gt;pepperoni&lt;input type=\"radio\" value=\"0\" data-value=\"pepperoni\"&gt;&lt;/label&gt;\n        &lt;label&gt;pineapple&lt;input type=\"radio\" value=\"1\" data-value=\"pineapple\"&gt;&lt;/label&gt;\n        &lt;label&gt;anchovies&lt;input type=\"radio\" value=\"2\" data-value=\"anchovies\"&gt;&lt;/label&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n\napp.routes.clear()\n\n\n@dataclass\nclass RadioButtons(_Select):\n    @ar('/value', methods=['POST'], name='value')\n    def changed(self, index:int):\n        with self._updating():\n            self.value = self.options[index-1][1]\n    def value_control(self):\n        n = self.ar.name().split(':')[-1]\n        wid = self.wrapper_id()\n        return H.Div(cls='inline-hbox')(\n            H.Label(self.description)(\n                Div(name='value', hx_post=self.ar.value, \n                    hx_vals=\"js:{'index':[...document.querySelectorAll('#\" + wid + \" input')].filter(e=&gt;e.checked)[0].value}\",\n                    hx_trigger=f\"click from:(#{wid} input)\", hx_swap='none')(\n                    *[H.Label(opt[0], \n                        H.Input(type='radio', value=i+1, name=n, checked=i==self.index)) \n                    for i,opt in enumerate(self.options)]\n                )\n            )\n        )\n\n\nv = RadioButtons(\n    options=['Larry', 'Moe', 'Curly'],\n    value='Moe',\n    description='3S:',\n)\nwith bridge_cfg(auto_show=False):\n    display(v.__ft__())\nv\n\n&lt;div id=\"RadioButtons_RadioButtons_1-1764705844\" class=\"control value radiobuttons\"&gt;\n  &lt;div class=\"inline-hbox\"&gt;\n&lt;label&gt;3S:      &lt;div name=\"value\" hx-post=\"/RadioButtons/RadioButtons_1-1764705844/value\" hx-trigger=\"click from:(#RadioButtons_RadioButtons_1-1764705844 input)\" hx-swap=\"none\" hx-vals=\"js:{'index':[...document.querySelectorAll('#RadioButtons_RadioButtons_1-1764705844 input')].filter(e=&gt;e.checked)[0].value}\"&gt;\n&lt;label&gt;Larry          &lt;input type=\"radio\" value=\"1\" name=\"RadioButtons_1-1764705844\"&gt;\n&lt;/label&gt;&lt;label&gt;Moe          &lt;input type=\"radio\" value=\"2\" name=\"RadioButtons_1-1764705844\" checked&gt;\n&lt;/label&gt;&lt;label&gt;Curly          &lt;input type=\"radio\" value=\"3\" name=\"RadioButtons_1-1764705844\"&gt;\n&lt;/label&gt;      &lt;/div&gt;\n&lt;/label&gt;  &lt;/div&gt;\n&lt;/div&gt;\n\n\n\n  \n3S:      \nLarry          \nMoe          \nCurly          \n      \n  \n\n\n\n\n\n\nv.value, v.index\n\n('Moe', 1)\n\n\n\nshow_routes(app)\n\n[Mount(path='/RadioButtons', name='RadioButtons', app=&lt;fasthtml.core.FastHTML object at 0x12f21e5d0&gt;)]\n\n\n\n[\n    Mount(path='/RadioButtons_1-1764705844', name='RadioButtons_1-1764705844', app=&lt;fasthtml.core.FastHTML object at \n0x14b94aa80&gt;)\n]\n\n\n\n[Route(path='/value', name='value', methods=['POST'])]\n\n\n\n&lt;div class=\"widget-box\"&gt;\n    &lt;div class=\"lm-Widget jupyter-widgets widget-inline-hbox widget-label\"&gt;Pizza topping with a very long label:&lt;/div&gt;\n    &lt;div class=\"radio\" style=\"width: max-content;\"&gt;\n        &lt;label class=\"widget-label\" title=\"null\" style=\"display: none;\"&gt;&lt;/label&gt;\n        &lt;div class=\"radio-box radio-box-vertical\"&gt;\n            &lt;label&gt;pepperoni&lt;input type=\"radio\" value=\"0\" data-value=\"pepperoni\"&gt;&lt;/label&gt;\n            &lt;label&gt;pineapple&lt;input type=\"radio\" value=\"1\" data-value=\"pineapple\"&gt;&lt;/label&gt;\n            &lt;label&gt;anchovies&lt;input type=\"radio\" value=\"2\" data-value=\"anchovies\"&gt;&lt;/label&gt;\n            &lt;label&gt;and the long name that will fit fine and the long name that will fit fine and the long name that will fit fine &lt;input type=\"radio\" value=\"3\" data-value=\"and%20the%20long%20name%20that%20will%20fit%20fine%20and%20the%20long%20name%20that%20will%20fit%20fine%20and%20the%20long%20name%20that%20will%20fit%20fine%20\"&gt;&lt;/label&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;",
    "crumbs": [
      "(very) WIP",
      "Widget (very WIP)"
    ]
  },
  {
    "objectID": "widget.html#togglebuttons",
    "href": "widget.html#togglebuttons",
    "title": "Widget (very WIP)",
    "section": "ToggleButtons",
    "text": "ToggleButtons\n&lt;div class=\"lm-Widget widget-toggle-buttons\"&gt;\n    &lt;label class=\"widget-label\" title=\"null\" style=\"\"&gt;Speed:&lt;/label&gt;\n    &lt;div&gt;\n        &lt;button type=\"button\" class=\"widget-toggle-button jupyter-button mod-active\" data-value=\"Slow\" value=\"0\" title=\"Description of slow\"&gt;Slow&lt;i&gt;&lt;/i&gt;&lt;/button&gt;\n        &lt;button type=\"button\" class=\"widget-toggle-button jupyter-button\" data-value=\"Regular\" value=\"1\" title=\"Description of regular\"&gt;Regular&lt;i&gt;&lt;/i&gt;&lt;/button&gt;\n        &lt;button type=\"button\" class=\"widget-toggle-button jupyter-button\" data-value=\"Fast\" value=\"2\" title=\"Description of fast\"&gt;Fast&lt;i&gt;&lt;/i&gt;&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/div&gt;",
    "crumbs": [
      "(very) WIP",
      "Widget (very WIP)"
    ]
  },
  {
    "objectID": "widget.html#value-1",
    "href": "widget.html#value-1",
    "title": "Widget (very WIP)",
    "section": "Value",
    "text": "Value\n\n# class Value(T.HasTraits, Control):\n#     value = T.Any()\n    \n#     @T.observe('value')\n#     def on_value(self, _):\n#         if self.bridget and not self._updating_:\n#             self.bridget.bridge.commander.swap(f\"#{self.ar.name()}\", to_xml(self.__ft__()), swapStyle='innerHTML')\n\n\n# app.routes.clear()\n\n\n# v = Value(value='Hello, world!')\n# with bridge_cfg(auto_show=False):\n#     display(v.__ft__())\n# v\n\n\n# v.value\n\n\n# v.value = 'bye!'",
    "crumbs": [
      "(very) WIP",
      "Widget (very WIP)"
    ]
  },
  {
    "objectID": "widget.html#numeric-1",
    "href": "widget.html#numeric-1",
    "title": "Widget (very WIP)",
    "section": "Numeric",
    "text": "Numeric\n\n# class Numeric(Value):\n#     value: int\n#     min, max, step = None, None, None\n#     input_type = 'number'\n#     hx_target, hx_swap = None, 'none'\n#     @ar('/value', methods=['POST'])\n#     def changed(self, value:int):\n#         with self._updating(): self.value = value\n#         return self.value  # fasthtml handles 0s from route handlers as falsy, not bona fide values\n#     def __ft__(self):\n#         return Input(type=self.input_type, name='value', \n#                     value=self.value, min=self.min, max=self.max, step=self.step,\n#                     hx_post=f\"/{self.ar.to()}/value\", hx_trigger='input changed throttle:100ms', \n#                     hx_target=self.hx_target, hx_swap=self.hx_swap)\n\n\n# class _Int(_Value):\n#     value: int\n#     min, max, step = None, None, None\n#     input_type = 'number'\n#     hx_target, hx_swap = None, 'none'\n#     @ar('/value', methods=['POST'])\n#     def changed(self, value:int):\n#         with self._updating(): self.value = value\n#         return self.value  # fasthtml handles 0s from route handlers as falsy, not bona fide values\n#     def value_control(self):\n#         return Input(type=self.input_type, name='value', value=self.value, min=self.min, max=self.max, step=self.step,\n#                 hx_post=f\"/{self.ar.to()}/value\", hx_trigger='input changed throttle:100ms', \n#                 hx_target=self.hx_target, hx_swap=self.hx_swap)\n\n\nIntText\n\n# class IntText(Value, _Int):\n#     value = T.CInt()\n\n\n# v = IntText(value=5)\n# with bridge_cfg(auto_show=False):\n#     display(v.__ft__())\n# v\n\n\n# v.value\n\n\n# v.value = 17\n\n\n\nBoundedInt\n\n# class BoundedInt(IntText):\n#     min = T.CInt(0)\n#     max = T.CInt(100)\n#     step = T.Int(1)\n\n#     def value_control(self): return super().value_control()(min=self.min, max=self.max, step=self.step)\n\n\n# v = BoundedInt(value=10, min=5, max=15)\n# with bridge_cfg(auto_show=False):\n#     display(v.__ft__())\n# v\n\n\n# v.value\n\n\n# v.max = 17\n\n\n\nIntSlider\n\n# class IntSlider(BoundedInt):\n#     readout:bool=True; readout_format:str='d'\n    \n#     _wrapper_class = 'slider'\n#     def value_control(self):\n#         return Input(type='range', name='value', min=self.min, max=self.max, step=self.step, value=self.value,\n#                 hx_post=f\"/{self.ar.to()}/value\", hx_trigger='input changed throttle:100ms', \n#                 hx_target='next text', hx_swap='textContent')\n#     def setup_controls(self):\n#         return (Label(_for='value')('Scale'), _n,\n#                 self.value_control(),\n#                 Text(id='spanscale', style='inline')(self.value), _n)\n\n\n# iv = IntSlider()\n# with bridge_cfg(auto_show=False):\n#     display(iv.__ft__())\n# iv\n\n\n# iv.value\n\n\n# iv.value = 77\n\n\n# iv2 = IntSlider(step=2)\n# iv2\n\n\n# iv3 = IntSlider()\n# iv4 = IntSlider()\n# # brt.mount(iv3, show=False)\n# # brt.mount(iv4, show=False)\n# T.link((iv3, 'value'), (iv4, 'value'))\n\n# box = Div(style='display: flex; gap: 1em;')(iv3, iv4)\n# box\n\n\n# iv3.value = 22\n# test_eq(iv4.value, 22)",
    "crumbs": [
      "(very) WIP",
      "Widget (very WIP)"
    ]
  },
  {
    "objectID": "bridge_plugins.html",
    "href": "bridge_plugins.html",
    "title": "Bridge plugins",
    "section": "",
    "text": "bridge = get_bridge(show_logger=True, wait=5)",
    "crumbs": [
      "Bridge",
      "Bridge plugins"
    ]
  },
  {
    "objectID": "bridge_plugins.html#test-swap",
    "href": "bridge_plugins.html#test-swap",
    "title": "Bridge plugins",
    "section": "Test swap",
    "text": "Test swap\n\n&lt;div id=\"output-99\"&gt;Original&lt;/div&gt;\n\n\nOriginal\n\n\n\ncmdr.swap('#output-99', '&lt;div&gt;Swapped!&lt;/div&gt;', swapStyle='innerHTML')\n\n\ncmdr.close()",
    "crumbs": [
      "Bridge",
      "Bridge plugins"
    ]
  },
  {
    "objectID": "bridge_plugins.html#section",
    "href": "bridge_plugins.html#section",
    "title": "Bridge plugins",
    "section": "—-",
    "text": "—-\nFirst steps exploring automation. Skip it.\n\n\n\n# HTMXCommander plugin\n\n\nWe can use HTMXCommander by itself. But probably, it’ll be more useful as a bridge plugin.\n\n\n\nsource\n\nHTMXCommanderPlugin\n\n HTMXCommanderPlugin (ctx:str='', src:str|pathlib.Path='', bridge=None)\n\nInherit from this to have all attr accesses in self._xtra passed down to self.default\n\nbridge.add_plugins((cmdr := HTMXCommanderPlugin()), wait=5)\n\n\n(d := Div(id='output-9999')('Original 2'))\n\nOriginal 2\n\n\n\ncmdr.swap(d, Div('Swapped 2'), swapStyle='innerHTML')\n\n\ndef swap(self,*args, **kwargs): \n    bridge.commander.swap(self, *args, **kwargs)\nFC.patch_to(FT)(swap)\n\n\ndiv = Div(id='output-99999')('Original 3')\ndiv\n\nOriginal 3\n\n\n\ndiv.swap('&lt;div&gt;Swapped 3&lt;/div&gt;', swapStyle='innerHTML')",
    "crumbs": [
      "Bridge",
      "Bridge plugins"
    ]
  },
  {
    "objectID": "nbdev_rt.html",
    "href": "nbdev_rt.html",
    "title": "nbdev_rt",
    "section": "",
    "text": "nb = get_nb()\nbridge = get_bridge()\n\n\nnb.cells\n\n\nnb.cells[10]\n\n\nsource\n\nNBDev_rt\n\n NBDev_rt (ctx:str='', src:str|pathlib.Path='', bridge=None)\n\nInherit from this to have all attr accesses in self._xtra passed down to self.default\n\nbridge.logger.show(clear=True)\n\n\nbridge.add_plugins(nbrt := NBDev_rt())\n\n\nthis(-3)\n\n\nnb = NB.from_NB(cast(NB, bridge.state))\n\nnb.process(cb := IpynbConvertCB(in_vscode_notebook()))\nipynb_json = cb.notebook\n\nnb = nbformat.reads(json.dumps(ipynb_json), as_version=nbformat.NO_CONVERT, capture_validation_error=(derr := {}))\ntest_eq(derr, {})\n\n# DetailsJSON(ipynb_json)\nRenderJSON(nb, init_level=1, max_height=400).display()\n\n\nnb.cells[14]\n\n\nprocr = NBProcessor(nb=nb)\nprocr.process()\n\n\nfrom nbdev.maker import ModuleMaker\nfrom nbdev.export import ExportModuleProc\n\n\nsource\n\n\nshow_doc\n\n show_doc (sym, renderer=None, name:str|None=None, title_level:int=3)\n\nShow signature and docstring for sym\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsym\n\n\nSymbol to document\n\n\nrenderer\nNoneType\nNone\nOptional renderer (defaults to markdown)\n\n\nname\nstr | None\nNone\nOptionally override displayed name of sym\n\n\ntitle_level\nint\n3\nHeading level to use for symbol name",
    "crumbs": [
      "(very) WIP",
      "nbdev_rt"
    ]
  },
  {
    "objectID": "prompt.html",
    "href": "prompt.html",
    "title": "Prompt",
    "section": "",
    "text": "import fastcore.all as FC\nfrom fastcore.xml import to_xml\n\n\nfrom fastcore.test import *\nfrom rich.console import Console\n\n\nfrom pote.widget import cleanupwidgets\n\n\n\ncprint = (console := Console(width=120)).print\n\n\n\nConfiguration\n\n\nPrompt\n\nsource\n\nPrompt\n\n Prompt ()\n\nInitialize self. See help(type(self)) for accurate signature.\n:: exclude :: ## Example\n\nprint('hello')\n\n\nHelp me write a **function** that takes a list of numbers and returns the sum of the squares of the numbers.\n\nBe sure to include docstring and type hints. Be as concise as possible.\n\n\ndef sum_of_squares(numbers: list[int]) -&gt; int:\n    return sum(x**2 for x in numbers)\n\n\n# Help me write a function that takes a list of numbers and returns the maximum of the numbers.\n\ndef max_of_numbers(numbers: list[int]) -&gt; int:\n    return max(numbers)\n\nClaude, I’m working on the Bridget project, specifically on one aspect: notebook state management. We’ve created @18_nb_state.ipynb to develop a widget that will:\n\nAccess notebook state from a DOM script element of type application/json with id notebook-state-json\nAllow Python code to read that state object\nEventually be integrated into the main Bridget class\n\nKey context: - Using AnyWidget for cross-environment compatibility (see examples here 16_htmx.ipynb, 22_bridget.ipynb) - Following @nbdev development patterns - State element is created as normal notebook output (IPython display) - No direct interaction with VSCode extension\nI’ll help you develop the notebook state management component in smaller, focused chunks. Let’s start with a high-level implementation plan and then break it down into actionable steps.\n\n\nInitial Implementation Plan\n\nState Access Layer\n\nJavaScript module to access DOM state element\nMessage passing between JS and Python via AnyWidget\nBasic state structure types in Python\n\nState Management\n\nState parsing and validation\nChange detection and events\nOutput tracking\n\nAPI Design\n\nPython interface for state access\nMethods for output manipulation\nEvent callbacks\n\n\nLet’s start with the first concrete step: implementing the JavaScript state access layer. Here’s what I propose for the initial implementation:\n\nfunction getNotebookState() {\n    const stateElement = document.querySelector('script[type=\"application/x-notebook-state+json\"]');\n    return stateElement ? JSON.parse(stateElement.textContent) : null;\n}\n\nfunction on_msg(msg) {\n    console.log(`new nbstate message: ${JSON.stringify(msg)}`);\n    // Handle commands from Python\n    if (msg.cmd === 'get_state') {\n        const state = getNotebookState();\n        this.model.send({ cmd: 'state_update', state });\n    }\n}\n\nexport default { \n    async initialize({ model }) {\n        console.log('NBState initialized');\n        model.on(\"msg:custom\", on_msg);\n        \n        // Send initial state\n        const state = getNotebookState();\n        if (state) model.send({ cmd: 'state_update', state });\n    }\n};\n\nWould you like me to explain this initial JavaScript implementation before we move on to the Python side?\n\n\n\nExport\n\nPrompt.export('gist')\n\n# or\n\n\nPrompt.export('nb')\n\n# or",
    "crumbs": [
      "(very) WIP",
      "Prompt"
    ]
  }
]